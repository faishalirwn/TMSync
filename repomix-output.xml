This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: docs/anilist.gql
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    context-recovery.md
    next-task.md
    smart-commit.md
    workflow-health.md
  settings.local.json
.github/
  workflows/
    ci.yml
    release.yml
    security.yml
.husky/
  pre-commit
docs/
  architecture/
    IMPLEMENTATION_DECISIONS.md
    MULTI_SERVICE_REDESIGN_SPEC.md
    SERVICE_DOMAIN_KNOWLEDGE.md
  CURRENT_STATE.md
  DESIGN_DECISIONS.md
  README.md
  TODO.md
public/
  manifest.json
  options.html
  popup.html
src/
  background/
    handlers/
      handleAuth.ts
      handleComments.ts
      handleHistory.ts
      handleMedia.ts
      handleRatings.ts
      handleScrobble.ts
    index.ts
    scrobbleOperationManager.ts
    serviceStatusManager.ts
    state.ts
  components/
    AuthenticationHub.tsx
    ErrorBoundary.tsx
    ServiceControlPanel.tsx
  content-scripts/
    main/
      components/
        CommentModal.tsx
        LoadingIndicator.tsx
        ManualSearchPrompt.tsx
        RewatchPrompt.tsx
        ScrobbleManager.tsx
        ScrobbleNotification.tsx
        StartWatchPrompt.tsx
      index.tsx
    trakt/
      index.tsx
  hooks/
    useMediaLifecycle.ts
    useMultiServiceAuth.ts
    useQuickLinkPreferences.ts
    useScrobbling.ts
    useServiceAuth.ts
    useServicePreferences.ts
    useServiceStatus.ts
    useTraktAuth.ts
  options/
    index.tsx
    minimal-test.tsx
  popup/
    index.tsx
  services/
    AniListService.ts
    index.ts
    ServiceRegistry.ts
    TraktService.ts
  styles/
    index.css
  test/
    mocks/
      chrome.ts
    setup.ts
    utils.tsx
  types/
    media.ts
    messaging.ts
    scrobbling.ts
    services.ts
    serviceStatus.ts
    serviceTypes.ts
    trakt.ts
  utils/
    __tests__/
      typeGuards.test.ts
    helpers/
      localRewatch.ts
    siteConfigs/
      baseConfig.ts
      cineby.ts
      freek.ts
      hexa.ts
      hydra.ts
      index.ts
      xprime.ts
    api.ts
    confidenceHelper.ts
    config.ts
    content.ts
    highlighting.ts
    serviceFiltering.ts
    servicePreferences.ts
    typeGuards.ts
  test-services.ts
webpack/
  webpack.common.js
  webpack.dev.js
  webpack.prod.js
.env.example
.gitignore
.nvmrc
.prettierignore
.prettierrc
CLAUDE.md
eslint.config.mjs
package.json
postcss.config.mjs
README.md
tsconfig.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(cp:*)",
      "Bash(pnpm build)",
      "Bash(pnpm dev:*)",
      "Bash(npx webpack:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "WebFetch(domain:docs.anilist.co)",
      "Bash(npm run typecheck:*)",
      "Bash(npm run build:*)",
      "Bash(npm run dev:*)",
      "Bash(pnpm add:*)",
      "Bash(pnpm test:*)",
      "Bash(pnpm exec:*)",
      "Bash(mkdir:*)",
      "Bash(chmod:*)",
      "Bash(pnpm format:*)",
      "Bash(pnpm lint:*)",
      "Bash(pnpm type-check:*)",
      "Bash(pnpm check-all:*)",
      "Bash(pnpm fix-all:*)",
      "Bash(npm run type-check:*)",
      "Bash(npm run lint)",
      "Bash(rg:*)",
      "Bash(git checkout:*)",
      "Bash(npm run test:types:*)",
      "Bash(npx tsc:*)",
      "Bash(npm run:*)",
      "Bash(node:*)",
      "Bash(npx tsx:*)",
      "Bash(ls:*)",
      "Bash(grep:*)",
      "Bash(git rebase:*)",
      "Bash(git stash push:*)",
      "Bash(git reset:*)",
      "Bash(git stash:*)",
      "WebFetch(domain:docs.anthropic.com)",
      "Bash(mv:*)"
    ],
    "deny": []
  }
}
</file>

<file path="docs/architecture/IMPLEMENTATION_DECISIONS.md">
# Implementation Decisions & Edge Case Handling

## Service State Conflicts

### Multi-Service State Display
- **Show all states** transparently in UI
- **Highlight most advanced state** (highest episode progress)
- **Re-evaluate** most advanced state after any service updates
- **Visual space**: Show essential info, optimize layout later

### Advanced State Logic
- **Trust most advanced**: If MAL shows ep 8, AniList shows ep 5 ‚Üí trust MAL ep 8
- **Special case**: "Completed + partial episodes" = treat as "watching"
- **Scrobbling**: Use most advanced state as baseline for episode progression

### Rewatch Handling
- **Unified prompt**: When multiple services have same state, show single rewatch prompt
- **State changes**: Re-evaluate after any service state update

## Scrobbling Controls

### Global Toggle Approach
- **Single toggle**: Removed per-service scrobble toggles
- **Location**: Integrated into service badge area
- **Scope**: Only affects scrobbling, not rating or comments
- **Authority**: Service enable/disable from options page overrides everything

### Service Authority Hierarchy
1. **Options page**: Service enable/disable (most authoritative)
2. **Service authentication**: Must be logged in
3. **Global scrobble toggle**: Enable/disable scrobbling only
4. **Service-specific errors**: Individual service failures

### Toggle Behavior
- **Partial failures**: Scrobble failures don't affect toggle state (unrelated)
- **Disabled services**: If Trakt disabled via options, toggle only affects AniList
- **Error states**: Show per-service error status separately from toggle

## Rating System

### Input & Conversion
- **One rating for all**: Single 10-point decimal input
- **No conversion preview**: Users learn service intricacies through experience
- **No per-service overrides**: Same rating intent for all services
- **Display current ratings**: Show what each service currently has

### Conversion Rules
- **Trakt**: Round to nearest 0.5 (half-star system)
- **AniList**: Convert to 100-point scale (7.5 ‚Üí 75)
- **MAL**: Round to nearest integer

## Comment System

### Tab Structure
- **Service-specific tabs**: Individual tabs for each service
- **Write to All tab**: Unified input with service selection

### Write to All Behavior
- **Service selection**: Checkboxes for each service (‚òë Trakt ‚òë AniList ‚òê MAL)
- **Dynamic validation**: Changes immediately when services unchecked/checked
- **Validation rules**: Apply most restrictive rules from selected services
- **Failed services**: Stay checked after failure for manual retry

### Error Handling
- **No automatic retry**: User must manually retry failed services
- **Show success/failure**: Display per-service status after submission
- **No complex sync**: Simple success/failure reporting

## Data Loading & Performance

### Request Strategy
- **Parallel loading**: Load all service data simultaneously
- **Partial display**: Show data as it loads (don't wait for slowest service)
- **Timeout handling**: If service takes >10 seconds, show partial data

### Cache Strategy
- **TBD**: Cache strategy to be determined during implementation
- **Priority**: Performance optimization for later phases

## Authentication & Errors

### Basic Retry Logic
- **Simple retry**: Basic retry on auth failures
- **Error after retries**: Show error if retries exhausted
- **No advanced queuing**: No complex retry queues or persistence

### Service Independence
- **Individual failures**: One service failure doesn't affect others
- **Per-service errors**: Show specific error messages per service
- **Graceful degradation**: Continue with working services

## Migration & Rollout

### No Migration Strategy
- **Unreleased product**: No existing user data to migrate
- **Clean implementation**: Start fresh with per-service architecture
- **No backward compatibility**: No need to support old unified approach

## Implementation Priorities

### Phase 1: Core Per-Service Display
1. Service state display with conflict resolution
2. Global scrobble toggle with proper authority hierarchy
3. Per-service rating display

### Phase 2: Comment System Redesign
1. Tabbed interface implementation
2. Write to All functionality with service selection
3. Dynamic validation and error handling

### Phase 3: Advanced Features
1. Performance optimization and caching
2. Enhanced error handling and retry logic
3. UI polish and space optimization

## Deferred Items

### Future Phases
- **Episode mapping conflicts**: Cross-service episode structure differences
- **Advanced caching**: Sophisticated cache invalidation strategies
- **Bulk operations**: Not applicable (one page = one show)
- **Privacy controls**: Service-specific privacy settings

### Out of Scope
- **Complex state reconciliation**: Don't try to sync conflicting service states
- **Advanced retry logic**: No queuing, persistence, or complex retry strategies
- **Per-service rating overrides**: Single rating intent for all services
</file>

<file path="docs/architecture/MULTI_SERVICE_REDESIGN_SPEC.md">
# Multi-Service Architecture Redesign Specification

## Problem Statement

The current unified approach creates UX confusion and technical complexity:

1. **State Synchronization Issues**: Users modify data on one service but not others, creating inconsistent states
2. **Service Paradigm Conflicts**: AniList (one note) vs Trakt (multiple comments) forced into same interface
3. **Complex Validation**: Different services have different requirements (5-word minimum, spoiler flags, etc.)
4. **Scrobbling Confusion**: Complex prompts for start tracking, rewatch when services have different states

## New Philosophy: Per-Service Independence with Unified Input Options

### Core Principles

1. **Respect Service Differences**: Each service maintains its own paradigm and state
2. **Show Actual State**: Display what each service actually has, not a unified view
3. **Optional Unified Input**: Provide convenience for multi-service input when user wants it
4. **Service Transparency**: User can see and understand differences between services

## Detailed Specifications

### 1. Rating System Redesign

#### Current Issues

- Single rating shown, unclear which service it's from
- User can't see if services have different ratings
- Unified input but no visibility into per-service state

#### New Approach: "Unified Input, Per-Service Display"

- **Display Phase**: Show what each service actually has with their native scales
- **Input Phase**: 10-point decimal system (0.0-10.0) with service conversion
- **Conversion**: Round/convert to each service's supported format
- **Transparency**: User sees exactly which services will be updated

### 2. Comment System Redesign

#### Current Issues

- Trying to unify AniList notes (single) with Trakt comments (multiple)
- Confusing validation and spoiler options
- User unclear about what happens when they submit

#### New Approach: Tabbed Interface with Unified Option

- **Tabbed Layout**: Separate tabs for each service plus "Write to All" tab
- **Service Separation**: Each service's comments/notes clearly separated
- **Unified Input**: "Write to All" tab with service rule toggle
- **Service Toggle**: User selects which services to send the unified comment to
- **Service-Specific Features**: Spoilers for Trakt only, length limits per service

### 3. Scrobbling System Simplification

#### Current Issues

- Complex prompts: start tracking, rewatch, manual search
- Services might have different watch states
- User confused about what each prompt means

#### New Approach: Simple Toggle with Service Control

- **No Prompts**: Remove start tracking, rewatch prompts entirely
- **Toggle Control**: Integrated into service badge area with per-service and toggle-all controls
- **Service Transparency**: Show what each service will do when scrobbling starts
- **State Independence**: Don't try to reconcile different service states
- **Rewatch Logic**: Service-specific rewatch handling (see SERVICE_DOMAIN_KNOWLEDGE.md)

## Technical Architecture Changes

### Service Independence

- Each service maintains its own complete state
- No attempt to reconcile or unify different service states
- UI layers handle display aggregation

### Data Flow

```typescript
User Action ‚Üí UI Layer ‚Üí Service Dispatcher ‚Üí Individual Services
                ‚Üì
         Per-Service Results ‚Üê Service Responses
                ‚Üì
            UI Update (per-service display)
```

### API Pattern

```typescript
// OLD: Unified response
getRating(media) ‚Üí number

// NEW: Per-service response
getRating(media) ‚Üí {
  trakt: { rating: 8, scale: '1-10' },
  anilist: { rating: 85, scale: '1-100' },
  mal: { rating: 8, scale: '1-10' }
}
```

## Implementation Strategy

### Phase 1: Rating System Redesign

1. Modify rating display to show per-service ratings
2. Update rating input to clearly show which services will be updated
3. Add service status indicators

### Phase 2: Comment System Redesign

1. Implement separated interface for comments
2. Create "Write to All" functionality
3. Separate service-specific validation and features

### Phase 3: Scrobbling Simplification

1. Remove complex prompts (rewatch, start tracking)
2. Implement simple scrobbling toggle in ScrobbleNotification
3. Add transparent service status during scrobbling

### Phase 4: Service Management Enhancement

1. Enhanced service panel with individual service states
2. Per-service preferences and controls
3. Service health monitoring and error handling

## Benefits of New Approach

1. **Clarity**: User sees exactly what each service has
2. **Flexibility**: Can interact with services individually or together
3. **Reliability**: No complex state synchronization to break
4. **Extensibility**: Easy to add new services without changing existing UX
5. **Transparency**: User understands what happens when they take actions

## Migration Strategy

1. Implement new interfaces alongside existing ones
2. Feature flag to switch between old/new approaches
3. Gradual rollout with user feedback
4. Remove old unified approach once new system is stable

## Additional Resources

- **SERVICE_DOMAIN_KNOWLEDGE.md**: Detailed service-specific business rules and rewatch logic
- **Current Implementation**: Phase 3 multi-service integration (unified approach)
- **Target Architecture**: Per-service independence with optional unified input
</file>

<file path="docs/architecture/SERVICE_DOMAIN_KNOWLEDGE.md">
# Service Domain Knowledge & Business Rules

## Service-Specific Rewatch Logic

### Trakt.tv
- **Simple**: Start scrobbling immediately, no status conflicts
- **Rewatch**: Handled transparently by service
- **Episodes**: Any episode can be scrobbled multiple times

### AniList
- **Status Check**: If user status is "COMPLETED", show inline notification in ScrobbleNotification asking if they want to change to "REWATCHING"
- **Episode Progress Logic**:
  - If current episode ‚â§ user's last watched episode: **No scrobbling/progress tracking**
  - If current episode > user's last watched episode: **Scrobble normally**
  - Continue until current episode = total episodes
  - When complete: Increment rewatch count by 1, set status to "COMPLETED"
  - On next rewatch: Repeat the same process

### MyAnimeList (MAL)
- **Same as AniList** but no "REWATCHING" status
- **Status Options**: Watching, Completed, On Hold, Dropped, Plan to Watch
- **Rewatch Logic**: Same episode progression rules as AniList
- **Limitation**: Cannot distinguish between first watch and rewatch in status

## Rating System

### Scale Standardization
- **Internal Scale**: 10-point decimal system (0.0 - 10.0)
- **Conversion Rules**:
  - **Trakt**: Round to nearest 0.5 (supports half-stars: 1.0, 1.5, 2.0, etc.)
  - **AniList**: Convert to 100-point scale (7.5 ‚Üí 75)
  - **MAL**: Round to nearest integer (7.5 ‚Üí 8)

### Conversion Examples
```
Internal ‚Üí Trakt ‚Üí AniList ‚Üí MAL
7.3      ‚Üí 7.5   ‚Üí 73      ‚Üí 7
8.7      ‚Üí 9.0   ‚Üí 87      ‚Üí 9
6.2      ‚Üí 6.0   ‚Üí 62      ‚Üí 6
```

## Comment System Rules

### Service Capabilities
- **Trakt**: Multiple comments, spoiler flags, 5-word minimum
- **AniList**: Single note, no spoilers, any length
- **MAL**: Single note, no spoilers, any length

### "Write to All" Validation
- **Service Selection**: User toggles which services to send to
- **Validation**: Apply most restrictive rules from selected services
- **If Trakt selected**: Apply 5-word minimum requirement
- **If only AniList/MAL**: No minimum word requirement
- **Spoiler flags**: Only applied to Trakt, ignored for others

## Scrobbling States

### Service State Independence
- **Don't reconcile**: Each service maintains its own state
- **Show transparency**: Display what each service will do
- **Start immediately**: Don't wait for state alignment

### Progress Tracking Differences
- **Trakt**: Real-time scrobbling (every few seconds)
- **AniList**: Progress updates at episode completion (80% threshold)
- **MAL**: Progress updates at episode completion

## Authentication & Capabilities

### OAuth Flows
- **Trakt**: Standard OAuth with refresh tokens
- **AniList**: OAuth with long-lived tokens (1 year)
- **MAL**: OAuth with refresh tokens

### API Rate Limits
- **Trakt**: ~1000 requests/hour per user
- **AniList**: ~90 requests/minute
- **MAL**: ~60 requests/minute

## Error Handling Patterns

### Service-Specific Errors
- **Trakt**: HTTP status codes, clear error messages
- **AniList**: GraphQL errors with detailed paths
- **MAL**: REST API with varying error formats

### Rewatch Logic Failures
- **Block scrobbling**: Don't scrobble until issue is resolved
- **Show reason**: Display specific error in ScrobbleNotification
- **Common causes**: Can't determine episode order, API errors, missing data

### Graceful Degradation
- Individual service failures should not affect other services
- Show service-specific error states in UI
- Allow retry per service, not globally

## Future Service Considerations

### New Service Integration
- Define capability matrix (real-time scrobbling, progress tracking, comments, ratings)
- Implement service-specific business rules
- Add to conversion/validation logic
- Update UI to show service differences

### Extensibility Patterns
- Services should be pluggable with minimal UI changes
- Business rules should be encapsulated per service
- UI should adapt to service capabilities automatically

## Implementation Priority

### Rewatch Logic Complexity
- **Implement full rewatch logic from the start** - don't simplify initially
- **Critical for user experience** - prevents double-counting episodes and incorrect progress
- **Service parity** - ensures consistent behavior across AniList/MAL
</file>

<file path="docs/CURRENT_STATE.md">
# TMSync Current Development State

## Architecture Status
- **Multi-service foundation**: ‚úÖ Complete
- **Active services**: Trakt.tv (primary), AniList (secondary)
- **Interface compliance**: Both services implement TrackerService interface
- **Type system**: Service-agnostic types implemented across codebase

## Last Major Work
**Current**: Global service control toggles (Problem 2 üîÑ In Progress)
- ‚úÖ Created service preference storage system with chrome.storage.sync
- ‚úÖ Built useServicePreferences hook for React integration
- ‚úÖ Added ServiceControlPanel component with toggle switches to options page
- ‚úÖ UI working: toggles persist on reload, auth-independent preferences
- üîÑ Next: Wire up background filtering to respect user preferences

**Previous**: Real-time service status indicators system (Problem 1 ‚úÖ Complete)
- ‚úÖ Created ServiceStatusManager for centralized status management
- ‚úÖ Built useServiceStatus hook for React integration
- ‚úÖ Added ServiceStatusIndicator component with visual status badges
- ‚úÖ Integrated status indicators into scrobble notification UI
- ‚úÖ Added authentication change notifications for immediate status updates
- ‚úÖ Implemented honest capability system (services only claim implemented features)
- ‚úÖ AniList now shows truthful status ("Ready", "Not logged in") until features implemented

**Previous**: `60322c5` - Unified service authentication system

## Known Issues
- **Scrobble Race Condition**: Extra start request after stop completion can cause error loops during rapid seeking
  - Impact: Edge case only, normal usage unaffected
  - Files involved: useScrobbling.ts, scrobbleOperationManager.ts (experimental, not committed)
- **AniList Status Message**: May show Trakt's "Added to history" message due to UI state sharing
  - Impact: Minor UX confusion, not affecting functionality
  - Root cause: Service status message sharing between services

## Development Environment
- **Package manager**: pnpm
- **Testing**: `npm run check-all` for full validation
- **Multi-service test**: `npx tsx src/test-services.ts`
- **Services registered**: 2 services (Trakt priority 1, AniList priority 2)

## Ready for Next Work
The codebase is in a clean, stable state ready for Phase 3 UI/UX multi-service integration work. 

**TODO System**: Now uses problem-solving format to encourage creative solutions rather than task execution. See TODO.md for current problems to solve with success criteria and alternative approaches.

## Context Recovery Commands
```bash
git log --oneline -5        # Recent commits
npm run type-check          # Verify TypeScript
npx tsx src/test-services.ts # Test multi-service architecture
```

---
*Auto-updated: 2025-07-05*
</file>

<file path="docs/DESIGN_DECISIONS.md">
# TMSync Design Decisions

This document captures product design decisions made during development to maintain consistency and provide context for future development.

## Product Philosophy

**Iterative Design**: Building product design collaboratively as we develop, making decisions based on user needs and technical feasibility rather than upfront comprehensive planning.

## Problem 2: Service Selection & Control

**Decision Date**: 2025-07-05  
**Context**: Users need control over which tracking services handle their actions (scrobbling, rating, commenting, etc.)

### Selected Approach: Global Service Toggles

**Design Decision**:

- **Location**: Options page settings (not inline controls)
- **Scope**: Global enable/disable per service (not per-action granularity)
- **Default Behavior**: Use all available authenticated services
- **Disabled State**: When user disables all services, treat like unauthenticated state
  - Content script behavior: Only quick links available
  - Options page and popup: Remain fully functional
  - No scrobbling, rating, or commenting functionality

### Alternative Approaches Considered

1. **Per-Action Control**: Choose services per scrobble/rate/comment action
   - *Rejected*: Too complex for initial implementation, can be added later

2. **Inline Controls**: Service selection within content script UI
   - *Rejected*: Would clutter interface, better suited for settings

3. **Per-Media-Type Control**: Different services for movies vs shows
   - *Rejected*: Not a common user need, adds unnecessary complexity

### Technical Implementation Plan

1. **User Preferences Storage**: Extension storage for service enable/disable state
2. **Service Filtering**: Modify existing handlers to filter services based on user preferences
3. **UI Integration**: Add toggle switches to options page authentication section
4. **State Management**: Extend service status system to include user preference state

### Future Enhancements

- Per-action service selection (if user feedback indicates need)
- Per-media-type preferences
- Temporary service overrides for specific actions

---

## Design Decision Template

For future decisions, use this format:

### Problem: [Brief Description]

**Decision Date**: YYYY-MM-DD  
**Context**: [Why this decision was needed]

**Selected Approach**: [What we chose]

**Design Decision**:
- Key aspects of the solution
- User experience considerations
- Technical constraints

**Alternative Approaches Considered**:
1. **Option Name**: Description
   - *Rejected*: Reason

**Implementation Notes**: [Technical details]

**Future Considerations**: [Potential evolution]

---

*Last updated: 2025-07-05*
</file>

<file path="docs/README.md">
# TMSync Documentation

## Project State & Planning

- **[TODO.md](TODO.md)** - Current problems to solve and phase status
- **[CURRENT_STATE.md](CURRENT_STATE.md)** - Architecture status and recent work
- **[DESIGN_DECISIONS.md](DESIGN_DECISIONS.md)** - Product design decisions and rationale

## Architecture & Specifications

- **[Multi-Service Redesign Spec](architecture/MULTI_SERVICE_REDESIGN_SPEC.md)** - Complete redesign specification for per-service architecture
- **[Service Domain Knowledge](architecture/SERVICE_DOMAIN_KNOWLEDGE.md)** - Service-specific business rules and implementation details
- **[Implementation Decisions](architecture/IMPLEMENTATION_DECISIONS.md)** - Edge case handling and detailed implementation decisions

## Development Guidelines

- **[CLAUDE.md](../CLAUDE.md)** - Development commands, patterns, and project architecture
- **[Package.json Scripts](../package.json)** - Available development commands

## Quick Navigation

### For Development Context Recovery
1. Start with [TODO.md](TODO.md) for current phase and problems
2. Check [CURRENT_STATE.md](CURRENT_STATE.md) for recent work
3. Review [CLAUDE.md](../CLAUDE.md) for development patterns

### For Architecture Planning
1. Review [Multi-Service Redesign Spec](architecture/MULTI_SERVICE_REDESIGN_SPEC.md) for future architecture
2. Check [Service Domain Knowledge](architecture/SERVICE_DOMAIN_KNOWLEDGE.md) for implementation details
3. Reference [DESIGN_DECISIONS.md](DESIGN_DECISIONS.md) for product rationale

### For Implementation
1. Follow patterns in [CLAUDE.md](../CLAUDE.md)
2. Use service-specific rules from [Service Domain Knowledge](architecture/SERVICE_DOMAIN_KNOWLEDGE.md)
3. Update [TODO.md](TODO.md) and [CURRENT_STATE.md](CURRENT_STATE.md) as work progresses
</file>

<file path="docs/TODO.md">
# TMSync Development TODO

## Current Phase: Phase 4 - Advanced Features & Edge Cases

### Recently Completed (Phase 3)
- **Problem 1: Users Don't Know Which Services Are Active** ‚úÖ Complete
- **Problem 2: Users Can't Control Which Services Handle Their Actions** ‚úÖ Complete
- **Problem 3: Service Authentication Infrastructure** ‚úÖ Complete

### Phase 4: Advanced Features & Edge Cases

#### Priority 1: Complete AniList Integration ‚úÖ COMPLETED
**Current State**: ‚úÖ Progress tracking implemented, ‚úÖ INTEGRATED into scrobble flow

**‚úÖ Fixed Critical Issue**: AniList progress tracking now fires correctly because:
- Modified `handleScrobbleStop` in `src/background/handlers/handleScrobble.ts` (lines 211-262)
- Added parallel processing of progress tracking services alongside real-time scrobbling services
- At 80% completion: both `stopScrobble` (Trakt) and `addToHistory` (AniList) are called
- Fixed authentication token loading in `addToHistory` and `removeFromHistory` methods
- Services process concurrently with proper error handling and status updates

**Success Criteria**: 
- ‚úÖ AniList supports both anime shows and movies (implemented)
- ‚úÖ Media search and identification works (implemented) 
- ‚úÖ Progress tracking integration into completion threshold flow (COMPLETED)
- üìã Rating system properly translates between Trakt (1-10) and AniList (1-100) scales (deferred)

**Implementation Details**:
- Progress tracking services are filtered by user preferences and authentication status
- Both services run in parallel when 80% threshold is reached
- Comprehensive logging shows service activity for debugging
- Service status manager updates reflect progress tracking operations
- Authentication fixed to properly load tokens from chrome.storage

#### Priority 2: Media Identification & Cross-Service Mapping
**Success Criteria**: Shows can be identified across different services even with naming differences

**Deferred Items** (when needed):
- EpisodeMapper for complex show structures
- MediaIdentifier service for cross-service mapping  
- Confidence scoring for media matching
- Database mapping utilities for episode/season reconciliation

### Completed Phase 3 Problems

#### Problem 1: Users Don't Know Which Services Are Active ‚úÖ COMPLETE
**Success Criteria**: Users can see at a glance which tracking services are enabled and their status (authenticated, syncing, etc.)

**‚úÖ Implemented Solution**:
- Real-time service status indicators integrated into scrobble notification
- Per-service activity states: scrobbling, tracking_progress, idle, error, not logged in
- Immediate status updates when authentication changes (login/logout)
- Honest capability system - services only claim what they actually implement
- Visual indicators with color-coded icons and descriptive text

#### Problem 2: Users Can't Control Which Services Handle Their Actions ‚úÖ COMPLETE
**Success Criteria**: Users can choose which services to scrobble to, rate on, comment to, etc., either globally or per-action

**‚úÖ Implemented Solution**:
- Global service toggle switches in options page 
- Real-time status updates when services are enabled/disabled
- All handlers (scrobble, rate, comment, history) respect user preferences
- Smart state recovery: re-enabled services resume appropriate state during active operations
- Service filtering with both user preference AND authentication status checks
- Default behavior: use all available authenticated services

#### Problem 3: Service Authentication Is Scattered and Confusing
**Success Criteria**: Users have a unified interface to authenticate with and manage multiple tracking services

**Questions to Consider**:
- Should auth be in options page, popup, or both?
- How do we handle different OAuth flows and token lifecycles?
- What happens when a service goes offline or tokens expire?

**Alternative Approaches**:
- Centralized auth hub vs distributed auth buttons
- Proactive re-auth vs on-demand error handling
- Service-specific settings vs unified configuration

#### Problem 4: Error States Provide Poor User Experience üîÑ DEFERRED
**Success Criteria**: When services fail, users understand what happened and how to fix it, without breaking their workflow

**Decision**: Defer until we encounter specific API failures in real usage. Better to solve actual problems than theoretical ones.

**Approach**: Tackle error handling organically when building other features and encountering real failure modes. This will drive better, more targeted solutions.

**Questions to Consider** (when we encounter real errors):
- How granular should error reporting be?
- Should errors be service-specific or aggregated?
- How do we handle partial failures (one service works, another doesn't)?

**Alternative Approaches**:
- Toast notifications vs status indicators vs error pages
- Auto-retry vs manual retry vs graceful degradation
- Technical error details vs user-friendly explanations

**Known Issues**:

- ‚úÖ **AniList Unrate Feature Fixed**: Click-to-unrate now works correctly for both Trakt and AniList
  - Root cause: AniList API expects `score: 0` to remove ratings, not `null` or omitted score
  - Solution: Modified `setAnimeRating` to send `score: 0` when unrating
  - Status: Both Trakt and AniList unrating work perfectly
  - Commit: e2ab516 - fix: resolve AniList unrate functionality by sending score 0

- Scrobble race condition: Extra start request after stop completion can cause loops when errors occur
  - Root cause: Timing between setting historyIdRef and pending video events
  - Impact: Edge case during rapid seeking/testing, not affecting normal usage
  - Solution: Consider debouncing video events or improving state synchronization

### Completed (Phase 2)

- [x] Create TrackerService interface defining common operations
- [x] Implement TraktService with full TrackerService interface compliance
- [x] Implement AniListService with TrackerService interface
- [x] Create ServiceRegistry for managing multiple services
- [x] Add service-agnostic types (ServiceComment, ServiceProgressInfo, etc.)
- [x] Update all handlers and components to use service-agnostic types
- [x] Create service initialization and testing infrastructure

### Future Phases

See CLAUDE.md Development Roadmap for Phase 4 items.

---
*Last updated: 2025-07-05*
*Current commit: 9aaf815 - Complete Phase 3: Multi-service UI/UX integration with service control toggles*
</file>

<file path="src/utils/config.ts">
export const clientId = process.env.TRAKT_CLIENT_ID
    ? process.env.TRAKT_CLIENT_ID
    : '';
export const clientSecret = process.env.TRAKT_CLIENT_SECRET
    ? process.env.TRAKT_CLIENT_SECRET
    : '';

export const traktHeaders = {
    'Content-Type': 'application/json',
    'trakt-api-key': clientId,
    'trakt-api-version': '2'
};
</file>

<file path="webpack/webpack.dev.js">
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
    devtool: 'inline-source-map',
    mode: 'development'
});
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk
</file>

<file path=".nvmrc">
v22.12.0
</file>

<file path=".prettierignore">
# Ignore artifacts:
build
coverage
</file>

<file path=".prettierrc">
{
    "trailingComma": "none",
    "tabWidth": 4,
    "semi": true,
    "singleQuote": true
}
</file>

<file path=".claude/commands/context-recovery.md">
---
description: "Run full context recovery protocol for new sessions"
---

# Context Recovery Protocol

Execute the context recovery protocol from CLAUDE.md:

1. Read TODO.md for current phase and pending tasks
2. Read CURRENT_STATE.md for recent work and architecture status  
3. Read DESIGN_DECISIONS.md for product design rationale
4. Run `git log --oneline -5` to see recent commits
5. Check current git status with `git status`
6. Verify system health with `pnpm type-check`

Then identify current work state and next priorities based on the gathered context.
</file>

<file path=".claude/commands/next-task.md">
---
description: "Identify and start next priority task based on current project state"
---

# Next Task Identification

Analyze current project state and identify next priority task:

1. Review TODO.md for current phase and pending tasks
2. Check git status for uncommitted work
3. Verify system health with `pnpm type-check`
4. Identify highest priority task based on:
   - Phase 4 priorities in TODO.md
   - Known issues that need resolution
   - Architectural improvements needed
5. Create TodoWrite entry for the selected task
6. Begin implementation

Focus on problems that provide the most user value and align with the current development phase.
</file>

<file path=".claude/commands/smart-commit.md">
---
description: "Commit current work with proper message format following CLAUDE.md guidelines"
---

# Smart Commit

Commit current work following CLAUDE.md commit strategy:

1. Run `git status` and `git diff` to understand changes
2. Run `pnpm type-check` to verify code quality
3. Create descriptive commit message focusing on user-facing impact and technical reasoning
4. Use format: `type: description` with proper context
5. Include co-authorship footer as specified in CLAUDE.md
6. Update relevant documentation (TODO.md, CURRENT_STATE.md) if needed

Arguments: `$ARGUMENTS` (optional commit message prefix)
</file>

<file path=".claude/commands/workflow-health.md">
---
description: "Check overall project health and workflow status"
---

# Workflow Health Check

Comprehensive project health check:

1. **Code Quality**:
   - Run `pnpm type-check` for TypeScript errors
   - Run `pnpm lint:check` for linting issues
   - Check for build errors with `pnpm build` (if dependencies are available)

2. **Git Status**:
   - Check for uncommitted changes
   - Verify branch status and recent commits
   - Check for merge conflicts or rebase issues

3. **Documentation Status**:
   - Verify TODO.md is current with recent work
   - Check CURRENT_STATE.md reflects latest architecture
   - Ensure CLAUDE.md guidelines are being followed

4. **Project State**:
   - Review current phase completion
   - Identify any blocking issues
   - Check service integrations and authentication status

Provide summary of any issues that need attention.
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: Test & Quality Checks
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [20.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Enable Corepack
      run: corepack enable

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Type check
      run: pnpm type-check

    - name: Lint
      run: pnpm lint:check

    - name: Format check
      run: pnpm format:check

    - name: Run tests
      run: pnpm test run --coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info
        fail_ci_if_error: false

  build:
    name: Build Extension
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Enable Corepack
      run: corepack enable

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Build extension
      run: pnpm build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: extension-build
        path: dist/
        retention-days: 30
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  release:
    name: Build and Release
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Enable Corepack
      run: corepack enable

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run quality checks
      run: |
        pnpm type-check
        pnpm lint:check
        pnpm format:check
        pnpm test run

    - name: Build extension
      run: pnpm build

    - name: Create extension package
      run: |
        cd dist
        zip -r ../tmsync-extension.zip ./*
        cd ..

    - name: Get version from tag
      id: get_version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.get_version.outputs.VERSION }}
        release_name: TMSync ${{ steps.get_version.outputs.VERSION }}
        body: |
          ## Changes in this Release
          
          - Extension package ready for browser installation
          - All quality checks passed
          
          ## Installation
          
          1. Download `tmsync-extension.zip`
          2. Extract the contents
          3. Load the extension in developer mode in your browser
          
          ## Browser Support
          
          - Chrome/Chromium-based browsers
          - Firefox (with manifest v2 compatibility)
          
        draft: false
        prerelease: false

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./tmsync-extension.zip
        asset_name: tmsync-extension.zip
        asset_content_type: application/zip
</file>

<file path=".github/workflows/security.yml">
name: Security & Dependencies

on:
  schedule:
    # Run weekly on Mondays at 10 AM UTC
    - cron: '0 10 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  security-events: write

jobs:
  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Enable Corepack
      run: corepack enable

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20.x
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Run security audit
      run: pnpm audit --audit-level moderate

    - name: Check for vulnerabilities
      run: |
        if pnpm audit --audit-level high --json > audit-results.json; then
          echo "No high-severity vulnerabilities found"
        else
          echo "High-severity vulnerabilities detected"
          cat audit-results.json
          exit 1
        fi

  dependency-review:
    name: Dependency Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Dependency Review
      uses: actions/dependency-review-action@v4
      with:
        fail-on-severity: moderate
        allow-licenses: MIT, Apache-2.0, BSD-2-Clause, BSD-3-Clause, ISC
</file>

<file path=".husky/pre-commit">
#\!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Run type checking
pnpm type-check

# Run lint-staged for formatting and linting
pnpm exec lint-staged
</file>

<file path="src/background/handlers/handleAuth.ts">
/**
 * Authentication Handler - Background Script
 *
 * Handles OAuth token exchanges that require unrestricted fetch access
 * for AniList and other services that need background script context.
 */

interface AuthTokenExchangeRequest {
    action: 'authTokenExchange';
    service: 'anilist';
    code: string;
    redirectUri: string;
    clientId: string;
    clientSecret?: string;
}

interface AuthTokenExchangeResponse {
    success: boolean;
    accessToken?: string;
    expiresIn?: number;
    error?: string;
}

/**
 * Handle OAuth token exchange for services that require background script context
 */
export async function handleAuthTokenExchange(
    request: AuthTokenExchangeRequest
): Promise<AuthTokenExchangeResponse> {
    try {
        if (request.service === 'anilist') {
            return await handleAniListTokenExchange(request);
        }

        return {
            success: false,
            error: `Unsupported service: ${request.service}`
        };
    } catch (error) {
        console.error('Token exchange error:', error);
        return {
            success: false,
            error:
                error instanceof Error
                    ? error.message
                    : 'Unknown error during token exchange'
        };
    }
}

/**
 * Handle AniList OAuth token exchange
 */
async function handleAniListTokenExchange(
    request: AuthTokenExchangeRequest
): Promise<AuthTokenExchangeResponse> {
    const tokenResponse = await fetch('https://anilist.co/api/v2/oauth/token', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Accept: 'application/json'
        },
        body: JSON.stringify({
            grant_type: 'authorization_code',
            client_id: request.clientId,
            client_secret: request.clientSecret || '', // AniList doesn't require client secret
            redirect_uri: request.redirectUri,
            code: request.code
        })
    });

    if (!tokenResponse.ok) {
        const errorData = await tokenResponse.json().catch(() => ({}));
        throw new Error(
            `Token exchange failed: ${errorData.error_description || tokenResponse.statusText}`
        );
    }

    const tokenData = await tokenResponse.json();

    return {
        success: true,
        accessToken: tokenData.access_token,
        expiresIn: tokenData.expires_in
    };
}
</file>

<file path="src/background/scrobbleOperationManager.ts">
import { MediaInfoResponse, SeasonEpisodeObj } from '../types/media';

/**
 * Manages scrobble operations to prevent conflicts and race conditions
 */
class ScrobbleOperationManager {
    private activeOperations: Map<string, Promise<any>> = new Map();

    /**
     * Generate a unique key for a scrobble operation
     */
    private generateOperationKey(
        operation: 'stop' | 'pause',
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj | null
    ): string {
        const mediaKey =
            mediaInfo.type === 'movie'
                ? `movie-${mediaInfo.movie.ids.trakt}`
                : `show-${mediaInfo.show.ids.trakt}-${episodeInfo?.season || 0}-${episodeInfo?.number || 0}`;

        return `${operation}-${mediaKey}`;
    }

    /**
     * Execute a scrobble operation with deduplication and retry logic
     */
    async executeOperation<T>(
        operation: 'stop' | 'pause',
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        executor: () => Promise<T>
    ): Promise<T> {
        const operationKey = this.generateOperationKey(
            operation,
            mediaInfo,
            episodeInfo
        );

        // If operation is already in progress, return the existing promise
        if (this.activeOperations.has(operationKey)) {
            console.log(
                `‚ö†Ô∏è Deduplicating ${operation} operation for ${operationKey}`
            );
            return this.activeOperations.get(operationKey)!;
        }

        console.log(`üîÑ Starting ${operation} operation for ${operationKey}`);

        // Create and store the operation promise with retry logic
        const operationPromise = this.executeWithRetry(
            executor,
            operation,
            operationKey
        ).finally(() => {
            // Clean up after operation completes
            this.activeOperations.delete(operationKey);
            console.log(
                `‚úÖ Completed ${operation} operation for ${operationKey}`
            );
        });

        this.activeOperations.set(operationKey, operationPromise);

        return operationPromise;
    }

    /**
     * Execute operation with retry logic for rate limits
     */
    private async executeWithRetry<T>(
        executor: () => Promise<T>,
        operation: string,
        operationKey: string,
        attempt: number = 1
    ): Promise<T> {
        try {
            return await executor();
        } catch (error: any) {
            // Retry on rate limit (429) or network errors, up to 3 attempts
            if (
                attempt < 3 &&
                (error?.status === 429 ||
                    error?.message?.includes('429') ||
                    error?.message?.includes('network') ||
                    error?.message?.includes('fetch'))
            ) {
                const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000); // Exponential backoff, max 5s
                console.log(
                    `‚è±Ô∏è Rate limit hit for ${operation} (${operationKey}), retrying in ${delay}ms (attempt ${attempt}/3)`
                );

                await new Promise((resolve) => setTimeout(resolve, delay));
                return this.executeWithRetry(
                    executor,
                    operation,
                    operationKey,
                    attempt + 1
                );
            }

            // Re-throw if not retryable or max attempts reached
            console.error(
                `‚ùå ${operation} operation failed for ${operationKey} after ${attempt} attempts:`,
                error
            );
            throw error;
        }
    }

    /**
     * Check if an operation is currently in progress
     */
    isOperationInProgress(
        operation: 'stop' | 'pause',
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj | null
    ): boolean {
        const operationKey = this.generateOperationKey(
            operation,
            mediaInfo,
            episodeInfo
        );
        return this.activeOperations.has(operationKey);
    }

    /**
     * Clear all active operations (for cleanup)
     */
    clearOperations(): void {
        this.activeOperations.clear();
    }

    /**
     * Get count of active operations (for debugging)
     */
    getActiveOperationCount(): number {
        return this.activeOperations.size;
    }
}

export const scrobbleOperationManager = new ScrobbleOperationManager();
</file>

<file path="src/components/ErrorBoundary.tsx">
import React from 'react';

interface ErrorBoundaryState {
    hasError: boolean;
    error?: Error;
    errorInfo?: React.ErrorInfo;
}

interface ErrorBoundaryProps {
    children: React.ReactNode;
}

export class ErrorBoundary extends React.Component<
    ErrorBoundaryProps,
    ErrorBoundaryState
> {
    constructor(props: ErrorBoundaryProps) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error: Error): ErrorBoundaryState {
        return { hasError: true, error };
    }

    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        console.error('Error boundary caught an error:', error);
        console.error('Error info:', errorInfo);
        this.setState({
            error,
            errorInfo
        });
    }

    render() {
        if (this.state.hasError) {
            return (
                <div className="p-6 max-w-4xl mx-auto mt-10">
                    <div className="bg-red-50 border border-red-200 rounded-lg p-6">
                        <h2 className="text-xl font-bold text-red-800 mb-4">
                            Something went wrong
                        </h2>
                        <div className="text-red-700 space-y-2">
                            <p>
                                <strong>Error:</strong>{' '}
                                {this.state.error?.message}
                            </p>
                            <details className="mt-4">
                                <summary className="cursor-pointer font-semibold">
                                    Technical Details
                                </summary>
                                <pre className="mt-2 p-3 bg-red-100 rounded text-sm overflow-auto">
                                    {this.state.error?.stack}
                                </pre>
                                {this.state.errorInfo && (
                                    <pre className="mt-2 p-3 bg-red-100 rounded text-sm overflow-auto">
                                        {this.state.errorInfo.componentStack}
                                    </pre>
                                )}
                            </details>
                        </div>
                        <button
                            onClick={() => window.location.reload()}
                            className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
                        >
                            Reload Page
                        </button>
                    </div>
                </div>
            );
        }

        return this.props.children;
    }
}
</file>

<file path="src/components/ServiceControlPanel.tsx">
import React from 'react';
import { useMultiServiceAuth } from '../hooks/useMultiServiceAuth';
import { useServicePreferences } from '../hooks/useServicePreferences';
import { ServiceAuthInfo } from '../hooks/useMultiServiceAuth';

/**
 * Service Control Panel for options page
 * Allows users to enable/disable services globally
 */
export const ServiceControlPanel: React.FC = () => {
    const { services, isServicesInitialized } = useMultiServiceAuth();
    const { preferences, isLoading, toggleService, isServiceEnabled } =
        useServicePreferences();

    if (!isServicesInitialized || isLoading) {
        return (
            <div className="bg-(--color-surface-1) rounded-lg shadow-md p-6">
                <h2 className="text-xl font-semibold mb-4 text-(--color-text-primary)">
                    Service Control
                </h2>
                <p className="text-(--color-text-secondary)">
                    Loading service preferences...
                </p>
            </div>
        );
    }

    if (services.length === 0) {
        return (
            <div className="bg-(--color-surface-1) rounded-lg shadow-md p-6">
                <h2 className="text-xl font-semibold mb-4 text-(--color-text-primary)">
                    Service Control
                </h2>
                <p className="text-(--color-text-secondary)">
                    No services available.
                </p>
            </div>
        );
    }

    return (
        <div className="bg-(--color-surface-1) rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold mb-4 text-(--color-text-primary)">
                Service Control
            </h2>
            <p className="text-(--color-text-secondary) mb-4">
                Control which services handle your scrobbling, rating, and
                commenting actions. Disabled services will not be used for any
                tracking activities.
            </p>

            <div className="space-y-3">
                {services.map((service: ServiceAuthInfo) => {
                    const serviceType = service.serviceType;
                    const enabled = isServiceEnabled(serviceType);
                    const capabilities = service.capabilities;

                    // Build capability description
                    const capabilityList = [];
                    if (capabilities.supportsScrobbling)
                        capabilityList.push('Scrobbling');
                    if (capabilities.supportsRatings)
                        capabilityList.push('Ratings');
                    if (capabilities.supportsComments)
                        capabilityList.push('Comments');

                    const capabilityText =
                        capabilityList.length > 0
                            ? capabilityList.join(', ')
                            : 'Basic features';

                    return (
                        <div
                            key={serviceType}
                            className="flex items-center justify-between p-4 bg-(--color-surface-2) rounded-md shadow-sm"
                        >
                            <div className="flex items-center space-x-3">
                                <div className="flex flex-col">
                                    <span className="font-medium text-(--color-text-primary) capitalize">
                                        {serviceType}
                                    </span>
                                    <span className="text-sm text-(--color-text-secondary)">
                                        {capabilityText}
                                    </span>
                                </div>
                            </div>

                            <label className="relative inline-flex items-center cursor-pointer">
                                <input
                                    type="checkbox"
                                    checked={enabled}
                                    onChange={() => toggleService(serviceType)}
                                    className="sr-only"
                                />
                                <div
                                    className={`w-11 h-6 rounded-full transition-colors duration-200 ease-in-out ${
                                        enabled
                                            ? 'bg-(--color-accent-primary)'
                                            : 'bg-(--color-border)'
                                    }`}
                                >
                                    <div
                                        className={`w-5 h-5 bg-white rounded-full shadow transform transition-transform duration-200 ease-in-out ${
                                            enabled
                                                ? 'translate-x-5'
                                                : 'translate-x-0'
                                        } mt-0.5 ml-0.5`}
                                    />
                                </div>
                                <span className="ml-3 text-sm text-(--color-text-primary)">
                                    {enabled ? 'Enabled' : 'Disabled'}
                                </span>
                            </label>
                        </div>
                    );
                })}
            </div>

            <div className="mt-4 p-3 bg-(--color-surface-3) rounded-md">
                <p className="text-xs text-(--color-text-secondary)">
                    <strong>Note:</strong> If you disable all services, TMSync
                    will only provide quick links to tracking sites. Scrobbling,
                    rating, and commenting features will be unavailable.
                </p>
            </div>
        </div>
    );
};
</file>

<file path="src/content-scripts/main/components/LoadingIndicator.tsx">
import React from 'react';

interface LoadingIndicatorProps {
    text?: string;
    size?: 'small' | 'medium' | 'large';
}

export const LoadingIndicator: React.FC<LoadingIndicatorProps> = ({
    text = 'Loading...',
    size = 'medium'
}) => {
    const sizeClasses = {
        small: 'w-4 h-4 border-2',
        medium: 'w-6 h-6 border-4',
        large: 'w-8 h-8 border-4'
    };

    return (
        <div className="fixed bottom-5 left-1/2 -translate-x-1/2 z-[1000000000] flex items-center justify-center space-x-2 bg-(--color-surface-1)/80 backdrop-blur-sm px-4 py-2 rounded-md shadow">
            <div
                className={`animate-spin rounded-full border-t-(--color-accent-primary) border-r-(--color-accent-primary) border-b-(--color-accent-primary)/40 border-l-(--color-accent-primary)/40 ${sizeClasses[size]}`}
                role="status"
            >
                <span className="sr-only">{text}</span>{' '}
            </div>
            {text && (
                <span className="text-sm text-(--color-text-primary)">
                    {text}
                </span>
            )}
        </div>
    );
};
</file>

<file path="src/content-scripts/main/components/RewatchPrompt.tsx">
import React from 'react';

interface RewatchPromptProps {
    onConfirm: () => void;
}

export const RewatchPrompt: React.FC<RewatchPromptProps> = ({ onConfirm }) => {
    return (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-[1000000000] bg-gradient-to-r from-purple-500 to-pink-500 text-white px-4 py-3 rounded-lg shadow-lg flex items-center space-x-3 animate-fade-in-scale">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-6 w-6"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                strokeWidth={2}
            >
                <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m-15.357-2a8.001 8.001 0 0015.357 2M9 21H4.581"
                />
            </svg>
            <span className="text-sm font-medium">
                Track this as a rewatch?
            </span>
            <button
                onClick={onConfirm}
                className="bg-(--color-surface-1) text-(--color-accent-secondary) hover:bg-(--color-surface-2) font-semibold text-xs px-3 py-1 rounded-full shadow transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-purple-600 focus:ring-(--color-surface-1)"
            >
                Confirm Rewatch
            </button>
        </div>
    );
};
</file>

<file path="src/content-scripts/main/components/StartWatchPrompt.tsx">
import React from 'react';

interface StartWatchPromptProps {
    onConfirm: () => void;
}

export const StartWatchPrompt: React.FC<StartWatchPromptProps> = ({
    onConfirm
}) => {
    const mediaText = 'this';

    return (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2 z-[1000000000] bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-4 py-3 rounded-lg shadow-lg flex items-center space-x-3 animate-fade-in-scale">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-6 w-6"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                strokeWidth={2}
            >
                <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                />
                <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                />
            </svg>
            <span className="text-sm font-medium">
                Start tracking {mediaText}?
            </span>
            <button
                onClick={onConfirm}
                className="bg-(--color-surface-1) text-(--color-accent-primary) hover:bg-(--color-surface-2) font-semibold text-xs px-3 py-1 rounded-full shadow transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-blue-600 focus:ring-(--color-surface-1)"
            >
                Confirm
            </button>
        </div>
    );
};
</file>

<file path="src/content-scripts/main/index.tsx">
import '../../styles/index.css';
import React from 'react';
import { createRoot, Root } from 'react-dom/client';
import { ScrobbleManager } from './components/ScrobbleManager';

const isIframe = window.self !== window.top;
let reactRoot: Root | null = null;
let videoMonitorIntervalId: number | null = null;
let iframeVideoEl: HTMLVideoElement | null = null;

const IFRAME_VIDEO_PROGRESS_UPDATE_THROTTLE_MS = 2000;

let timeUpdateProcessingScheduled = false;
let latestVideoState: { currentTime: number; duration: number } | null = null;

function processThrottledIframeTimeUpdate() {
    if (latestVideoState) {
        console.log(
            'TMSync Iframe: Posting throttled TimeUpdate event',
            latestVideoState
        );
        window.top?.postMessage(
            {
                type: 'TMSYNC_IFRAME_TIMEUPDATE',
                ...latestVideoState,
                sourceId: 'tmsync-iframe-player'
            },
            '*'
        );
        latestVideoState = null;
    }
    timeUpdateProcessingScheduled = false;
}

function handleIframePlay(event: Event) {
    const video = event.target as HTMLVideoElement;
    if (!video || isNaN(video.duration) || video.duration === 0) return;
    console.log('TMSync Iframe: Play event', {
        currentTime: video.currentTime,
        duration: video.duration
    });
    window.top?.postMessage(
        {
            type: 'TMSYNC_IFRAME_PLAY',
            currentTime: video.currentTime,
            duration: video.duration,
            sourceId: 'tmsync-iframe-player'
        },
        '*'
    );
}

function handleIframePause(event: Event) {
    const video = event.target as HTMLVideoElement;
    if (!video || isNaN(video.duration) || video.duration === 0) return;
    console.log('TMSync Iframe: Pause event', {
        currentTime: video.currentTime,
        duration: video.duration
    });
    window.top?.postMessage(
        {
            type: 'TMSYNC_IFRAME_PAUSE',
            currentTime: video.currentTime,
            duration: video.duration,
            sourceId: 'tmsync-iframe-player'
        },
        '*'
    );
}

function handleIframeEnded(event: Event) {
    const video = event.target as HTMLVideoElement;
    if (!video || isNaN(video.duration) || video.duration === 0) return;
    console.log('TMSync Iframe: Ended event', {
        currentTime: video.currentTime,
        duration: video.duration
    });
    window.top?.postMessage(
        {
            type: 'TMSYNC_IFRAME_ENDED',
            currentTime: video.duration,
            duration: video.duration,
            sourceId: 'tmsync-iframe-player'
        },
        '*'
    );
}

function handleIframeTimeUpdate(event: Event) {
    const video = event.target as HTMLVideoElement;
    // The `video.paused` check is removed here. The event itself implies progress.
    if (!video || isNaN(video.duration) || video.duration === 0) {
        return;
    }

    latestVideoState = {
        currentTime: video.currentTime,
        duration: video.duration
    };

    if (!timeUpdateProcessingScheduled) {
        timeUpdateProcessingScheduled = true;
        setTimeout(
            processThrottledIframeTimeUpdate,
            IFRAME_VIDEO_PROGRESS_UPDATE_THROTTLE_MS
        );
    }
}

function attachIframeVideoListeners(videoElement: HTMLVideoElement) {
    iframeVideoEl = videoElement;
    console.log(
        'TMSync Iframe: Attaching listeners to video element:',
        videoElement
    );
    videoElement.addEventListener('play', handleIframePlay);
    videoElement.addEventListener('pause', handleIframePause);
    videoElement.addEventListener('ended', handleIframeEnded);
    videoElement.addEventListener('timeupdate', handleIframeTimeUpdate);

    if (
        !videoElement.paused &&
        videoElement.duration > 0 &&
        videoElement.currentTime > 0
    ) {
        console.log(
            'TMSync Iframe: Video already playing, sending initial play event.'
        );

        window.top?.postMessage(
            {
                type: 'TMSYNC_IFRAME_PLAY',
                currentTime: videoElement.currentTime,
                duration: videoElement.duration,
                sourceId: 'tmsync-iframe-player'
            },
            '*'
        );
    }
}

function detachIframeVideoListeners() {
    if (iframeVideoEl) {
        console.log('TMSync Iframe: Detaching listeners from video element.');
        iframeVideoEl.removeEventListener('play', handleIframePlay);
        iframeVideoEl.removeEventListener('pause', handleIframePause);
        iframeVideoEl.removeEventListener('ended', handleIframeEnded);
        iframeVideoEl.removeEventListener('timeupdate', handleIframeTimeUpdate);
        iframeVideoEl = null;
    }
}

function startIframeVideoMonitoring() {
    const videoElement = document.querySelector('video');
    if (videoElement) {
        attachIframeVideoListeners(videoElement);
    } else {
        let attempts = 0;
        const findVideoInterval = setInterval(() => {
            attempts++;
            const vEl = document.querySelector('video');
            if (vEl) {
                clearInterval(findVideoInterval);
                attachIframeVideoListeners(vEl);
            } else if (attempts > 20) {
                clearInterval(findVideoInterval);
                console.warn(
                    'TMSync Iframe: Video element not found after multiple attempts.'
                );
            }
        }, 500);
    }

    window.addEventListener('beforeunload', () => {
        console.log('TMSync Iframe: beforeunload, detaching listeners.');
        detachIframeVideoListeners();
    });
}

function injectReactApp(): void {
    let container = document.getElementById('tmsync-container');
    let shadowRootElement: ShadowRoot | null = null;

    if (!container) {
        container = document.createElement('div');
        container.id = 'tmsync-container';

        shadowRootElement = container.attachShadow({ mode: 'open' });

        const reactAppContainer = document.createElement('div');
        reactAppContainer.id = 'tmsync-react-app-root';

        shadowRootElement.appendChild(reactAppContainer);

        window.addEventListener(
            'keydown',
            (event) => {
                if (event.composedPath().includes(container!)) {
                    event.stopImmediatePropagation();
                }
            },
            { capture: true }
        );

        const tailwindCssUrl = chrome.runtime.getURL('css/styles.css');
        fetch(tailwindCssUrl)
            .then((response) => response.text())
            .then((cssText) => {
                if (shadowRootElement) {
                    const styleEl = document.createElement('style');
                    styleEl.textContent = cssText;
                    shadowRootElement.appendChild(styleEl);
                }
            })
            .catch((err) =>
                console.error('Failed to load styles into shadow DOM', err)
            );

        document.body.appendChild(container);
    } else {
        shadowRootElement = container.shadowRoot;
    }

    const reactAppRootElement = shadowRootElement?.getElementById(
        'tmsync-react-app-root'
    );

    if (reactAppRootElement) {
        if (!reactRoot) {
            reactRoot = createRoot(reactAppRootElement);
        }
        reactRoot.render(<ScrobbleManager />);
    } else {
        console.error('TMSync: React root within shadow DOM not found!');
    }
}

async function initialize() {
    if (isIframe) {
        console.log(
            'TMSync: Running in iframe context. Initializing video event posting.'
        );

        if (videoMonitorIntervalId) {
            clearInterval(videoMonitorIntervalId);
            videoMonitorIntervalId = null;
        }
        startIframeVideoMonitoring();
    } else {
        console.log(
            'TMSync: Running in main frame context. Injecting React app.'
        );
        injectReactApp();
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initialize);
} else {
    initialize();
}
</file>

<file path="src/hooks/useQuickLinkPreferences.ts">
import { useState, useEffect, useMemo } from 'react';
import { siteConfigs } from '../utils/siteConfigs';

export interface SiteQuickLinkPreference {
    enabled: boolean;
    order: number;
}
export interface UserQuickLinkPrefs {
    [siteKey: string]: SiteQuickLinkPreference;
}

const availableSitesForQuickLinks = Object.entries(siteConfigs)
    .filter(([, config]) => !!config.generateWatchLink)
    .map(([key, config]) => ({
        key: key,
        name: config.name,
        logo: chrome.runtime.getURL(`images/logos/${key.toLowerCase()}.png`)
    }));

export function useQuickLinkPreferences(isLoggedIn: boolean) {
    const [prefs, setPrefs] = useState<UserQuickLinkPrefs>({});
    const [isLoading, setIsLoading] = useState(true);
    const [searchTerm, setSearchTerm] = useState('');

    useEffect(() => {
        if (!isLoggedIn) {
            setPrefs({});
            setIsLoading(false);
            return;
        }

        const loadPreferences = async () => {
            setIsLoading(true);
            const data = await chrome.storage.sync.get([
                'quickLinkPreferences'
            ]);
            const loadedPrefs = (data.quickLinkPreferences ||
                {}) as UserQuickLinkPrefs;
            let maxOrder = -1;

            Object.values(loadedPrefs).forEach((p) => {
                if (p && typeof p.order === 'number' && p.order > maxOrder) {
                    maxOrder = p.order;
                }
            });

            const initialPrefs: UserQuickLinkPrefs = {};
            availableSitesForQuickLinks.forEach((site, index) => {
                initialPrefs[site.key] = loadedPrefs[site.key] || {
                    enabled: true,
                    order: maxOrder + 1 + index
                };
            });
            setPrefs(initialPrefs);
            setIsLoading(false);
        };

        loadPreferences();
    }, [isLoggedIn]);

    const updatePreferences = (newPrefs: UserQuickLinkPrefs) => {
        setPrefs(newPrefs);
        chrome.storage.sync.set({ quickLinkPreferences: newPrefs });
    };

    const toggleSite = (siteKey: string) => {
        const newPrefs = {
            ...prefs,
            [siteKey]: {
                ...prefs[siteKey],
                enabled: !prefs[siteKey]?.enabled
            }
        };
        updatePreferences(newPrefs);
    };

    const moveSite = (siteKey: string, direction: 'up' | 'down') => {
        const orderedSites = availableSitesForQuickLinks
            .map((s) => ({ ...s, ...prefs[s.key] }))
            .sort((a, b) => a.order - b.order);

        const currentIndex = orderedSites.findIndex((s) => s.key === siteKey);
        if (currentIndex === -1) return;

        let newIndex = currentIndex;
        if (direction === 'up' && currentIndex > 0) newIndex = currentIndex - 1;
        if (direction === 'down' && currentIndex < orderedSites.length - 1)
            newIndex = currentIndex + 1;

        if (newIndex !== currentIndex) {
            const [movedSite] = orderedSites.splice(currentIndex, 1);
            orderedSites.splice(newIndex, 0, movedSite);

            const newPrefs: UserQuickLinkPrefs = {};
            orderedSites.forEach((site, index) => {
                newPrefs[site.key] = {
                    ...(prefs[site.key] || { enabled: true }),
                    order: index
                };
            });
            updatePreferences(newPrefs);
        }
    };

    const filteredSites = useMemo(() => {
        return availableSitesForQuickLinks
            .filter((site) =>
                site.name.toLowerCase().includes(searchTerm.toLowerCase())
            )
            .sort(
                (a, b) =>
                    (prefs[a.key]?.order ?? 999) - (prefs[b.key]?.order ?? 999)
            );
    }, [searchTerm, prefs]);

    return {
        prefs,
        isLoading,
        searchTerm,
        setSearchTerm,
        filteredSites,
        toggleSite,
        moveSite
    };
}
</file>

<file path="src/hooks/useServicePreferences.ts">
import { useState, useEffect, useCallback } from 'react';
import { ServiceType } from '../types/serviceTypes';
import {
    getServicePreferences,
    setServiceEnabled,
    isServiceEnabled,
    ServicePreferences
} from '../utils/servicePreferences';

interface UseServicePreferencesReturn {
    preferences: ServicePreferences;
    isLoading: boolean;
    toggleService: (serviceType: ServiceType) => Promise<void>;
    isServiceEnabled: (serviceType: ServiceType) => boolean;
    refreshPreferences: () => Promise<void>;
}

/**
 * Hook for managing user service preferences
 */
export function useServicePreferences(): UseServicePreferencesReturn {
    const [preferences, setPreferences] = useState<ServicePreferences>({});
    const [isLoading, setIsLoading] = useState(true);

    const refreshPreferences = useCallback(async () => {
        setIsLoading(true);
        try {
            const prefs = await getServicePreferences();
            setPreferences(prefs);
        } catch (error) {
            console.error('Failed to load service preferences:', error);
        } finally {
            setIsLoading(false);
        }
    }, []);

    const toggleService = useCallback(
        async (serviceType: ServiceType) => {
            const currentlyEnabled = preferences[serviceType] !== false;
            const newEnabled = !currentlyEnabled;

            try {
                await setServiceEnabled(serviceType, newEnabled);
                await refreshPreferences(); // Refresh to get updated state
            } catch (error) {
                console.error(
                    `Failed to toggle service ${serviceType}:`,
                    error
                );
            }
        },
        [preferences, refreshPreferences]
    );

    const checkIsServiceEnabled = useCallback(
        (serviceType: ServiceType): boolean => {
            return preferences[serviceType] !== false; // Default to enabled
        },
        [preferences]
    );

    useEffect(() => {
        refreshPreferences();
    }, [refreshPreferences]);

    return {
        preferences,
        isLoading,
        toggleService,
        isServiceEnabled: checkIsServiceEnabled,
        refreshPreferences
    };
}
</file>

<file path="src/hooks/useServiceStatus.ts">
/**
 * Hook for managing real-time service status in content scripts
 */

import { useState, useEffect, useCallback } from 'react';
import {
    ServiceStatus,
    ServiceStatusUpdateEvent
} from '../types/serviceStatus';
import { ServiceType } from '../types/serviceTypes';

interface UseServiceStatusReturn {
    serviceStatuses: ServiceStatus[];
    isLoading: boolean;
    getServiceStatus: (serviceType: ServiceType) => ServiceStatus | undefined;
    refreshStatuses: () => Promise<void>;
}

/**
 * Hook for real-time service status updates in content scripts
 */
export function useServiceStatus(): UseServiceStatusReturn {
    const [serviceStatuses, setServiceStatuses] = useState<ServiceStatus[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    // Register for status updates
    useEffect(() => {
        let isRegistered = false;

        const registerListener = async () => {
            try {
                // Register for status updates (background script will determine tab ID from sender)
                await chrome.runtime.sendMessage({
                    action: 'registerStatusListener',
                    params: {}
                });

                // Get initial status
                const initialStatuses = await chrome.runtime.sendMessage({
                    action: 'getServiceStatuses',
                    params: {}
                });

                if (initialStatuses.success) {
                    setServiceStatuses(initialStatuses.data || []);
                }

                isRegistered = true;
                setIsLoading(false);
            } catch (error) {
                console.error(
                    'Failed to register service status listener:',
                    error
                );
                setIsLoading(false);
            }
        };

        registerListener();

        // Listen for status updates
        const handleMessage = (message: ServiceStatusUpdateEvent) => {
            if (message.action === 'serviceStatusUpdate') {
                setServiceStatuses(message.data.services);
            }
        };

        chrome.runtime.onMessage.addListener(handleMessage);

        return () => {
            chrome.runtime.onMessage.removeListener(handleMessage);

            // Unregister listener
            if (isRegistered) {
                chrome.runtime
                    .sendMessage({
                        action: 'unregisterStatusListener',
                        params: {}
                    })
                    .catch(() => {
                        // Ignore errors during cleanup
                    });
            }
        };
    }, []);

    // Get status for specific service
    const getServiceStatus = useCallback(
        (serviceType: ServiceType): ServiceStatus | undefined => {
            return serviceStatuses.find(
                (status) => status.serviceType === serviceType
            );
        },
        [serviceStatuses]
    );

    // Refresh all service statuses
    const refreshStatuses = useCallback(async (): Promise<void> => {
        try {
            const response = await chrome.runtime.sendMessage({
                action: 'getServiceStatuses',
                params: {}
            });

            if (response.success) {
                setServiceStatuses(response.data || []);
            }
        } catch (error) {
            console.error('Failed to refresh service statuses:', error);
        }
    }, []);

    return {
        serviceStatuses,
        isLoading,
        getServiceStatus,
        refreshStatuses
    };
}
</file>

<file path="src/options/minimal-test.tsx">
import React, { useEffect } from 'react';
import { createRoot } from 'react-dom/client';
import '../styles/index.css';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { initializeServices } from '../services';
import { useMultiServiceAuth } from '../hooks/useMultiServiceAuth';

const MinimalOptions: React.FC = () => {
    useEffect(() => {
        try {
            console.log('Initializing services in minimal test...');
            initializeServices();
            console.log('Services initialized successfully in minimal test');
        } catch (error) {
            console.error(
                'Error initializing services in minimal test:',
                error
            );
        }
    }, []);

    const multiServiceAuth = useMultiServiceAuth();
    console.log('Multi-service auth state:', multiServiceAuth);

    return (
        <div className="p-6 max-w-4xl mx-auto mt-10">
            <h1 className="text-2xl font-bold mb-4">
                TMSync Options (Minimal Test)
            </h1>
            <div className="bg-gray-100 p-4 rounded">
                <h2>
                    Services Initialized:{' '}
                    {multiServiceAuth.isServicesInitialized ? 'Yes' : 'No'}
                </h2>
                <h2>Service Count: {multiServiceAuth.services?.length || 0}</h2>
                <h2>
                    Authenticated:{' '}
                    {multiServiceAuth.authenticatedServices?.length || 0}
                </h2>

                {!multiServiceAuth.isServicesInitialized && (
                    <div className="mt-2 p-2 bg-yellow-100 border border-yellow-300 rounded">
                        <p className="text-yellow-800">
                            Waiting for services to initialize...
                        </p>
                    </div>
                )}

                <pre className="mt-2 text-sm">
                    {JSON.stringify(multiServiceAuth, null, 2)}
                </pre>
            </div>
        </div>
    );
};

const container = document.getElementById('root');
if (container) {
    const root = createRoot(container);
    root.render(
        <ErrorBoundary>
            <MinimalOptions />
        </ErrorBoundary>
    );
} else {
    console.error("Target container 'root' not found for Options page.");
}
</file>

<file path="src/popup/index.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { createRoot } from 'react-dom/client';
import '../styles/index.css';

const Popup: React.FC = () => {
    const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);
    const [username, setUsername] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(true);

    const checkStatus = useCallback(async () => {
        try {
            const data = await chrome.storage.local.get([
                'traktAccessToken',
                'traktTokenExpiresAt',
                'traktUsername'
            ]);
            const token = data.traktAccessToken;
            const expires = data.traktTokenExpiresAt || 0;
            const name = data.traktUsername;

            if (token && Date.now() < expires && name) {
                setIsLoggedIn(true);
                setUsername(name);
            } else {
                setIsLoggedIn(false);
                setUsername(null);
            }
        } catch (err) {
            console.error('Error checking status in popup:', err);
            setIsLoggedIn(false);
            setUsername(null);
        } finally {
            setIsLoading(false);
        }
    }, []);

    useEffect(() => {
        checkStatus();

        const handleStorageChange = (
            changes: { [key: string]: chrome.storage.StorageChange },
            areaName: string
        ) => {
            if (
                areaName === 'local' &&
                (changes.traktAccessToken ||
                    changes.traktTokenExpiresAt ||
                    changes.traktUsername)
            ) {
                console.log('Detected storage change, re-checking status...');
                checkStatus();
            }
        };

        chrome.storage.onChanged.addListener(handleStorageChange);

        return () => {
            chrome.storage.onChanged.removeListener(handleStorageChange);
        };
    }, [checkStatus]);

    const openOptionsPage = () => {
        chrome.runtime.openOptionsPage();
    };

    return (
        <div className="p-4 bg-(--color-background) shadow min-w-[280px] text-sm text-(--color-text-primary)">
            <h1 className="text-lg font-semibold text-center mb-3 text-(--color-text-primary)">
                TMSync
            </h1>

            {isLoading ? (
                <div className="flex justify-center items-center h-10">
                    <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-(--color-text-secondary)"></div>
                </div>
            ) : isLoggedIn && username ? (
                <div className="text-center space-y-2">
                    <p className="text-(--color-success-text)">
                        Logged in as:{' '}
                        <strong className="font-medium">{username}</strong>
                    </p>
                </div>
            ) : (
                <p className="text-center text-(--color-danger-text)">
                    Not logged in.
                </p>
            )}

            <button
                onClick={openOptionsPage}
                className="mt-4 w-full bg-(--color-surface-2) hover:bg-(--color-surface-3) text-(--color-text-primary) font-semibold py-2 px-4 rounded text-xs focus:outline-none focus:shadow-outline transition duration-150 ease-in-out"
            >
                {isLoggedIn ? 'Open Settings' : 'Login / Open Settings'}
            </button>
        </div>
    );
};

const container = document.getElementById('root');
if (container) {
    const root = createRoot(container);
    root.render(<Popup />);
} else {
    console.error("Target container 'root' not found for Popup.");
}
</file>

<file path="src/test/mocks/chrome.ts">
import { vi } from 'vitest';

// Mock Chrome Extension APIs
export const chromeMock = {
    runtime: {
        onMessage: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        },
        sendMessage: vi.fn().mockImplementation((message, callback) => {
            // Default mock response
            const response = { success: true, data: {} };
            if (callback) callback(response);
            return Promise.resolve(response);
        }),
        getURL: vi
            .fn()
            .mockImplementation((path) => `chrome-extension://test/${path}`),
        id: 'test-extension-id',
        lastError: null
    },
    tabs: {
        onRemoved: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        },
        onUpdated: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        },
        query: vi.fn().mockResolvedValue([
            {
                id: 1,
                url: 'https://example.com',
                title: 'Test Page',
                active: true
            }
        ]),
        create: vi.fn().mockResolvedValue({
            id: 2,
            url: 'https://example.com',
            title: 'New Tab'
        }),
        remove: vi.fn().mockResolvedValue(undefined)
    },
    storage: {
        local: {
            get: vi.fn().mockImplementation((keys) => {
                const result = Array.isArray(keys)
                    ? keys.reduce((acc, key) => ({ ...acc, [key]: null }), {})
                    : typeof keys === 'string'
                      ? { [keys]: null }
                      : {};
                return Promise.resolve(result);
            }),
            set: vi.fn().mockResolvedValue(undefined),
            remove: vi.fn().mockResolvedValue(undefined),
            clear: vi.fn().mockResolvedValue(undefined)
        },
        sync: {
            get: vi.fn().mockImplementation((keys) => {
                const result = Array.isArray(keys)
                    ? keys.reduce((acc, key) => ({ ...acc, [key]: null }), {})
                    : typeof keys === 'string'
                      ? { [keys]: null }
                      : {};
                return Promise.resolve(result);
            }),
            set: vi.fn().mockResolvedValue(undefined),
            remove: vi.fn().mockResolvedValue(undefined),
            clear: vi.fn().mockResolvedValue(undefined)
        }
    },
    action: {
        onClicked: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        },
        setBadgeText: vi.fn(),
        setBadgeBackgroundColor: vi.fn(),
        setIcon: vi.fn(),
        setTitle: vi.fn()
    },
    alarms: {
        create: vi.fn(),
        clear: vi.fn(),
        clearAll: vi.fn(),
        get: vi.fn(),
        getAll: vi.fn(),
        onAlarm: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        }
    },
    permissions: {
        request: vi.fn().mockResolvedValue(true),
        remove: vi.fn().mockResolvedValue(true),
        contains: vi.fn().mockResolvedValue(true)
    },
    webNavigation: {
        onCompleted: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        },
        onHistoryStateUpdated: {
            addListener: vi.fn(),
            removeListener: vi.fn()
        }
    },
    scripting: {
        executeScript: vi.fn().mockResolvedValue([{ result: {} }]),
        insertCSS: vi.fn().mockResolvedValue(undefined),
        removeCSS: vi.fn().mockResolvedValue(undefined)
    }
};

// Helper function to create mock message sender
export const createMockSender = (
    tabId: number = 1,
    url: string = 'https://example.com'
) => ({
    tab: {
        id: tabId,
        url,
        title: 'Test Page',
        active: true
    },
    frameId: 0,
    id: 'test-extension-id',
    url: 'chrome-extension://test/background.html'
});

// Helper function to mock sendMessage responses
export const mockSendMessageResponse = (action: string, response: any) => {
    chromeMock.runtime.sendMessage.mockImplementation((message, callback) => {
        if (message.action === action) {
            if (callback) callback(response);
            return Promise.resolve(response);
        }
        // Default response for other actions
        const defaultResponse = { success: true, data: {} };
        if (callback) callback(defaultResponse);
        return Promise.resolve(defaultResponse);
    });
};

// Helper function to simulate tab events
export const simulateTabEvent = (
    event: 'removed' | 'updated',
    tabId: number,
    changeInfo?: any
) => {
    const listeners =
        event === 'removed'
            ? chromeMock.tabs.onRemoved.addListener.mock.calls.flat()
            : chromeMock.tabs.onUpdated.addListener.mock.calls.flat();

    listeners.forEach((listener) => {
        if (typeof listener === 'function') {
            if (event === 'removed') {
                listener(tabId);
            } else {
                listener(tabId, changeInfo || {}, {
                    id: tabId,
                    url: 'https://example.com'
                });
            }
        }
    });
};
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom';
import { vi, beforeEach } from 'vitest';
import { chromeMock } from './mocks/chrome';

// Mock Chrome Extension APIs
Object.defineProperty(global, 'chrome', {
    value: chromeMock,
    writable: true
});

// Mock window.location
Object.defineProperty(window, 'location', {
    value: {
        href: 'https://example.com',
        pathname: '/test',
        search: '',
        hash: ''
    },
    writable: true
});

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
    disconnect: vi.fn(),
    observe: vi.fn(),
    unobserve: vi.fn()
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
    disconnect: vi.fn(),
    observe: vi.fn(),
    unobserve: vi.fn()
}));

// Mock requestAnimationFrame
global.requestAnimationFrame = vi.fn(
    (cb) => setTimeout(cb, 0) as unknown as number
);
global.cancelAnimationFrame = vi.fn((id) => clearTimeout(id));

// Mock fetch
global.fetch = vi.fn();

// Clear all mocks before each test
beforeEach(() => {
    vi.clearAllMocks();
});
</file>

<file path="src/test/utils.tsx">
import React from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { vi } from 'vitest';
import { chromeMock } from './mocks/chrome';

// Custom render function that includes providers
const customRender = (ui: React.ReactElement, options?: RenderOptions) => {
    return render(ui, {
        ...options
    });
};

// Mock site configuration factory
export const createMockSiteConfig = (overrides: any = {}) => ({
    name: 'Test Site',
    selectorType: 'css' as const,
    usesTmdbId: false,
    urlPatterns: {
        movie: /\/movie\/\d+/,
        show: /\/show\/\d+/
    },
    selectors: {
        movie: { title: '.movie-title', year: '.movie-year' },
        show: { title: '.show-title', year: '.show-year' }
    },
    isWatchPage: vi.fn().mockReturnValue(true),
    getMediaType: vi.fn().mockReturnValue('movie'),
    getTitle: vi.fn().mockResolvedValue('Test Movie'),
    getYear: vi.fn().mockResolvedValue('2023'),
    getTmdbId: vi.fn().mockReturnValue(null),
    getSeasonEpisodeObj: vi.fn().mockReturnValue(null),
    ...overrides
});

// Mock media info factory
export const createMockMediaInfo = (type: 'movie' | 'show' = 'movie') => {
    if (type === 'movie') {
        return {
            type: 'movie' as const,
            score: 85,
            movie: {
                title: 'Test Movie',
                year: 2023,
                ids: {
                    trakt: 123,
                    slug: 'test-movie',
                    imdb: 'tt1234567',
                    tmdb: 456
                }
            }
        };
    } else {
        return {
            type: 'show' as const,
            score: 90,
            show: {
                title: 'Test Show',
                year: 2023,
                ids: {
                    trakt: 789,
                    slug: 'test-show',
                    tvdb: 111,
                    imdb: 'tt7890123',
                    tmdb: 12
                }
            }
        };
    }
};

// Mock episode info factory
export const createMockEpisodeInfo = (
    season: number = 1,
    episode: number = 1
) => ({
    season,
    number: episode,
    title: `Episode ${episode}`,
    ids: {
        trakt: 999,
        imdb: 'tt9999999',
        tmdb: 888
    }
});

// Mock ratings factory
export const createMockRatings = () => ({
    show: {
        userRating: 8,
        ratedAt: '2023-01-01T00:00:00Z'
    },
    episode: {
        userRating: 7,
        ratedAt: '2023-01-01T00:00:00Z'
    }
});

// Mock Trakt comments factory
export const createMockComments = (count: number = 2) => {
    return Array.from({ length: count }, (_, i) => ({
        id: i + 1,
        comment: `Test comment ${i + 1}`,
        spoiler: false,
        review: false,
        parent_id: 0,
        created_at: '2023-01-01T00:00:00Z',
        updated_at: '2023-01-01T00:00:00Z',
        replies: 0,
        likes: 0,
        user_stats: {
            rating: 8,
            plays: 1,
            watched: true
        },
        user: {
            username: 'testuser',
            private: false,
            name: 'Test User',
            vip: false,
            vip_ep: false,
            ids: {
                slug: 'testuser'
            }
        }
    }));
};

// Helper to wait for async operations
export const waitForAsync = () =>
    new Promise((resolve) => setTimeout(resolve, 0));

// Helper to create mock video element
export const createMockVideoElement = (overrides: any = {}) => {
    const mockVideo = {
        currentTime: 0,
        duration: 100,
        paused: true,
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        play: vi.fn(),
        pause: vi.fn(),
        ...overrides
    };

    // Mock querySelector to return our mock video
    const originalQuerySelector = document.querySelector;
    document.querySelector = vi.fn().mockImplementation((selector) => {
        if (selector === 'video') {
            return mockVideo;
        }
        return originalQuerySelector.call(document, selector);
    });

    return mockVideo;
};

// Helper to simulate media lifecycle states
export const simulateMediaLifecycleState = (state: string, data?: any) => {
    const mockResponse = {
        success: true,
        data: {
            mediaInfo: createMockMediaInfo(),
            confidence: 'high',
            originalQuery: {
                type: 'movie',
                query: 'Test Movie',
                years: '2023'
            },
            watchStatus: { isInHistory: false },
            ratingInfo: null,
            progressInfo: null,
            ...data
        }
    };

    chromeMock.runtime.sendMessage.mockResolvedValue(mockResponse);
    return mockResponse;
};

export * from '@testing-library/react';
export { customRender as render };
</file>

<file path="src/types/media.ts">
// Defines the core media-related types used throughout the application.

export interface MovieMediaInfo {
    type: 'movie';
    score: number;
    movie: {
        title: string;
        year: number;
        ids: {
            trakt: number;
            slug: string;
            imdb: string;
            tmdb: number;
        };
    };
}

export interface ShowMediaInfo {
    type: 'show';
    score: number;
    show: {
        title: string;
        year: number;
        ids: {
            trakt: number;
            slug: string;
            tvdb: number;
            imdb: string;
            tmdb: number;
        };
    };
}

export type MediaInfoResponse = MovieMediaInfo | ShowMediaInfo;

export type ScoredMediaInfo = MediaInfoResponse & {
    confidenceScore: number;
};

export interface IndividualRating {
    userRating: number | null;
    ratedAt?: string;
}

export interface MediaRatings {
    show?: IndividualRating;
    season?: IndividualRating;
    episode?: IndividualRating;
}

export interface SeasonEpisodeObj {
    season: number;
    number: number;
}

export type CommentableType = 'movie' | 'show' | 'season' | 'episode';
</file>

<file path="src/types/trakt.ts">
// Contains types that directly map to Trakt API request/response bodies.

export interface TraktShowWatchedProgress {
    aired: number;
    completed: number;
    last_watched_at: string;
    reset_at: string | null;
    seasons: TraktSeason[];
    hidden_seasons: TraktHiddenSeason[];
    next_episode: TraktEpisodeInfo | null;
    last_episode: TraktEpisodeInfo | null;
}

export interface TraktSeason {
    number: number;
    title: string;
    aired: number;
    completed: number;
    episodes: TraktEpisode[];
}

export interface TraktEpisode {
    number: number;
    completed: boolean;
    last_watched_at: string | null;
}

export interface TraktHiddenSeason {
    number: number;
    ids: TraktIds;
}

export interface TraktEpisodeInfo {
    season: number;
    number: number;
    title: string;
    ids: TraktEpisodeIds;
}

export interface TraktIds {
    trakt: number;
    tvdb: number;
    tmdb: number;
}

export interface TraktEpisodeIds {
    trakt: number;
    tvdb: number;
    imdb: string | null;
    tmdb: number | null;
}

export interface ScrobbleBody {
    movie?: any;
    show?: any;
    episode?: any;
    progress: number;
}

export interface HistoryBody {
    movies?: any[];
    shows?: any[];
    seasons?: any[];
    episodes?: any[];
}

export interface TraktRating {
    rated_at: string;
    rating: number;
    type: 'movie' | 'show' | 'season' | 'episode';
}

export interface TraktComment {
    id: number;
    parent_id: number;
    created_at: string;
    updated_at: string;
    comment: string;
    spoiler: boolean;
    review: boolean;
    replies: number;
    likes: number;
    user_stats: {
        rating: number | null;
        play_count: number;
        completed_count: number;
    };
    user: {
        username: string;
        private: boolean;
        name: string;
        vip: boolean;
        vip_ep: boolean;
        ids: { slug: string };
    };
}
</file>

<file path="src/utils/__tests__/typeGuards.test.ts">
import { describe, it, expect } from 'vitest';
import { isMovieMediaInfo, isShowMediaInfo } from '../typeGuards';
import { createMockMediaInfo } from '../../test/utils';

describe('typeGuards', () => {
    describe('isMovieMediaInfo', () => {
        it('should return true for movie media info', () => {
            const movieInfo = createMockMediaInfo('movie');
            expect(isMovieMediaInfo(movieInfo)).toBe(true);
        });

        it('should return false for show media info', () => {
            const showInfo = createMockMediaInfo('show');
            expect(isMovieMediaInfo(showInfo)).toBe(false);
        });

        it('should return false for null', () => {
            expect(isMovieMediaInfo(null)).toBe(false);
        });

        it('should return false for undefined', () => {
            expect(isMovieMediaInfo(undefined)).toBe(false);
        });
    });

    describe('isShowMediaInfo', () => {
        it('should return true for show media info', () => {
            const showInfo = createMockMediaInfo('show');
            expect(isShowMediaInfo(showInfo)).toBe(true);
        });

        it('should return false for movie media info', () => {
            const movieInfo = createMockMediaInfo('movie');
            expect(isShowMediaInfo(movieInfo)).toBe(false);
        });

        it('should return false for null', () => {
            expect(isShowMediaInfo(null)).toBe(false);
        });

        it('should return false for undefined', () => {
            expect(isShowMediaInfo(undefined)).toBe(false);
        });
    });
});
</file>

<file path="src/utils/highlighting.ts">
import {
    EpisodeListContextConfig,
    SiteConfigBase
} from './siteConfigs/baseConfig';

export type HighlightType =
    | 'first_watch_last'
    | 'rewatch_last'
    | 'watched_history';
interface HighlightInfo {
    season: number;
    episode: number;
    type: HighlightType;
}

const observers = new Map<string, MutationObserver>();
const HIGHLIGHT_STYLE_ATTRIBUTE = 'data-tmsync-highlight-style';

const highlightStyles: Record<HighlightType, Partial<CSSStyleDeclaration>> = {
    first_watch_last: {
        border: '2px solid #3b82f6',

        boxShadow: '0 0 8px rgba(59, 130, 246, 0.5)'
    },
    rewatch_last: {
        border: '2px solid #ef4444',

        boxShadow: '0 0 8px rgba(239, 68, 68, 0.5)'
    },
    watched_history: {
        opacity: '0.7'
    }
};

function applyHighlightStyle(element: HTMLElement, type: HighlightType) {
    if (element.dataset.tmsyncHighlightStyle === type) {
        return;
    }

    clearHighlightStyle(element);

    const styles = highlightStyles[type];
    if (styles) {
        Object.assign(element.style, styles);

        element.dataset.tmsyncHighlightStyle = type;
    }
}

function clearHighlightStyle(element: HTMLElement) {
    const previousStyleType = element.dataset.tmsyncHighlightStyle;
    if (
        previousStyleType &&
        highlightStyles[previousStyleType as HighlightType]
    ) {
        const stylesToRemove =
            highlightStyles[previousStyleType as HighlightType];
        for (const prop in stylesToRemove) {
            element.style.removeProperty(
                prop.replace(/([A-Z])/g, '-$1').toLowerCase()
            );
        }
    }

    delete element.dataset.tmsyncHighlightStyle;
}

function highlightSingleEpisodeElement(
    element: HTMLElement,
    expectedSeason: number,
    expectedEpisode: number,
    highlightInfo: HighlightInfo | null,
    watchedEpisodes?: { season: number; number: number }[]
) {
    clearHighlightStyle(element);
    if (
        watchedEpisodes?.some(
            (ep) =>
                ep.season === expectedSeason && ep.number === expectedEpisode
        )
    ) {
        if (
            !highlightInfo ||
            highlightInfo.season !== expectedSeason ||
            highlightInfo.episode !== expectedEpisode
        ) {
            applyHighlightStyle(element, 'watched_history');
        }
    }

    if (
        highlightInfo &&
        expectedSeason === highlightInfo.season &&
        expectedEpisode === highlightInfo.episode
    ) {
        applyHighlightStyle(element, highlightInfo.type);
    }
}

function processContainerWithConfig(
    containerElement: Element,
    contextConfig: EpisodeListContextConfig,
    highlightInfo: HighlightInfo | null,
    watchedEpisodes?: { season: number; number: number }[]
) {
    console.log(
        `Processing container with config for selector: ${contextConfig.itemSelector}`,
        containerElement
    );
    const items = containerElement.querySelectorAll(contextConfig.itemSelector);
    items.forEach((itemEl) => {
        const se = contextConfig.getSeasonEpisodeFromElement(
            itemEl,
            containerElement
        );
        if (se) {
            const elementToStyle = contextConfig.getElementToStyle(itemEl);
            if (elementToStyle) {
                highlightSingleEpisodeElement(
                    elementToStyle,
                    se.season,
                    se.episode,
                    highlightInfo,
                    watchedEpisodes
                );
            }
        }
    });
}

export function setupEpisodeHighlighting(
    siteConfig: SiteConfigBase,
    highlightInfo: HighlightInfo | null,
    watchedEpisodes?: { season: number; number: number }[]
) {
    if (
        !siteConfig.highlighting?.getCurrentHighlightContextKey ||
        !siteConfig.highlighting.contexts
    ) {
        console.warn(
            `Highlighting not fully configured for site: ${siteConfig.name}`
        );
        return;
    }

    const currentContextKey =
        siteConfig.highlighting.getCurrentHighlightContextKey(
            window.location.href
        );
    if (!currentContextKey) {
        console.log(
            `No active highlighting context for current URL on ${siteConfig.name}.`
        );

        clearHighlighting(siteConfig.name, null);
        return;
    }

    const contextConfig = siteConfig.highlighting.contexts[currentContextKey];
    if (!contextConfig) {
        console.warn(
            `Highlighting context '${currentContextKey}' not found in config for ${siteConfig.name}.`
        );
        return;
    }

    const observerKey = `${siteConfig.name}-hl-observer-${currentContextKey}`;

    if (observers.has(observerKey)) {
        observers.get(observerKey)?.disconnect();
    }

    const callback: MutationCallback = (mutationsList, observer) => {
        const containersToReProcess = new Set<Element>();

        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                if (
                    mutation.target instanceof Element &&
                    mutation.target.matches(contextConfig.containerSelector)
                ) {
                    containersToReProcess.add(mutation.target);
                }

                for (const node of mutation.addedNodes) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const addedElement = node as Element;

                        if (addedElement.matches(contextConfig.itemSelector)) {
                            const parentContainer = addedElement.closest(
                                contextConfig.containerSelector
                            );
                            if (parentContainer) {
                                containersToReProcess.add(parentContainer);
                            } else {
                                console.warn(
                                    `Individual item '${contextConfig.itemSelector}' added, but its direct container ` +
                                        `'${contextConfig.containerSelector}' not found via .closest(). Skipping individual fallback highlight for this item.`
                                );
                            }
                        } else if (
                            addedElement.matches(
                                contextConfig.containerSelector
                            )
                        ) {
                            containersToReProcess.add(addedElement);
                        } else if (
                            addedElement.querySelector(
                                contextConfig.containerSelector
                            )
                        ) {
                            containersToReProcess.add(
                                addedElement.querySelector(
                                    contextConfig.containerSelector
                                )!
                            );
                        }
                    }
                }
            } else if (mutation.type === 'attributes') {
                if (mutation.target instanceof Element) {
                    const mutatedElement = mutation.target;

                    if (
                        mutatedElement.matches(contextConfig.containerSelector)
                    ) {
                        containersToReProcess.add(mutatedElement);
                    } else if (
                        mutatedElement.matches(contextConfig.itemSelector)
                    ) {
                        const parentContainer = mutatedElement.closest(
                            contextConfig.containerSelector
                        );
                        if (parentContainer) {
                            containersToReProcess.add(parentContainer);
                        }
                    }
                }
            }
        }

        if (containersToReProcess.size > 0) {
            containersToReProcess.forEach((container) => {
                processContainerWithConfig(
                    container,
                    contextConfig,
                    highlightInfo,
                    watchedEpisodes
                );
            });
        }
    };

    const obs = new MutationObserver(callback);
    obs.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class']
    });
    observers.set(observerKey, obs);
    console.log(
        `MutationObserver for ${siteConfig.name} (context: ${currentContextKey}) set up.`
    );

    const initialContainer = document.querySelector(
        contextConfig.containerSelector
    );
    if (initialContainer) {
        console.log(`Initial scan: Found container for ${currentContextKey}.`);
        processContainerWithConfig(
            initialContainer,
            contextConfig,
            highlightInfo,
            watchedEpisodes
        );
    }
}

export function clearHighlighting(siteName: string, contextKey: string | null) {
    const keyToClear = contextKey
        ? `${siteName}-hl-observer-${contextKey}`
        : null;

    if (keyToClear && observers.has(keyToClear)) {
        observers.get(keyToClear)?.disconnect();
        observers.delete(keyToClear);
        console.log(
            `Highlighting observer stopped for ${siteName} context ${contextKey}`
        );
    } else if (!contextKey) {
        observers.forEach((observer, key) => {
            if (key.startsWith(`${siteName}-hl-observer-`)) {
                observer.disconnect();
                observers.delete(key);
            }
        });
        console.log(`All highlighting observers stopped for ${siteName}`);
    }

    document
        .querySelectorAll(`[data-${HIGHLIGHT_STYLE_ATTRIBUTE.substring(5)}]`)
        .forEach((el) => clearHighlightStyle(el as HTMLElement));
}
</file>

<file path="src/utils/serviceFiltering.ts">
import { TrackerService } from '../types/services';
import { isServiceEnabled } from './servicePreferences';

/**
 * Filter services based on user preferences and authentication status
 * Only returns services that are both enabled by user AND authenticated
 */
export async function filterEnabledAuthenticatedServices(
    services: TrackerService[]
): Promise<TrackerService[]> {
    const filteredServices: TrackerService[] = [];

    for (const service of services) {
        const serviceType = service.getCapabilities().serviceType;

        // Check if user has enabled this service
        const userEnabled = await isServiceEnabled(serviceType);
        if (!userEnabled) {
            console.log(
                `üö´ Service ${serviceType} disabled by user preference`
            );
            continue;
        }

        // Check if service is authenticated
        const isAuthenticated = await service
            .isAuthenticated()
            .catch(() => false);
        if (!isAuthenticated) {
            console.log(`üö´ Service ${serviceType} not authenticated`);
            continue;
        }

        console.log(`‚úÖ Service ${serviceType} enabled and authenticated`);
        filteredServices.push(service);
    }

    return filteredServices;
}
</file>

<file path="src/utils/servicePreferences.ts">
import { ServiceType } from '../types/serviceTypes';

export interface ServicePreferences {
    [key: string]: boolean; // ServiceType -> enabled state
}

const STORAGE_KEY = 'servicePreferences';

/**
 * Get user preferences for service enablement
 * Default: all services enabled
 */
export async function getServicePreferences(): Promise<ServicePreferences> {
    const result = await chrome.storage.sync.get(STORAGE_KEY);
    return result[STORAGE_KEY] || {};
}

/**
 * Update preference for a specific service
 */
export async function setServiceEnabled(
    serviceType: ServiceType,
    enabled: boolean
): Promise<void> {
    const preferences = await getServicePreferences();
    preferences[serviceType] = enabled;
    await chrome.storage.sync.set({ [STORAGE_KEY]: preferences });
}

/**
 * Check if a service is enabled by user preference
 * Default: enabled if not explicitly disabled
 */
export async function isServiceEnabled(
    serviceType: ServiceType
): Promise<boolean> {
    const preferences = await getServicePreferences();
    return preferences[serviceType] !== false; // Default to enabled
}

/**
 * Check if user has disabled all services
 * Used to determine if content script should show minimal functionality
 */
export async function areAllServicesDisabled(
    availableServices: ServiceType[]
): Promise<boolean> {
    const preferences = await getServicePreferences();
    return availableServices.every(
        (serviceType) => preferences[serviceType] === false
    );
}

/**
 * Reset all service preferences to default (enabled)
 */
export async function resetServicePreferences(): Promise<void> {
    await chrome.storage.sync.remove(STORAGE_KEY);
}
</file>

<file path="webpack/webpack.prod.js">
const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = merge(common, {
    mode: 'production',
    optimization: {
        minimizer: [
            new TerserPlugin({
                terserOptions: {
                    format: {
                        comments: false
                    }
                },
                extractComments: false
            }),
            new CssMinimizerPlugin()
        ]
    }
});
</file>

<file path=".env.example">
TRAKT_CLIENT_ID=
TRAKT_CLIENT_SECRET=
ANILIST_CLIENT_ID=
</file>

<file path="eslint.config.mjs">
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import eslintConfigPrettier from "eslint-config-prettier";

export default [
  {
    files: ["**/*.{js,mjs,cjs,ts,tsx}"],
    languageOptions: {
      globals: { ...globals.browser, ...globals.webextensions, ...globals.node },
    },
  },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  {
    rules: {
      // Relax some strict TypeScript rules for gradual migration
      "@typescript-eslint/no-explicit-any": "warn",
      "@typescript-eslint/no-unused-vars": "warn",
      "prefer-const": "warn",
    },
  },
  eslintConfigPrettier,
];
</file>

<file path="postcss.config.mjs">
export default {
    plugins: {
        '@tailwindcss/postcss': {}
    }
};
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
    test: {
        environment: 'jsdom',
        setupFiles: ['./src/test/setup.ts'],
        globals: true,
        coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
            exclude: [
                'node_modules/',
                'dist/',
                'webpack/',
                'src/test/',
                '**/*.d.ts',
                '**/*.config.*',
                'coverage/**'
            ]
        }
    },
    resolve: {
        alias: {
            '@': resolve(__dirname, 'src')
        }
    }
});
</file>

<file path="public/options.html">
<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>TMSync Options</title>

        <link rel="stylesheet" href="./css/styles.css" />
    </head>
    <body>
        <div id="root"></div>

        <script src="./js/vendor.js"></script>
        <script src="./js/options.js"></script>
    </body>
</html>
</file>

<file path="public/popup.html">
<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>TMSync Popup</title>

        <link rel="stylesheet" href="./css/styles.css" />
    </head>
    <body style="width: 300px; /* Adjust width as needed */">
        <div id="root"></div>

        <script src="./js/vendor.js"></script>
        <script src="./js/popup.js"></script>
    </body>
</html>
</file>

<file path="src/background/state.ts">
import { ActiveScrobbleState } from '../types/scrobbling';

const initialState: ActiveScrobbleState = {
    tabId: null,
    mediaInfo: null,
    episodeInfo: undefined,
    currentProgress: 0,
    status: 'idle',
    traktMediaType: null,
    lastUpdateTime: 0,
    previousScrobbledUrl: ''
};

export const scrobbleState = {
    current: { ...initialState }
};

export function resetActiveScrobbleState() {
    scrobbleState.current = { ...initialState };
    console.log('Active scrobble state reset.');
}
</file>

<file path="src/components/AuthenticationHub.tsx">
import React from 'react';
import { useMultiServiceAuth } from '../hooks/useMultiServiceAuth';
import { ServiceType } from '../types/serviceTypes';

interface ServiceAuthCardProps {
    serviceType: ServiceType;
    isLoggedIn: boolean;
    username: string | null;
    isLoading: boolean;
    error: string | null;
    onLogin: () => Promise<void>;
    onLogout: () => Promise<void>;
    onClearError: () => void;
    capabilities: {
        supportsScrobbling: boolean;
        supportsRatings: boolean;
        supportsComments: boolean;
        supportedMediaTypes: ('movie' | 'show')[];
    };
}

const ServiceAuthCard: React.FC<ServiceAuthCardProps> = ({
    serviceType,
    isLoggedIn,
    username,
    isLoading,
    error,
    onLogin,
    onLogout,
    onClearError,
    capabilities
}) => {
    const serviceName =
        serviceType.charAt(0).toUpperCase() + serviceType.slice(1);

    const getStatusColor = () => {
        if (error) return 'text-red-500';
        if (isLoggedIn) return 'text-green-500';
        return 'text-gray-500';
    };

    const getStatusText = () => {
        if (isLoading) return 'Checking...';
        if (error) return 'Error';
        if (isLoggedIn) return `Logged in${username ? ` as ${username}` : ''}`;
        return 'Not authenticated';
    };

    const getCapabilityText = () => {
        const caps = [];
        if (capabilities.supportsScrobbling) caps.push('Scrobbling');
        if (capabilities.supportsRatings) caps.push('Ratings');
        if (capabilities.supportsComments) caps.push('Comments');

        const mediaTypes = capabilities.supportedMediaTypes.join(', ');
        return `${caps.join(', ')} ‚Ä¢ ${mediaTypes}`;
    };

    return (
        <div className="border border-(--color-border) rounded-lg p-4 bg-(--color-surface-1)">
            <div className="flex items-center justify-between mb-3">
                <div>
                    <h3 className="text-lg font-semibold text-(--color-text-primary)">
                        {serviceName}
                    </h3>
                    <p className={`text-sm ${getStatusColor()}`}>
                        {getStatusText()}
                    </p>
                </div>

                <div className="flex gap-2">
                    {error && (
                        <button
                            onClick={onClearError}
                            className="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50"
                            title="Clear error"
                        >
                            Clear
                        </button>
                    )}

                    {isLoggedIn ? (
                        <button
                            onClick={onLogout}
                            disabled={isLoading}
                            className="px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
                        >
                            {isLoading ? 'Loading...' : 'Logout'}
                        </button>
                    ) : (
                        <button
                            onClick={onLogin}
                            disabled={isLoading}
                            className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
                        >
                            {isLoading ? 'Loading...' : 'Login'}
                        </button>
                    )}
                </div>
            </div>

            {error && (
                <div className="mb-3 p-2 bg-red-50 border border-red-200 rounded text-red-700 text-sm">
                    {error}
                </div>
            )}

            <div className="text-sm text-(--color-text-secondary)">
                <strong>Capabilities:</strong> {getCapabilityText()}
            </div>
        </div>
    );
};

interface AuthenticationHubProps {
    showBulkActions?: boolean;
    className?: string;
}

export const AuthenticationHub: React.FC<AuthenticationHubProps> = ({
    showBulkActions = true,
    className = ''
}) => {
    const {
        services,
        authenticatedServices,
        hasAnyAuthenticated,
        isAnyLoading,
        hasAnyErrors,
        isServicesInitialized,
        loginToAll,
        logoutFromAll,
        refreshAllStatus,
        clearAllErrors
    } = useMultiServiceAuth();

    return (
        <div className={`space-y-4 ${className}`}>
            {/* Header with summary */}
            <div className="flex items-center justify-between">
                <div>
                    <h2 className="text-xl font-bold text-(--color-text-primary)">
                        Service Authentication
                    </h2>
                    <p className="text-sm text-(--color-text-secondary)">
                        {authenticatedServices.length} of {services.length}{' '}
                        services authenticated
                    </p>
                </div>

                {showBulkActions && services.length > 1 && (
                    <div className="flex gap-2">
                        <button
                            onClick={refreshAllStatus}
                            disabled={isAnyLoading}
                            className="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50"
                        >
                            Refresh All
                        </button>

                        {hasAnyErrors && (
                            <button
                                onClick={clearAllErrors}
                                className="px-3 py-1 text-sm bg-orange-500 text-white rounded hover:bg-orange-600"
                            >
                                Clear Errors
                            </button>
                        )}

                        {hasAnyAuthenticated && (
                            <button
                                onClick={logoutFromAll}
                                disabled={isAnyLoading}
                                className="px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50"
                            >
                                Logout All
                            </button>
                        )}

                        <button
                            onClick={loginToAll}
                            disabled={isAnyLoading}
                            className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
                        >
                            Login All
                        </button>
                    </div>
                )}
            </div>

            {/* Service cards */}
            <div className="space-y-3">
                {services.map((service) => (
                    <ServiceAuthCard
                        key={service.serviceType}
                        serviceType={service.serviceType}
                        isLoggedIn={service.isLoggedIn}
                        username={service.username}
                        isLoading={service.isLoading}
                        error={service.error}
                        onLogin={service.login}
                        onLogout={service.logout}
                        onClearError={service.clearError}
                        capabilities={service.capabilities}
                    />
                ))}
            </div>

            {!isServicesInitialized && (
                <div className="text-center py-8">
                    <div className="inline-flex items-center px-4 py-2 bg-blue-50 border border-blue-200 rounded-lg">
                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500 mr-2"></div>
                        <span className="text-blue-700">
                            Initializing services...
                        </span>
                    </div>
                </div>
            )}

            {isServicesInitialized && services.length === 0 && (
                <div className="text-center py-8 text-(--color-text-secondary)">
                    No tracking services configured
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/content-scripts/main/components/ManualSearchPrompt.tsx">
import React, { useState, useEffect } from 'react';
import { isMovieMediaInfo, isShowMediaInfo } from '../../../utils/typeGuards';
import {
    MediaInfoResponse,
    MovieMediaInfo,
    ShowMediaInfo
} from '../../../types/media';
import { MessageRequest, MessageResponse } from '../../../types/messaging';

interface ManualSearchPromptProps {
    originalQuery: { type: string; query: string; years: string };
    onConfirmMedia: (selectedMedia: MediaInfoResponse) => void | Promise<void>;
    onCancel: () => void;
}

export const ManualSearchPrompt: React.FC<ManualSearchPromptProps> = ({
    originalQuery,
    onConfirmMedia,
    onCancel
}) => {
    const [searchTerm, setSearchTerm] = useState(originalQuery.query);
    const [searchResults, setSearchResults] = useState<
        (MovieMediaInfo | ShowMediaInfo)[]
    >([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const handleSearch = async () => {
        if (!searchTerm.trim()) return;
        setIsLoading(true);
        setError(null);
        setSearchResults([]);

        try {
            const response = await chrome.runtime.sendMessage<
                MessageRequest,
                MessageResponse<(MovieMediaInfo | ShowMediaInfo)[]>
            >({
                action: 'manualSearch',
                params: {
                    type: originalQuery.type,
                    query: searchTerm
                }
            });

            if (response.success && response.data) {
                setSearchResults(response.data);
                if (response.data.length === 0) {
                    setError('No results found for your search.');
                }
            } else {
                setError(response.error || 'Search failed.');
            }
        } catch (err) {
            console.error('Manual search send message error:', err);
            setError(
                err instanceof Error
                    ? err.message
                    : 'An unknown error occurred during search.'
            );
        } finally {
            setIsLoading(false);
        }
    };

    const handleSelect = (media: MediaInfoResponse) => {
        console.log('Media selected:', media);
        onConfirmMedia(media);
    };

    useEffect(() => {
        handleSearch();
    }, []);

    const getTitle = (item: MovieMediaInfo | ShowMediaInfo) => {
        if (isMovieMediaInfo(item)) {
            return item.movie.title;
        } else if (isShowMediaInfo(item)) {
            return item.show.title;
        }
        return 'Unknown Title';
    };
    const getYear = (item: MovieMediaInfo | ShowMediaInfo) => {
        if (isMovieMediaInfo(item)) {
            return item.movie.year;
        } else if (isShowMediaInfo(item)) {
            return item.show.year;
        }
        return undefined;
    };

    return (
        <div className="tmsync-manual-search fixed bottom-[60px] left-1/2 -translate-x-1/2 z-[1000000000] bg-(--color-surface-1) border border-(--color-border) rounded-lg p-4 shadow-lg w-[350px] text-(--color-text-primary)">
            <p className="m-0 mb-2.5 text-sm">
                Couldn't automatically identify "{originalQuery.query}". Please
                confirm or search:
            </p>
            <div className="flex">
                <input
                    type="text"
                    className="w-[calc(100%-80px)] p-2 mr-1 border border-(--color-border) rounded bg-(--color-background) text-(--color-text-primary) focus:ring-2 focus:ring-(--color-accent-primary) focus:outline-none"
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    placeholder="Search on Trakt..."
                />
                <button
                    className="px-3 py-2 cursor-pointer border-none rounded ml-1 bg-(--color-accent-primary) text-(--color-text-primary) disabled:opacity-50"
                    onClick={handleSearch}
                    disabled={isLoading}
                >
                    {isLoading ? '...' : 'Search'}
                </button>
            </div>

            {error && (
                <p className="text-(--color-danger) text-xs mt-1">{error}</p>
            )}

            {isLoading && searchResults.length === 0 && <p>Loading...</p>}

            {!isLoading && searchResults.length > 0 && (
                <div className="max-h-[200px] overflow-y-auto mt-2.5 border-t border-(--color-border) pt-2.5">
                    {searchResults.map((item) => {
                        const key = isMovieMediaInfo(item)
                            ? item.movie.ids?.trakt
                            : isShowMediaInfo(item)
                              ? item.show.ids?.trakt
                              : `fallback-${Math.random()}`;
                        return (
                            <div
                                key={key}
                                className="p-2 border-b border-(--color-border) flex justify-between items-center"
                            >
                                <span>
                                    {getTitle(item)} ({getYear(item)})
                                </span>
                                <button
                                    className="px-2 py-1 cursor-pointer border-none rounded bg-(--color-success) text-white text-xs disabled:opacity-50"
                                    onClick={() => handleSelect(item)}
                                >
                                    Select
                                </button>
                            </div>
                        );
                    })}
                </div>
            )}

            <button
                className="px-3 py-2 cursor-pointer border-none rounded ml-1 bg-(--color-danger) text-white mt-2.5 block w-full disabled:opacity-50"
                onClick={onCancel}
                disabled={isLoading}
            >
                Cancel / Not This
            </button>
        </div>
    );
};
</file>

<file path="src/content-scripts/trakt/index.tsx">
import React, { useEffect, useState } from 'react';
import { createRoot, Root } from 'react-dom/client';
import '../../styles/index.css';
import { siteConfigs } from '../../utils/siteConfigs';
import { SiteConfigBase } from '../../utils/siteConfigs/baseConfig';
import { UserQuickLinkPrefs } from '../../options';

export interface TraktPageInfo {
    type: 'movie' | 'show';
    traktSlug?: string;
    tmdbId?: string;
    traktId?: number;
    title?: string;
    year?: number;
    season?: number;
    episode?: number;
}

interface QuickLinkConfig {
    siteKey: string;
    name: string;
    logoUrl?: string;
    enabled: boolean;
    order: number;
    generateLink: (
        info: TraktPageInfo,
        siteSpecificConfig: SiteConfigBase
    ) => string | null;
}

function getTraktPageInfo(): TraktPageInfo | null {
    const path = window.location.pathname.split('/');
    const info: Partial<TraktPageInfo> = {};

    const tmdbLinkElement = document.getElementById(
        'external-link-tmdb'
    ) as HTMLAnchorElement;
    if (tmdbLinkElement && tmdbLinkElement.href) {
        const tmdbUrl = new URL(tmdbLinkElement.href);
        const tmdbPathParts = tmdbUrl.pathname.split('/');
        if (tmdbPathParts.length >= 3) {
            info.tmdbId = tmdbPathParts[2];
        }
    }

    const titleElement = document.querySelector('h1[itemprop="name"]');
    if (titleElement) {
        info.title = titleElement.textContent?.trim() || undefined;
        const yearElement = titleElement.querySelector('span.year');
        if (yearElement?.textContent) {
            info.year = parseInt(yearElement.textContent, 10) || undefined;
        }
    }

    if (path[1] === 'shows') {
        info.type = 'show';
        info.traktSlug = path[2];
        if (path[3] === 'seasons' && path[4]) {
            info.season = parseInt(path[4], 10);
            if (path[5] === 'episodes' && path[6]) {
                info.episode = parseInt(path[6], 10);
            }
        }
    } else if (path[1] === 'movies') {
        info.type = 'movie';
        info.traktSlug = path[2];
    } else {
        return null;
    }

    if (!info.type || (!info.tmdbId && !info.traktSlug)) return null;

    return info as TraktPageInfo;
}

function generateSiteLink(
    pageInfo: TraktPageInfo,
    siteKey: string,
    config: SiteConfigBase
): string | null {
    if (config.generateWatchLink) {
        return config.generateWatchLink(pageInfo);
    }

    return null;
}

const QuickLinksInjector: React.FC<{
    pageInfo: TraktPageInfo;
    storedLinkPrefs: UserQuickLinkPrefs | null;
}> = ({ pageInfo, storedLinkPrefs }) => {
    const [quickLinks, setQuickLinks] = useState<QuickLinkConfig[]>([]);

    useEffect(() => {
        const enabledLinks: QuickLinkConfig[] = [];
        const defaultOrder = Object.keys(siteConfigs).length;

        for (const siteKey in siteConfigs) {
            const config = siteConfigs[siteKey];
            const userPref = storedLinkPrefs?.[siteKey];

            if (userPref?.enabled ?? true) {
                const link = generateSiteLink(pageInfo, siteKey, config);
                if (link) {
                    enabledLinks.push({
                        siteKey: siteKey,
                        name: config.name,

                        logoUrl: chrome.runtime.getURL(
                            `images/logos/${siteKey.toLowerCase()}.png`
                        ),
                        enabled: true,
                        order: userPref?.order ?? defaultOrder,
                        generateLink: (info, cfg) =>
                            generateSiteLink(info, siteKey, cfg)
                    });
                }
            }
        }
        enabledLinks.sort((a, b) => a.order - b.order);
        setQuickLinks(enabledLinks);
    }, [pageInfo, storedLinkPrefs]);

    if (quickLinks.length === 0) {
        return null;
    }

    return (
        <div className="tmsync-quicklinks-container mt-2 flex flex-wrap gap-2 items-center border-t border-gray-700 pt-2">
            {quickLinks.map((linkConfig) => (
                <a
                    key={linkConfig.siteKey}
                    href={
                        linkConfig.generateLink(
                            pageInfo,
                            siteConfigs[linkConfig.siteKey]
                        )!
                    }
                    target="_blank"
                    rel="noopener noreferrer"
                    title={`Watch on ${linkConfig.name}`}
                    className="flex items-center justify-center h-15 w-15 p-1 bg-gray-700 hover:bg-gray-600 rounded-md transition-colors overflow-hidden group"
                >
                    <img
                        src={linkConfig.logoUrl}
                        alt={`${linkConfig.name} logo`}
                        className="block max-h-full max-w-full object-contain transition-transform duration-200 group-hover:scale-110"
                        onError={(e) => {
                            (e.target as HTMLImageElement).classList.add(
                                'hidden'
                            );
                        }}
                    />
                </a>
            ))}
        </div>
    );
};

async function injectQuickLinks() {
    const watchNowButton = document.querySelector('a.btn-watch-now');
    const sidebar = document.querySelector('div.sidebar.posters');
    let injectionTarget: Element | null = null;
    let injectionMethod: 'after' | 'prepend' = 'after';

    if (watchNowButton) {
        injectionTarget = watchNowButton;
        injectionMethod = 'after';
    } else if (sidebar) {
        injectionTarget = sidebar;
        injectionMethod = 'prepend';
    } else {
        console.error('TMSync: Could not find injection point.');
        return;
    }

    const pageInfo = getTraktPageInfo();
    if (!pageInfo) return;
    const prefs = await chrome.storage.sync.get(['quickLinkPreferences']);
    const storedLinkPrefs =
        prefs.quickLinkPreferences as UserQuickLinkPrefs | null;

    const injectorId = 'tmsync-quicklinks-injector';
    let injectorHost = document.getElementById(
        injectorId
    ) as HTMLElement | null;
    let shadowRoot: ShadowRoot | null = null;
    let reactRoot: Root | null = null;

    if (!injectorHost) {
        console.log('TMSync: Creating injector host and shadow root.');
        injectorHost = document.createElement('div');
        injectorHost.id = injectorId;
        injectorHost.className = 'tmsync-quicklinks-host mt-3 mb-3';

        shadowRoot = injectorHost.attachShadow({ mode: 'open' });

        if (injectionMethod === 'after' && injectionTarget?.parentNode) {
            injectionTarget.parentNode.insertBefore(
                injectorHost,
                injectionTarget.nextSibling
            );
        } else if (injectionMethod === 'prepend' && injectionTarget) {
            injectionTarget.insertBefore(
                injectorHost,
                injectionTarget.firstChild
            );
        } else {
            console.error('TMSync: Could not inject host element.');
            return;
        }

        try {
            const cssUrl = chrome.runtime.getURL('css/styles.css');
            console.log('TMSync: Loading CSS:', cssUrl);
            const response = await fetch(cssUrl);
            if (!response.ok)
                throw new Error(`CSS fetch failed: ${response.statusText}`);
            const cssText = await response.text();
            const sheet = new CSSStyleSheet();
            await sheet.replace(cssText);
            shadowRoot.adoptedStyleSheets = [sheet];
            console.log('TMSync: CSS loaded into Shadow DOM.');
        } catch (error) {
            console.error('TMSync: Failed to load CSS into Shadow DOM:', error);
        }

        const reactContainer = document.createElement('div');
        reactContainer.id = 'react-root';
        shadowRoot.appendChild(reactContainer);
        reactRoot = createRoot(reactContainer);
    } else {
        shadowRoot = injectorHost.shadowRoot;
        const reactContainer = shadowRoot?.getElementById('react-root');
        if (reactContainer) {
            reactRoot = createRoot(reactContainer);
        } else {
            console.error(
                "TMSync: Found host but couldn't find react-root inside shadowRoot."
            );
            return;
        }
        console.log('TMSync: Injector host already exists.');
    }

    if (reactRoot) {
        reactRoot.render(
            <QuickLinksInjector
                pageInfo={pageInfo}
                storedLinkPrefs={storedLinkPrefs}
            />
        );
        console.log('TMSync: Quick links component rendered into Shadow DOM.');
    } else {
        console.error('TMSync: Failed to obtain React root instance.');
    }
}

const observer = new MutationObserver((mutations, obs) => {
    const watchNowButton = document.querySelector('a.btn-watch-now');
    const sidebar = document.querySelector('div.sidebar.posters');
    const tmdbLink = document.getElementById('external-link-tmdb');

    if ((watchNowButton || sidebar) && tmdbLink) {
        console.log('TMSync: Required elements found, injecting quick links.');
        injectQuickLinks();
        obs.disconnect();
    }
});

observer.observe(document.body, { childList: true, subtree: true });

const initialWatchNowButton = document.querySelector('a.btn-watch-now');
const initialSidebar = document.querySelector('div.sidebar.posters');
const initialTmdbLink = document.getElementById('external-link-tmdb');
if ((initialWatchNowButton || initialSidebar) && initialTmdbLink) {
    injectQuickLinks();
    observer.disconnect();
}
</file>

<file path="src/hooks/useTraktAuth.ts">
import { useState, useEffect, useCallback } from 'react';
import { traktService } from '../services/TraktService';

export function useTraktAuth() {
    const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);
    const [username, setUsername] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const checkAuthStatus = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const isAuth = await traktService.isAuthenticated();
            if (isAuth) {
                const username = await traktService.getUsername();
                setIsLoggedIn(true);
                setUsername(username);
            } else {
                setIsLoggedIn(false);
                setUsername(null);
            }
        } catch (err) {
            console.error('Error checking auth status:', err);
            setError(
                err instanceof Error
                    ? err.message
                    : 'An error occurred checking login status.'
            );
            setIsLoggedIn(false);
            setUsername(null);
        } finally {
            setIsLoading(false);
        }
    }, []);

    const login = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            await traktService.login();
            await checkAuthStatus();
        } catch (err) {
            console.error('Error during login process:', err);
            setError(
                err instanceof Error
                    ? err.message
                    : 'An unexpected error occurred during login.'
            );
            setIsLoggedIn(false);
            setUsername(null);
        } finally {
            setIsLoading(false);
        }
    }, [checkAuthStatus]);

    const logout = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            await traktService.logout();
        } catch (err) {
            console.error('Error during logout:', err);
        } finally {
            setIsLoggedIn(false);
            setUsername(null);
            setIsLoading(false);
        }
    }, []);

    useEffect(() => {
        checkAuthStatus();
    }, [checkAuthStatus]);

    return { isLoggedIn, username, isLoading, error, login, logout };
}
</file>

<file path="src/services/ServiceRegistry.ts">
import {
    TrackerService,
    ServiceRegistry,
    ServiceConfig
} from '../types/services';
import { ServiceType, ServiceCapabilities } from '../types/serviceTypes';

/**
 * Implementation of ServiceRegistry that manages all tracking services
 */
export class DefaultServiceRegistry implements ServiceRegistry {
    private services = new Map<ServiceType, TrackerService>();
    private configs = new Map<ServiceType, ServiceConfig>();

    /**
     * Get all registered services
     */
    getAllServices(): TrackerService[] {
        return Array.from(this.services.values());
    }

    /**
     * Get all enabled services ordered by priority
     */
    getEnabledServices(): TrackerService[] {
        const enabledConfigs = Array.from(this.configs.entries())
            .filter(([, config]) => config.enabled)
            .sort(([, a], [, b]) => a.priority - b.priority);

        return enabledConfigs
            .map(([serviceType]) => this.services.get(serviceType))
            .filter(
                (service): service is TrackerService => service !== undefined
            );
    }

    /**
     * Get a specific service by type
     */
    getService(serviceType: ServiceType): TrackerService | null {
        return this.services.get(serviceType) || null;
    }

    /**
     * Register a new service
     */
    registerService(service: TrackerService, config: ServiceConfig): void {
        const serviceType = service.getCapabilities().serviceType;
        this.services.set(serviceType, service);
        this.configs.set(serviceType, config);
    }

    /**
     * Update service configuration
     */
    updateServiceConfig(
        serviceType: ServiceType,
        config: Partial<ServiceConfig>
    ): void {
        const existingConfig = this.configs.get(serviceType);
        if (existingConfig) {
            this.configs.set(serviceType, { ...existingConfig, ...config });
        }
    }

    /**
     * Get service configuration
     */
    getServiceConfig(serviceType: ServiceType): ServiceConfig | null {
        return this.configs.get(serviceType) || null;
    }

    /**
     * Check if a service is enabled
     */
    isServiceEnabled(serviceType: ServiceType): boolean {
        const config = this.configs.get(serviceType);
        return config?.enabled ?? false;
    }

    /**
     * Get the primary (highest priority) service
     */
    getPrimaryService(): TrackerService | null {
        const enabledServices = this.getEnabledServices();
        return enabledServices.length > 0 ? enabledServices[0] : null;
    }

    /**
     * Get service by type
     */
    getServiceByType(serviceType: ServiceType): TrackerService | null {
        return this.services.get(serviceType) || null;
    }

    /**
     * Get services that support a specific capability
     */
    getServicesWithCapability(
        capability: keyof ServiceCapabilities
    ): TrackerService[] {
        return this.getEnabledServices().filter((service) => {
            const capabilities = service.getCapabilities();
            return capabilities[capability];
        });
    }
}

// Export singleton instance
export const serviceRegistry = new DefaultServiceRegistry();
</file>

<file path="src/types/scrobbling.ts">
// Contains types specific to the scrobbling state machine and UI.

import { MediaInfoResponse, SeasonEpisodeObj } from './media';

export type ActiveScrobbleStatus = 'idle' | 'started' | 'paused';

export interface ActiveScrobbleState {
    tabId: number | null;
    mediaInfo: MediaInfoResponse | null;
    episodeInfo?: SeasonEpisodeObj | null;
    currentProgress: number;
    status: ActiveScrobbleStatus;
    traktMediaType: 'movie' | 'episode' | null;
    lastUpdateTime: number;
    previousScrobbledUrl?: string;
}

export interface WatchStatusInfo {
    isInHistory: boolean;
    lastWatchedAt?: string;
    isCompleted?: boolean;
}

export interface ScrobbleStopResponseData {
    traktHistoryId?: number;
    action: 'watched' | 'paused_incomplete' | 'error';
    serviceHistoryIds?: { [serviceType: string]: number | string };
}

export type ScrobbleNotificationMediaType =
    | MediaInfoResponse
    | (MediaInfoResponse & SeasonEpisodeObj);
</file>

<file path="src/types/services.ts">
import { MediaInfoResponse, SeasonEpisodeObj } from './media';
import { WatchStatusInfo } from './scrobbling';
import {
    ServiceType,
    ServiceComment,
    ServiceProgressInfo,
    ServiceMediaIds,
    ServiceMediaRatings,
    ServiceScrobbleResponse,
    ServiceCapabilities
} from './serviceTypes';

/**
 * Generic interface for all media tracking services
 *
 * This interface defines the contract that all tracking services must implement
 * to work with the TMSync multi-service architecture.
 */
export interface TrackerService {
    /**
     * Get service capabilities and configuration
     */
    getCapabilities(): ServiceCapabilities;

    /**
     * Authentication Methods
     */

    /**
     * Check if user is currently authenticated with this service
     */
    isAuthenticated(): Promise<boolean>;

    /**
     * Get current username for this service
     */
    getUsername(): Promise<string>;

    /**
     * Initiate login flow for this service
     */
    login(): Promise<void>;

    /**
     * Logout and clear stored credentials
     */
    logout(): Promise<void>;

    /**
     * Media Search and Identification Methods
     */

    /**
     * Search for media by query and type
     */
    searchMedia(
        query: string,
        type: 'movie' | 'show',
        years?: string
    ): Promise<MediaInfoResponse[]>;

    /**
     * Get media info by TMDB ID
     */
    getMediaByTmdbId(
        tmdbId: string,
        type: 'movie' | 'show'
    ): Promise<MediaInfoResponse | null>;

    /**
     * Get detailed media status including watch history and ratings
     */
    getMediaStatus(mediaInfo: MediaInfoResponse): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }>;

    /**
     * Get media status with episode-specific ratings
     */
    getMediaStatusWithEpisode(
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }>;

    /**
     * Scrobbling Methods
     */

    /**
     * Start scrobbling media
     */
    startScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void>;

    /**
     * Pause scrobbling
     */
    pauseScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void>;

    /**
     * Stop scrobbling and mark as watched if threshold met
     */
    stopScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<ServiceScrobbleResponse>;

    /**
     * History Management Methods
     */

    /**
     * Add media to watch history manually
     */
    addToHistory(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null
    ): Promise<{ historyId?: number | string }>;

    /**
     * Remove item from watch history
     */
    removeFromHistory(historyId: number | string): Promise<void>;

    /**
     * Rating Methods
     */

    /**
     * Rate a movie
     */
    rateMovie(movieIds: ServiceMediaIds, rating: number): Promise<void>;

    /**
     * Rate a show
     */
    rateShow(showIds: ServiceMediaIds, rating: number): Promise<void>;

    /**
     * Rate a season
     */
    rateSeason(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        rating: number
    ): Promise<void>;

    /**
     * Rate an episode
     */
    rateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number,
        rating: number
    ): Promise<void>;

    /**
     * Unrating Methods
     */

    /**
     * Remove rating from a movie
     */
    unrateMovie(movieIds: ServiceMediaIds): Promise<void>;

    /**
     * Remove rating from a show
     */
    unrateShow(showIds: ServiceMediaIds): Promise<void>;

    /**
     * Remove rating from a season
     */
    unrateSeason(showIds: ServiceMediaIds, seasonNumber: number): Promise<void>;

    /**
     * Remove rating from an episode
     */
    unrateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number
    ): Promise<void>;

    /**
     * Comment Methods
     */

    /**
     * Get comments for media
     */
    getComments(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment[]>;

    /**
     * Post a new comment
     */
    postComment(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        comment: string,
        spoiler: boolean,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment>;

    /**
     * Update existing comment
     */
    updateComment(
        commentId: number | string,
        comment: string,
        spoiler: boolean
    ): Promise<ServiceComment>;

    /**
     * Delete a comment
     */
    deleteComment(commentId: number | string): Promise<void>;
}

/**
 * Configuration for a tracking service
 */
export interface ServiceConfig {
    serviceType: ServiceType;
    enabled: boolean;
    priority: number; // Lower numbers = higher priority
}

/**
 * Registry of all available tracking services
 */
export interface ServiceRegistry {
    /**
     * Get all registered services
     */
    getAllServices(): TrackerService[];

    /**
     * Get all enabled services ordered by priority
     */
    getEnabledServices(): TrackerService[];

    /**
     * Get a specific service by type
     */
    getService(serviceType: ServiceType): TrackerService | null;

    /**
     * Register a new service
     */
    registerService(service: TrackerService, config: ServiceConfig): void;

    /**
     * Update service configuration
     */
    updateServiceConfig(
        serviceType: ServiceType,
        config: Partial<ServiceConfig>
    ): void;

    /**
     * Get service configuration
     */
    getServiceConfig(serviceType: ServiceType): ServiceConfig | null;
}
</file>

<file path="src/types/serviceStatus.ts">
/**
 * Service status types for real-time status indicators
 */

import { ServiceType } from './serviceTypes';

/**
 * Real-time service activity states
 */
export type ServiceActivityState =
    | 'idle' // Service available but not doing anything
    | 'starting_scrobble' // Sending real-time scrobble start request (Trakt)
    | 'scrobbling' // Active real-time scrobble session (Trakt)
    | 'pausing_scrobble' // Sending real-time scrobble pause request (Trakt)
    | 'paused' // Scrobble is paused/waiting (better than 'ready')
    | 'stopping_scrobble' // Sending real-time scrobble stop request (Trakt)
    | 'tracking_progress' // Watching for completion threshold (AniList, MAL)
    | 'updating_progress' // Sending progress update request (AniList, MAL)
    | 'rating' // Sending rating request
    | 'commenting' // Sending comment request
    | 'error' // Service encountered an error
    | 'disabled'; // Service disabled by user preference

/**
 * Service status information for real-time display
 */
export interface ServiceStatus {
    serviceType: ServiceType;
    isAuthenticated: boolean;
    activityState: ServiceActivityState;
    lastActivity?: string; // Timestamp of last activity
    errorMessage?: string; // Error details if activityState is 'error'
    isEnabled: boolean; // Whether service is enabled for current context
}

/**
 * Multi-service status update
 */
export interface MultiServiceStatus {
    services: ServiceStatus[];
    timestamp: string;
}

/**
 * Service status update event
 */
export interface ServiceStatusUpdateEvent {
    action: 'serviceStatusUpdate';
    data: MultiServiceStatus;
}
</file>

<file path="src/types/serviceTypes.ts">
/**
 * Service-agnostic types for multi-service architecture
 *
 * These types abstract away service-specific data structures,
 * allowing different tracking services to work with common interfaces.
 */

/**
 * Represents a tracking service (Trakt, AniList, MyAnimeList, etc.)
 */
export type ServiceType = 'trakt' | 'anilist' | 'myanimelist';

/**
 * Generic comment structure that works across all services
 */
export interface ServiceComment {
    id: number | string;
    comment: string;
    spoiler: boolean;
    createdAt: string;
    updatedAt?: string;
    user: {
        username: string;
        name?: string;
    };
    // Service-specific data can be stored here
    serviceData?: Record<string, any>;
    serviceType: ServiceType;
}

/**
 * Generic progress info that works across all services
 */
export interface ServiceProgressInfo {
    aired: number;
    completed: number;
    lastWatchedAt?: string;
    lastEpisode?: {
        season: number;
        number: number;
        title?: string;
    };
    seasons?: Array<{
        number: number;
        aired: number;
        completed: number;
        episodes: Array<{
            number: number;
            completed: boolean;
            watchedAt?: string;
        }>;
    }>;
    // Service-specific data
    serviceData?: Record<string, any>;
    serviceType: ServiceType;
}

/**
 * Generic media identifiers that work across all services
 */
export interface ServiceMediaIds {
    // Common identifiers
    tmdb?: number;
    imdb?: string;
    tvdb?: number;

    // Service-specific identifiers
    trakt?: number;
    anilist?: number;
    myanimelist?: number;

    // Allow for future services
    [key: string]: number | string | undefined;
}

/**
 * Service-agnostic rating info
 */
export interface ServiceRatingInfo {
    userRating: number;
    ratedAt: string;
    serviceType: ServiceType;
}

/**
 * Service-agnostic media ratings collection
 */
export interface ServiceMediaRatings {
    show?: ServiceRatingInfo;
    season?: ServiceRatingInfo;
    episode?: ServiceRatingInfo;
}

/**
 * Service-agnostic scrobble response
 */
export interface ServiceScrobbleResponse {
    action: 'watched' | 'paused_incomplete';
    historyId?: number | string;
    serviceType: ServiceType;
}

/**
 * Service-agnostic history entry
 */
export interface ServiceHistoryEntry {
    id: number | string;
    watchedAt: string;
    serviceType: ServiceType;
}

/**
 * Rating scale configuration for different services
 */
export interface ServiceRatingScale {
    min: number;
    max: number;
    step: number;
    serviceType: ServiceType;
}

/**
 * Service-specific configuration and capabilities
 */
export interface ServiceCapabilities {
    serviceType: ServiceType;

    // What features this service supports
    supportsRealTimeScrobbling: boolean; // Real-time start/pause/stop during playback (Trakt)
    supportsProgressTracking: boolean; // Episode/movie completion tracking (AniList, MAL)
    supportsRatings: boolean;
    supportsComments: boolean;
    supportsHistory: boolean;
    supportsSearch: boolean;

    // Rating system
    ratingScale: ServiceRatingScale;

    // Authentication method
    authMethod: 'oauth' | 'api_key' | 'username_password';

    // Supported media types
    supportedMediaTypes: ('movie' | 'show')[];

    // API rate limits
    rateLimits?: {
        requestsPerMinute: number;
        requestsPerHour: number;
    };
}
</file>

<file path="src/utils/helpers/localRewatch.ts">
const REWATCH_STORAGE_KEY = 'tmsync_rewatch_progress';

export type LocalRewatchInfo = {
    lastWatched: { season: number; number: number; timestamp: number };

    nextExpected?: { season: number; number: number } | null;
};
export type LocalRewatchProgressStorage = {
    [traktShowId: number]: LocalRewatchInfo;
};

export async function getLocalRewatchInfo(
    showId: number
): Promise<LocalRewatchInfo | null> {
    try {
        const data = await chrome.storage.local.get(REWATCH_STORAGE_KEY);
        const allProgress: LocalRewatchProgressStorage =
            data[REWATCH_STORAGE_KEY] || {};
        return allProgress[showId] || null;
    } catch (error) {
        console.error('Error getting local rewatch info:', error);
        return null;
    }
}

export async function saveLocalRewatchInfo(
    showId: number,
    watchedSeason: number,
    watchedEpisode: number
): Promise<void> {
    try {
        const data = await chrome.storage.local.get(REWATCH_STORAGE_KEY);
        const allProgress: LocalRewatchProgressStorage =
            data[REWATCH_STORAGE_KEY] || {};

        const nextExpected: { season: number; number: number } | null = {
            season: watchedSeason,
            number: watchedEpisode + 1
        };

        allProgress[showId] = {
            lastWatched: {
                season: watchedSeason,
                number: watchedEpisode,
                timestamp: Date.now()
            },
            nextExpected: nextExpected
        };
        await chrome.storage.local.set({ [REWATCH_STORAGE_KEY]: allProgress });
        console.log(
            `Saved local rewatch info for ${showId}: Last S${watchedSeason}E${watchedEpisode}, Next S${nextExpected.season}E${nextExpected.number}`
        );
    } catch (error) {
        console.error('Error saving local rewatch info:', error);
    }
}
</file>

<file path="src/utils/confidenceHelper.ts">
import { MovieMediaInfo, ShowMediaInfo } from '../types/media';
import { isMovieMediaInfo, isShowMediaInfo } from './typeGuards';

export function getTitleSimilarity(
    queryTitle: string,
    resultTitle: string
): number {
    const q = queryTitle.toLowerCase().trim();
    const r = resultTitle.toLowerCase().trim();
    if (q === r) return 1.0;
    if (r.includes(q)) return 0.7;
    if (q.includes(r)) return 0.6;

    const queryWords = new Set(q.split(' '));
    const resultWords = r.split(' ');
    const overlap = resultWords.filter((word) => queryWords.has(word)).length;
    return (overlap / Math.max(queryWords.size, resultWords.length)) * 0.5;
}

export function calculateConfidence(
    result: MovieMediaInfo | ShowMediaInfo,
    queryTitle: string,
    queryYear: string | number | null
): number {
    let score = 0;
    let resultTitle = '';
    let resultYear = 0;
    if (isMovieMediaInfo(result)) {
        resultTitle = result.movie.title;
        resultYear = result.movie.year;
    } else if (isShowMediaInfo(result)) {
        resultTitle = result.show.title;
        resultYear = result.show.year;
    } else {
        console.warn(
            'calculateConfidence received unexpected media type:',
            result
        );
        return 0;
    }

    const titleSim = getTitleSimilarity(queryTitle, resultTitle);
    score += titleSim * 50;

    if (queryYear && resultYear && String(resultYear) === String(queryYear)) {
        score += 40;
    }

    score += Math.min(result.score / 100, 10);

    return Math.min(score, 100);
}
</file>

<file path="src/utils/typeGuards.ts">
import {
    MediaInfoResponse,
    MovieMediaInfo,
    ShowMediaInfo
} from '../types/media';

export function isMovieMediaInfo(
    media: MediaInfoResponse | null | undefined
): media is MovieMediaInfo {
    return (
        !!media && media.type === 'movie' && 'movie' in media && !!media.movie
    );
}

export function isShowMediaInfo(
    media: MediaInfoResponse | null | undefined
): media is ShowMediaInfo {
    return !!media && media.type === 'show' && 'show' in media && !!media.show;
}
</file>

<file path="src/test-services.ts">
/**
 * Test script to validate multi-service architecture
 */

import { initializeServices, getServices } from './services';

// Test the multi-service architecture
try {
    console.log('üöÄ Testing Multi-Service Architecture...\n');

    // Initialize services
    initializeServices();

    const { registry } = getServices();

    console.log('\nüìä Service Registry Validation:');
    console.log(
        '- Total services registered:',
        registry.getAllServices().length
    );
    console.log('- Enabled services:', registry.getEnabledServices().length);

    const primaryService = registry.getPrimaryService();
    if (primaryService) {
        const capabilities = primaryService.getCapabilities();
        console.log('\nüéØ Primary Service Details:');
        console.log('- Type:', capabilities.serviceType);
        console.log(
            '- Supports real-time scrobbling:',
            capabilities.supportsRealTimeScrobbling
        );
        console.log(
            '- Supports progress tracking:',
            capabilities.supportsProgressTracking
        );
        console.log('- Supports ratings:', capabilities.supportsRatings);
        console.log('- Supports comments:', capabilities.supportsComments);
        console.log(
            '- Rating scale:',
            `${capabilities.ratingScale.min}-${capabilities.ratingScale.max}`
        );
        console.log('- Auth method:', capabilities.authMethod);
        console.log(
            '- Media types:',
            capabilities.supportedMediaTypes.join(', ')
        );
    }

    console.log('\n‚úÖ Multi-service architecture validation successful!');
    console.log('‚úÖ TrackerService interface design proven');
    console.log('‚úÖ ServiceRegistry management working');
    console.log('‚úÖ Ready for TraktService interface implementation');
} catch (error) {
    console.error('‚ùå Multi-service architecture test failed:', error);
}
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "noImplicitAny": true,
        "strict": true,
        "target": "ES2020",
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "moduleResolution": "bundler",
        "module": "ESNext",
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "sourceMap": false,
        "outDir": "dist/js",
        "noEmitOnError": true,
        "jsx": "react-jsx",
        "typeRoots": ["node_modules/@types"],
        "resolveJsonModule": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "isolatedModules": true,
        "allowJs": true,
        "baseUrl": ".",
        "paths": {
            "@/*": ["src/*"]
        }
    },
    "include": [
        "src/**/*",
        "vitest.config.ts",
        "eslint.config.mjs"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "coverage"
    ]
}
</file>

<file path="src/background/serviceStatusManager.ts">
/**
 * Service Status Manager - Background Script
 *
 * Manages real-time service status and broadcasts updates to content scripts
 */

import { ServiceType } from '../types/serviceTypes';
import {
    ServiceStatus,
    ServiceActivityState,
    MultiServiceStatus
} from '../types/serviceStatus';
import { serviceRegistry } from '../services/ServiceRegistry';
import { isServiceEnabled } from '../utils/servicePreferences';
import { scrobbleState } from './state';

class ServiceStatusManager {
    private serviceStatuses: Map<ServiceType, ServiceStatus> = new Map();
    private listeners: Set<number> = new Set(); // Tab IDs listening for updates

    constructor() {
        // Don't initialize immediately - wait for services to be registered
        // We'll call this manually after services are initialized
        this.setupStorageListener();
    }

    /**
     * Listen for service preference changes and update statuses
     */
    private setupStorageListener(): void {
        chrome.storage.onChanged.addListener(async (changes, namespace) => {
            if (namespace === 'sync' && changes.servicePreferences) {
                // Service preferences changed, update all service statuses
                await this.updateServicePreferenceStatuses();
            }
        });
    }

    /**
     * Update all service statuses based on current preferences
     */
    private async updateServicePreferenceStatuses(): Promise<void> {
        const services = serviceRegistry.getAllServices();

        for (const service of services) {
            const serviceType = service.getCapabilities().serviceType;
            const userEnabled = await isServiceEnabled(serviceType);
            const currentStatus = this.serviceStatuses.get(serviceType);

            if (currentStatus) {
                const newActivityState = userEnabled
                    ? currentStatus.activityState === 'disabled'
                        ? this.determineCurrentActivityState(serviceType)
                        : currentStatus.activityState
                    : 'disabled';

                this.updateServiceActivity(serviceType, newActivityState);
            }
        }
    }

    /**
     * Determine what activity state a service should have based on current global state
     */
    private determineCurrentActivityState(
        serviceType: ServiceType
    ): ServiceActivityState {
        // Check if there's an active scrobble
        if (scrobbleState.current.status === 'started') {
            // Check if this service supports the current scrobble type
            const service = serviceRegistry.getServiceByType(serviceType);
            if (service?.getCapabilities().supportsRealTimeScrobbling) {
                return 'scrobbling';
            }
        } else if (scrobbleState.current.status === 'paused') {
            const service = serviceRegistry.getServiceByType(serviceType);
            if (service?.getCapabilities().supportsRealTimeScrobbling) {
                return 'paused';
            }
        }

        // Default to idle if no active state
        return 'idle';
    }

    /**
     * Initialize service statuses based on registered services
     */
    async initializeServiceStatuses(): Promise<void> {
        const services = serviceRegistry.getAllServices();

        for (const service of services) {
            const serviceType = service.getCapabilities().serviceType;
            const isAuthenticated = await service
                .isAuthenticated()
                .catch(() => false);

            this.serviceStatuses.set(serviceType, {
                serviceType,
                isAuthenticated,
                activityState: 'idle',
                isEnabled: true, // Default enabled, will be contextual later
                lastActivity: new Date().toISOString()
            });
        }

        this.broadcastStatusUpdate();
    }

    /**
     * Update service activity state
     */
    updateServiceActivity(
        serviceType: ServiceType,
        activityState: ServiceActivityState,
        errorMessage?: string
    ): void {
        const currentStatus = this.serviceStatuses.get(serviceType);
        if (!currentStatus) return;

        const updatedStatus: ServiceStatus = {
            ...currentStatus,
            activityState,
            errorMessage: activityState === 'error' ? errorMessage : undefined,
            lastActivity: new Date().toISOString()
        };

        this.serviceStatuses.set(serviceType, updatedStatus);
        this.broadcastStatusUpdate();
    }

    /**
     * Update service authentication status
     */
    async updateServiceAuthentication(serviceType: ServiceType): Promise<void> {
        const currentStatus = this.serviceStatuses.get(serviceType);
        if (!currentStatus) return;

        const service = serviceRegistry.getServiceByType(serviceType);
        if (!service) return;

        const isAuthenticated = await service
            .isAuthenticated()
            .catch(() => false);

        const updatedStatus: ServiceStatus = {
            ...currentStatus,
            isAuthenticated,
            lastActivity: new Date().toISOString()
        };

        this.serviceStatuses.set(serviceType, updatedStatus);
        this.broadcastStatusUpdate();
    }

    /**
     * Enable/disable service for current context
     */
    setServiceEnabled(serviceType: ServiceType, enabled: boolean): void {
        const currentStatus = this.serviceStatuses.get(serviceType);
        if (!currentStatus) return;

        const updatedStatus: ServiceStatus = {
            ...currentStatus,
            isEnabled: enabled,
            activityState: enabled ? 'idle' : 'disabled',
            lastActivity: new Date().toISOString()
        };

        this.serviceStatuses.set(serviceType, updatedStatus);
        this.broadcastStatusUpdate();
    }

    /**
     * Get current status for all services
     */
    getAllServiceStatuses(): ServiceStatus[] {
        return Array.from(this.serviceStatuses.values());
    }

    /**
     * Register a tab to receive status updates
     */
    addStatusListener(tabId: number): void {
        this.listeners.add(tabId);
    }

    /**
     * Unregister a tab from status updates
     */
    removeStatusListener(tabId: number): void {
        this.listeners.delete(tabId);
    }

    /**
     * Broadcast current status to all listening tabs
     */
    private broadcastStatusUpdate(): void {
        const statusUpdate: MultiServiceStatus = {
            services: this.getAllServiceStatuses(),
            timestamp: new Date().toISOString()
        };

        for (const tabId of this.listeners) {
            chrome.tabs
                .sendMessage(tabId, {
                    action: 'serviceStatusUpdate',
                    data: statusUpdate
                })
                .catch(() => {
                    // Tab probably closed, remove from listeners
                    this.listeners.delete(tabId);
                });
        }
    }

    /**
     * Refresh all service authentication statuses
     */
    async refreshAllServiceStatuses(): Promise<void> {
        const services = serviceRegistry.getAllServices();

        for (const service of services) {
            const serviceType = service.getCapabilities().serviceType;
            await this.updateServiceAuthentication(serviceType);
        }
    }
}

// Export singleton instance
export const serviceStatusManager = new ServiceStatusManager();
</file>

<file path="src/content-scripts/main/components/ScrobbleManager.tsx">
import React, { useEffect, useMemo } from 'react';
import { useMediaLifecycle } from '../../../hooks/useMediaLifecycle';
import { useScrobbling } from '../../../hooks/useScrobbling';
import { useServiceStatus } from '../../../hooks/useServiceStatus';
import { ScrobbleNotification } from './ScrobbleNotification';
import { ManualSearchPrompt } from './ManualSearchPrompt';
import { LoadingIndicator } from './LoadingIndicator';
import { StartWatchPrompt } from './StartWatchPrompt';
import { RewatchPrompt } from './RewatchPrompt';
import { CommentModal } from './CommentModal';
import { isShowMediaInfo } from '../../../utils/typeGuards';
import {
    clearHighlighting,
    setupEpisodeHighlighting
} from '../../../utils/highlighting';
import { ScrobbleNotificationMediaType } from '../../../types/scrobbling';

export const ScrobbleManager = () => {
    const {
        mediaInfo,
        episodeInfo,
        originalQuery,
        ratings,
        uiState,
        userConfirmedAction,
        isRewatchSession,
        siteConfig,
        highlightTarget,
        watchedHistoryEpisodes,
        confirmManualSelection,
        confirmStart,
        confirmRewatch,
        cancelManualSearch,
        handleRate,
        handleUnrate,
        refetch,
        isCommentModalOpen,
        isLoadingComments,
        commentModalType,
        comments,
        openCommentModal,
        closeCommentModal,
        postComment,
        updateComment,
        deleteComment
    } = useMediaLifecycle();

    const { serviceStatuses } = useServiceStatus();

    // Filter service statuses to only include those that support comments
    const commentServiceStatuses = useMemo(() => 
        serviceStatuses.filter(status => 
            status.serviceType === 'trakt' || status.serviceType === 'anilist'
        ),
        [serviceStatuses]
    );

    const { status, isProcessing, historyId, manualScrobble, undoScrobble } =
        useScrobbling(
            mediaInfo,
            episodeInfo,
            userConfirmedAction,
            isRewatchSession
        );

    useEffect(() => {
        if (!siteConfig || !siteConfig.highlighting) {
            if (siteConfig?.name) clearHighlighting(siteConfig.name, null);
            return;
        }
        setupEpisodeHighlighting(
            siteConfig,
            highlightTarget,
            watchedHistoryEpisodes
        );
        return () => {
            if (siteConfig?.name) clearHighlighting(siteConfig.name, null);
        };
    }, [siteConfig, highlightTarget, watchedHistoryEpisodes]);

    const notificationMediaInfo: ScrobbleNotificationMediaType | null =
        useMemo(() => {
            if (!mediaInfo) return null;
            return {
                ...mediaInfo,
                ...(isShowMediaInfo(mediaInfo) && episodeInfo
                    ? episodeInfo
                    : {})
            };
        }, [mediaInfo, episodeInfo]);

    const isEffectivelyScrobbled = !!historyId;

    const handleUndo = async () => {
        const success = await undoScrobble();
        if (success) refetch();
    };

    if (uiState === 'loading') {
        return <LoadingIndicator text="Finding media..." />;
    }

    if (uiState === 'needs_manual_confirmation' && originalQuery) {
        return (
            <ManualSearchPrompt
                originalQuery={originalQuery}
                onConfirmMedia={confirmManualSelection}
                onCancel={cancelManualSearch}
            />
        );
    }

    const showScrobbleUI =
        mediaInfo && (userConfirmedAction || isEffectivelyScrobbled);

    return (
        <>
            {uiState === 'prompt_start' && (
                <StartWatchPrompt onConfirm={confirmStart} />
            )}
            {uiState === 'prompt_rewatch' && (
                <RewatchPrompt onConfirm={confirmRewatch} />
            )}

            {showScrobbleUI && notificationMediaInfo && (
                <ScrobbleNotification
                    mediaInfo={notificationMediaInfo}
                    isEffectivelyScrobbled={isEffectivelyScrobbled}
                    traktHistoryId={historyId}
                    liveScrobbleStatus={status}
                    onManualScrobble={manualScrobble}
                    onUndoScrobble={handleUndo}
                    isProcessingAction={isProcessing}
                    ratings={ratings}
                    onRate={handleRate}
                    onUnrate={handleUnrate}
                    onOpenCommentModal={openCommentModal}
                />
            )}

            <CommentModal
                isOpen={isCommentModalOpen}
                onClose={closeCommentModal}
                isLoading={isLoadingComments}
                comments={comments}
                mediaInfo={mediaInfo}
                ratings={ratings}
                commentType={commentModalType}
                serviceStatuses={commentServiceStatuses}
                onPostComment={postComment}
                onUpdateComment={updateComment}
                onDeleteComment={deleteComment}
                onRate={handleRate}
            />
        </>
    );
};
</file>

<file path="src/hooks/useMultiServiceAuth.ts">
import { useMemo, useState, useEffect } from 'react';
import { useServiceAuth } from './useServiceAuth';
import { serviceRegistry } from '../services/ServiceRegistry';
import { ServiceType } from '../types/serviceTypes';

export interface ServiceAuthInfo {
    serviceType: ServiceType;
    isLoggedIn: boolean;
    username: string | null;
    isLoading: boolean;
    error: string | null;
    login: () => Promise<void>;
    logout: () => Promise<void>;
    checkAuthStatus: () => Promise<void>;
    clearError: () => void;
    capabilities: {
        supportsScrobbling: boolean;
        supportsRatings: boolean;
        supportsComments: boolean;
        supportedMediaTypes: ('movie' | 'show')[];
    };
}

interface UseMultiServiceAuthReturn {
    services: ServiceAuthInfo[];
    authenticatedServices: ServiceAuthInfo[];
    hasAnyAuthenticated: boolean;
    isAnyLoading: boolean;
    hasAnyErrors: boolean;
    isServicesInitialized: boolean;
    loginToAll: () => Promise<void>;
    logoutFromAll: () => Promise<void>;
    refreshAllStatus: () => Promise<void>;
    clearAllErrors: () => void;
    getServiceAuth: (serviceType: ServiceType) => ServiceAuthInfo | undefined;
}

/**
 * Hook for managing authentication across all registered tracking services
 *
 * @returns Aggregated auth state and bulk operations for all services
 */
export function useMultiServiceAuth(): UseMultiServiceAuthReturn {
    const [servicesInitialized, setServicesInitialized] = useState(false);
    const [allServices, setAllServices] = useState(
        serviceRegistry.getAllServices()
    );

    // Monitor service registry for changes
    useEffect(() => {
        const checkServices = () => {
            const currentServices = serviceRegistry.getAllServices();
            console.log(
                'useMultiServiceAuth: Checking services, found:',
                currentServices.length
            );

            if (currentServices.length > 0 && !servicesInitialized) {
                console.log(
                    'useMultiServiceAuth: Services initialized, updating state'
                );
                setAllServices(currentServices);
                setServicesInitialized(true);
            }
        };

        // Check immediately
        checkServices();

        // Set up a polling mechanism to check for service initialization
        const interval = setInterval(checkServices, 100);

        // Cleanup interval when services are found or component unmounts
        if (servicesInitialized) {
            clearInterval(interval);
        }

        return () => clearInterval(interval);
    }, [servicesInitialized]);

    // Always call hooks for the maximum possible number of services to avoid conditional hook calls
    // This ensures we don't violate the Rules of Hooks
    const traktAuth = useServiceAuth(
        allServices.find((s) => s.getCapabilities().serviceType === 'trakt') ||
            null
    );
    const anilistAuth = useServiceAuth(
        allServices.find(
            (s) => s.getCapabilities().serviceType === 'anilist'
        ) || null
    );

    // Create service auth info array from the individual hooks
    const serviceAuthHooks = useMemo(() => {
        const hooks = [];

        // Add Trakt if available
        const traktService = allServices.find(
            (s) => s.getCapabilities().serviceType === 'trakt'
        );
        if (traktService) {
            hooks.push({ service: traktService, auth: traktAuth });
        }

        // Add AniList if available
        const anilistService = allServices.find(
            (s) => s.getCapabilities().serviceType === 'anilist'
        );
        if (anilistService) {
            hooks.push({ service: anilistService, auth: anilistAuth });
        }

        return hooks;
    }, [allServices, traktAuth, anilistAuth]);

    // Transform to ServiceAuthInfo format
    const services: ServiceAuthInfo[] = useMemo(() => {
        return serviceAuthHooks.map(({ service, auth }) => {
            const capabilities = service.getCapabilities();
            return {
                serviceType: capabilities.serviceType,
                isLoggedIn: auth.isLoggedIn,
                username: auth.username,
                isLoading: auth.isLoading,
                error: auth.error,
                login: auth.login,
                logout: auth.logout,
                checkAuthStatus: auth.checkAuthStatus,
                clearError: auth.clearError,
                capabilities: {
                    supportsScrobbling:
                        capabilities.supportsRealTimeScrobbling ||
                        capabilities.supportsProgressTracking,
                    supportsRatings: capabilities.supportsRatings,
                    supportsComments: capabilities.supportsComments,
                    supportedMediaTypes: capabilities.supportedMediaTypes
                }
            };
        });
    }, [serviceAuthHooks]);

    // Computed properties
    const authenticatedServices = services.filter((s) => s.isLoggedIn);
    const hasAnyAuthenticated = authenticatedServices.length > 0;
    const isAnyLoading = services.some((s) => s.isLoading);
    const hasAnyErrors = services.some((s) => s.error !== null);

    // Bulk operations
    const loginToAll = async () => {
        await Promise.allSettled(services.map((service) => service.login()));
    };

    const logoutFromAll = async () => {
        await Promise.allSettled(
            authenticatedServices.map((service) => service.logout())
        );
    };

    const refreshAllStatus = async () => {
        await Promise.allSettled(
            services.map((service) => service.checkAuthStatus())
        );
    };

    const clearAllErrors = () => {
        services.forEach((service) => service.clearError());
    };

    const getServiceAuth = (serviceType: ServiceType) => {
        return services.find((s) => s.serviceType === serviceType);
    };

    return {
        services,
        authenticatedServices,
        hasAnyAuthenticated,
        isAnyLoading,
        hasAnyErrors,
        isServicesInitialized: servicesInitialized,
        loginToAll,
        logoutFromAll,
        refreshAllStatus,
        clearAllErrors,
        getServiceAuth
    };
}
</file>

<file path="src/hooks/useServiceAuth.ts">
import { useState, useEffect, useCallback } from 'react';
import { TrackerService } from '../types/services';
import { ServiceType } from '../types/serviceTypes';

interface ServiceAuthState {
    isLoggedIn: boolean;
    username: string | null;
    isLoading: boolean;
    error: string | null;
    serviceType: ServiceType;
}

interface UseServiceAuthReturn extends ServiceAuthState {
    login: () => Promise<void>;
    logout: () => Promise<void>;
    checkAuthStatus: () => Promise<void>;
    clearError: () => void;
}

/**
 * Generic hook for managing authentication state of any TrackerService
 *
 * @param service - The TrackerService instance to manage auth for
 * @returns Authentication state and methods for the service
 */
export function useServiceAuth(
    service: TrackerService | null
): UseServiceAuthReturn {
    const serviceType = service?.getCapabilities().serviceType || 'trakt';

    const [state, setState] = useState<ServiceAuthState>({
        isLoggedIn: false,
        username: null,
        isLoading: true,
        error: null,
        serviceType
    });

    const updateState = useCallback((updates: Partial<ServiceAuthState>) => {
        setState((prev) => ({ ...prev, ...updates }));
    }, []);

    const clearError = useCallback(() => {
        updateState({ error: null });
    }, [updateState]);

    const checkAuthStatus = useCallback(async () => {
        if (!service) {
            updateState({
                isLoggedIn: false,
                username: null,
                isLoading: false,
                error: null
            });
            return;
        }

        updateState({ isLoading: true, error: null });

        try {
            const isAuth = await service.isAuthenticated();

            if (isAuth) {
                try {
                    const username = await service.getUsername();
                    updateState({
                        isLoggedIn: true,
                        username,
                        isLoading: false
                    });
                } catch (usernameError) {
                    // Authenticated but can't get username - still consider logged in
                    console.warn(
                        `${serviceType}: Could not fetch username:`,
                        usernameError
                    );
                    updateState({
                        isLoggedIn: true,
                        username: null,
                        isLoading: false
                    });
                }
            } else {
                updateState({
                    isLoggedIn: false,
                    username: null,
                    isLoading: false
                });
            }

            // Notify service status manager of authentication change
            chrome.runtime
                .sendMessage({
                    action: 'updateServiceAuthentication',
                    params: { serviceType }
                })
                .catch(() => {
                    // Ignore errors if background script isn't ready
                });
        } catch (error) {
            console.error(`${serviceType}: Auth status check failed:`, error);
            updateState({
                isLoggedIn: false,
                username: null,
                isLoading: false,
                error:
                    error instanceof Error
                        ? error.message
                        : 'Authentication check failed'
            });
        }
    }, [service, serviceType, updateState]);

    const login = useCallback(async () => {
        if (!service) {
            updateState({
                error: 'Service not available',
                isLoading: false
            });
            return;
        }

        updateState({ isLoading: true, error: null });

        try {
            await service.login();
            // Check auth status after successful login to update state
            await checkAuthStatus();
        } catch (error) {
            console.error(`${serviceType}: Login failed:`, error);
            updateState({
                isLoading: false,
                error: error instanceof Error ? error.message : 'Login failed'
            });
        }
    }, [service, serviceType, checkAuthStatus, updateState]);

    const logout = useCallback(async () => {
        if (!service) {
            updateState({
                error: 'Service not available',
                isLoading: false
            });
            return;
        }

        updateState({ isLoading: true, error: null });

        try {
            await service.logout();
            updateState({
                isLoggedIn: false,
                username: null,
                isLoading: false
            });
        } catch (error) {
            console.error(`${serviceType}: Logout failed:`, error);
            updateState({
                isLoading: false,
                error: error instanceof Error ? error.message : 'Logout failed'
            });
        }
    }, [service, serviceType, updateState]);

    // Check auth status on mount
    useEffect(() => {
        checkAuthStatus();
    }, [checkAuthStatus]);

    return {
        ...state,
        login,
        logout,
        checkAuthStatus,
        clearError
    };
}
</file>

<file path="src/utils/siteConfigs/freek.ts">
import { createSiteConfig } from './baseConfig';

export const freekConfig = createSiteConfig({
    name: 'Freek',
    selectorType: 'xpath',
    urlPatterns: {
        movie: /\/watch\/movie\/.+/,
        show: /\/watch\/tv\/.+/
    },
    selectors: {
        movie: {
            title: '//*[@id="root"]/div/div[2]/div/div[5]/div/div[2]/div/div[2]/div/span',
            year: '//*[@id="root"]/div/div[2]/div/div[5]/div/div[2]/div/div[1]/div[2]/div[3]/span[2]'
        },
        show: {
            title: '//*[@id="right-header"]/div[1]',
            year: '//*[@id="root"]/div/div[2]/div/div[5]/div/div[2]/div[3]/div[1]/div[2]/div[3]/span[2]'
        }
    }
});

// Override specific methods as needed
freekConfig.getUrlIdentifier = function (url: string): string {
    const urlObj = new URL(url);
    const urlPath = urlObj.pathname.split('/');

    if (urlObj.hostname === 'freek.to' && this.isWatchPage(url)) {
        return (
            urlObj.hostname +
            '/' +
            urlPath[1] +
            '/' +
            urlPath[2] +
            '/' +
            urlPath[3]
        );
    }
    return '';
};

freekConfig.getSeasonEpisodeObj = function (
    url: string
): { season: number; number: number } | null {
    if (!this.isShowPage(url)) return null;

    const urlObj = new URL(url);
    const urlQueryParams = urlObj.searchParams;

    if (urlQueryParams.has('season') && urlQueryParams.has('ep')) {
        return {
            season: Number(urlQueryParams.get('season')),
            number: Number(urlQueryParams.get('ep'))
        };
    } else if (urlQueryParams.has('ep')) {
        return {
            season: 1,
            number: Number(urlQueryParams.get('ep'))
        };
    } else if (urlQueryParams.has('season')) {
        return {
            season: Number(urlQueryParams.get('season')),
            number: 1
        };
    }
    return { season: 1, number: 1 };
};
</file>

<file path="src/utils/siteConfigs/hydra.ts">
import { waitForElm } from '../content';
import { createSiteConfig } from './baseConfig';

export const hydraConfig = createSiteConfig({
    name: 'HydraHD',
    selectorType: 'css',
    urlPatterns: {
        movie: /\/movie\/.+/,
        show: /\/watchseries\/.+-online-free\/season\/.*\/episode\/.*/
    },
    selectors: {
        movie: {
            title: '#wdthcontrol > div.btn-group.btns-under-jumbo.center-block.col-lg-12 > div > div > div > div.row.diz-title > div.ploting > h1',
            year: '#wdthcontrol > div.btn-group.btns-under-jumbo.center-block.col-lg-12 > div > div > div > div.row.diz-title > span:nth-child(2) > span:nth-child(5)'
        },
        show: {
            title: '#wdthcontrol > div.btn-group.btns-under-jumbo.center-block.col-lg-12 > div > div:nth-child(3) > div > div.row.diz-title > div.ploting > h1',
            year: '#wdthcontrol > div.btn-group.btns-under-jumbo.center-block.col-lg-12 > div > div:nth-child(3) > div > div.row.diz-title > span:nth-child(2) > span:nth-child(5)'
        }
    }
});

hydraConfig.getTitle = async function (url: string) {
    if (!this.isWatchPage(url)) return null;

    let selector = '';

    if (this.isMoviePage(url)) {
        selector = this.selectors.movie.title;
    } else if (this.isShowPage(url)) {
        selector = this.selectors.show.title;
    }

    if (!selector) return null;

    try {
        const element = await waitForElm(
            selector,
            this.selectorType === 'xpath'
        );

        if (this.isShowPage(url)) {
            return element?.textContent?.split('-')[0].trim() || null;
        }

        return element?.textContent?.trim() || null;
    } catch (error) {
        console.error(`Error getting title for ${url}:`, error);
        return null;
    }
};

// Override specific methods as needed
hydraConfig.getUrlIdentifier = function (url: string): string {
    const urlObj = new URL(url);
    const urlPath = urlObj.pathname.split('/');

    if (this.isWatchPage(url)) {
        return urlObj.hostname + '/' + urlPath[1] + '/' + urlPath[2];
    }
    return '';
};

hydraConfig.getSeasonEpisodeObj = function (
    url: string
): { season: number; number: number } | null {
    if (!this.isShowPage(url)) return null;

    const urlObj = new URL(url);
    const urlPath = urlObj.pathname.split('/');

    if (urlPath.length === 3) {
        return { season: 1, number: 1 };
    } else {
        return {
            season: Number(urlPath[4]),
            number: Number(urlPath[6])
        };
    }
};
</file>

<file path="src/utils/api.ts">
import { clientId, clientSecret, traktHeaders } from './config';

let isRefreshing = false;

let refreshSubscribers: ((token: string) => void)[] = [];

function subscribeTokenRefresh(cb: (token: string) => void) {
    refreshSubscribers.push(cb);
}

function onRefreshed(token: string) {
    refreshSubscribers.forEach((cb) => cb(token));

    refreshSubscribers = [];
}

async function refreshToken(): Promise<string | null> {
    console.log('Attempting token refresh...');
    isRefreshing = true;

    const tokenData = await chrome.storage.local.get(['traktRefreshToken']);
    const storedRefreshToken = tokenData.traktRefreshToken;

    if (!storedRefreshToken) {
        console.error('No refresh token found. Cannot refresh.');
        isRefreshing = false;

        await chrome.storage.local.remove([
            'traktAccessToken',
            'traktRefreshToken',
            'traktTokenExpiresAt'
        ]);
        return null;
    }

    let redirectUri: string | undefined;
    try {
        redirectUri = chrome.identity.getRedirectURL();
        if (!redirectUri)
            throw new Error('Could not get redirect URL for refresh.');
    } catch (error) {
        console.error('Error getting redirect URL during refresh:', error);
        isRefreshing = false;
        return null;
    }

    try {
        const response = await fetch('https://api.trakt.tv/oauth/token', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                refresh_token: storedRefreshToken,
                client_id: clientId,
                client_secret: clientSecret,
                redirect_uri: redirectUri,
                grant_type: 'refresh_token'
            })
        });

        const data = await response.json();

        if (!response.ok) {
            console.error('Token refresh failed:', response.status, data);

            await chrome.storage.local.remove([
                'traktAccessToken',
                'traktRefreshToken',
                'traktTokenExpiresAt'
            ]);
            isRefreshing = false;
            onRefreshed('');
            return null;
        }

        console.log('Token refresh successful:', data);
        const newExpiresAt = Date.now() + data.expires_in * 1000;

        await chrome.storage.local.set({
            traktAccessToken: data.access_token,
            traktRefreshToken: data.refresh_token,
            traktTokenExpiresAt: newExpiresAt
        });

        isRefreshing = false;
        onRefreshed(data.access_token);
        return data.access_token;
    } catch (error) {
        console.error('Error during token refresh fetch:', error);
        isRefreshing = false;
        onRefreshed('');
        return null;
    }
}

export const callApi = async <T = any>(
    url: string,
    method: RequestInit['method'] = 'GET',
    body: BodyInit | object | null = null,
    isAuth: boolean = true
): Promise<T> => {
    let accessToken: string | null = null;

    if (isAuth) {
        const tokenData = await chrome.storage.local.get([
            'traktAccessToken',
            'traktTokenExpiresAt'
        ]);
        const expiresAt = tokenData.traktTokenExpiresAt || 0;
        const storedAccessToken = tokenData.traktAccessToken;

        if (!storedAccessToken || Date.now() >= expiresAt - 60000) {
            console.log('Access token missing or expired/expiring soon.');

            if (isRefreshing) {
                console.log('Waiting for ongoing token refresh...');
                return new Promise((resolve) => {
                    subscribeTokenRefresh(async (newToken) => {
                        if (!newToken) {
                            console.error('Refresh failed while waiting.');

                            throw new Error(
                                'Authentication failed during refresh.'
                            );
                        }

                        resolve(
                            callApiInternal(url, method, body, isAuth, newToken)
                        );
                    });
                });
            } else {
                accessToken = await refreshToken();
                if (!accessToken) {
                    console.error(
                        'Failed to refresh token. User needs to re-authenticate.'
                    );

                    await chrome.storage.local.remove([
                        'traktAccessToken',
                        'traktRefreshToken',
                        'traktTokenExpiresAt'
                    ]);
                    throw new Error(
                        'Authentication required. Please login via the extension popup.'
                    );
                }
            }
        } else {
            accessToken = storedAccessToken;
        }
    }

    return callApiInternal<T>(url, method, body, isAuth, accessToken);
};

async function callApiInternal<T = any>(
    url: string,
    method: RequestInit['method'],
    body: BodyInit | object | null,
    isAuth: boolean,
    token: string | null
): Promise<T> {
    const headers: HeadersInit = { ...traktHeaders };
    if (isAuth && token) {
        headers['Authorization'] = `Bearer ${token}`;
    }

    if (body && method !== 'GET' && method !== 'HEAD') {
        headers['Content-Type'] = 'application/json';
    } else {
        delete headers['Content-Type'];
    }

    const reqBody =
        body &&
        typeof body === 'object' &&
        method !== 'GET' &&
        method !== 'HEAD'
            ? JSON.stringify(body)
            : (body as BodyInit | null);

    try {
        const response = await fetch(url, {
            method,
            headers,
            body: reqBody
        });

        if (!response.ok) {
            if (response.status === 401 && isAuth) {
                console.warn(
                    'Received 401 Unauthorized even after token check/refresh attempt.'
                );

                await chrome.storage.local.remove([
                    'traktAccessToken',
                    'traktRefreshToken',
                    'traktTokenExpiresAt'
                ]);
                throw new Error(
                    `Authentication failed (${response.status}). Please try logging in again.`
                );
            }

            const errorData = await response.text();
            console.error(
                `API call failed: ${response.status} ${response.statusText}`,
                errorData
            );
            throw new Error(
                `API Error: ${response.status} ${response.statusText}`
            );
        }

        const contentType = response.headers.get('content-type');
        if (contentType && contentType.indexOf('application/json') !== -1) {
            const json = await response.json();
            return json as T;
        } else if (response.status === 204) {
            return null as unknown as T;
        } else {
            const text = await response.text();

            throw new Error(`Unexpected response content type: ${contentType}`);
        }
    } catch (error) {
        console.error(
            `Network or fetch error during API call to ${url}:`,
            error
        );

        throw error;
    }
}
</file>

<file path="src/utils/content.ts">
function getElementByXpath(path: string): Element | null {
    const node = document.evaluate(
        path,
        document,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null
    ).singleNodeValue;
    if (node && node.nodeType === Node.ELEMENT_NODE) {
        return node as Element;
    } else {
        return null;
    }
}

export function waitForElm(
    selector: string,
    isXPath: boolean = false,
    checkInterval: number = 100,
    maxWaitTime: number = 5000
): Promise<Element> {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();

        const checkForElement = () => {
            if (Date.now() - startTime > maxWaitTime) {
                clearInterval(intervalId);
                reject(
                    new Error(
                        `Element ${selector} not found within ${maxWaitTime}ms`
                    )
                );
                return;
            }

            try {
                let element = null;
                if (isXPath) {
                    element = getElementByXpath(selector);
                } else {
                    element = document.querySelector(selector);
                }

                if (element) {
                    clearInterval(intervalId);
                    resolve(element);
                }
            } catch (error) {
                clearInterval(intervalId);
                reject(error);
            }
        };

        const intervalId = setInterval(checkForElement, checkInterval);

        checkForElement();
    });
}
</file>

<file path="README.md">
# TMSync

[![Made with TypeScript](https://img.shields.io/badge/Made%20with-TypeScript-007ACC.svg)](https://www.typescriptlang.org/)
[![Built with React](https://img.shields.io/badge/Built%20with-React-61DAFB.svg)](https://reactjs.org/)
[![Styled with Tailwind CSS](https://img.shields.io/badge/Styled%20with-Tailwind%20CSS-38B2AC.svg)](https://tailwindcss.com/)

TMSync is a browser extension designed to seamlessly integrate various streaming websites with your Trakt.tv account. It automates watch history tracking (scrobbling), provides quick access to watch media from Trakt, and enhances the viewing experience with episode highlighting and a built-in commenting/rating system.

## ‚ú® Core Features

-   **Trakt.tv Authentication:** Securely connect to your Trakt.tv account via OAuth2.
-   **Automatic Scrobbling:** Automatically detects when you're watching a movie or TV show and updates your Trakt history in real-time (start, pause, and stop events).
-   **Intelligent Media Matching:** Uses a combination of TMDB ID lookups and a confidence-based text search to accurately identify the media you are watching.
-   **Manual Control:**
    -   **Manual Search:** If automatic matching fails, a prompt allows you to search Trakt's database and confirm the correct media.
    -   **Undo Scrobble:** Accidentally scrobbled something? Undo it directly from the UI.
-   **Episode Highlighting:** On supported sites, highlights the last watched episode and visually distinguishes watched episodes, making it easy to see where you left off.
-   **Rewatch Support:** Intelligently prompts to track a view as a "rewatch" if the item is already in your history.
-   **In-Page UI:**
    -   **Rating System:** Rate movies, shows, seasons, and episodes directly from the page you're on.
    -   **Comment/Review Modal:** Write and manage your Trakt comments and reviews without leaving the streaming site.
-   **Trakt.tv Quick Links:** Injects convenient "Watch on..." links directly into Trakt.tv pages, allowing you to jump straight to your favorite streaming sites.

## üì∫ Supported Sites

-   hexa.watch
-   xprime.tv
-   cineby.app (unmaintained)
-   freek.to (unmaintained)
-   hydrahd.me / hydrahd.ac (unmaintained)

## üõ†Ô∏è Tech Stack

-   **Framework:** React 19
-   **Language:** TypeScript
-   **Styling:** Tailwind CSS v4 (using `@theme` for theming)
-   **Bundler:** Webpack
-   **Package Manager:** pnpm
-   **Linting/Formatting:** ESLint & Prettier
-   **Key Architectural Patterns:**
    -   Stateful logic is encapsulated in **Custom Hooks** (`useMediaLifecycle`, `useScrobbling`, `useTraktAuth`).
    -   The background script uses a modular **Handler/Dispatcher Pattern** for message routing.

## üöÄ Getting Started

Follow these instructions to get a local development environment running.

### Prerequisites

-   **Node.js:** This project uses a specific version of Node.js. It's recommended to use a version manager like `nvm`.
    ```bash
    nvm install
    nvm use
    ```
-   **pnpm:** This project uses `pnpm` as its package manager.
    ```bash
    npm install -g pnpm
    ```

### Installation & Setup

1.  **Clone the repository:**

    ```bash
    git clone <your-repository-url>
    cd tmsync
    ```

2.  **Install dependencies:**

    ```bash
    pnpm install
    ```

3.  **Configure Environment Variables:**
    You need to provide your Trakt.tv API credentials.
    -   Copy the example environment file:
        ```bash
        cp .env.example .env
        ```
    -   Edit the `.env` file and fill in your Trakt Client ID and Secret. You can get these by creating a new API App on the [Trakt.tv website](https://trakt.tv/oauth/applications/new).
        ```.env
        TRAKT_CLIENT_ID=your_trakt_client_id
        TRAKT_CLIENT_SECRET=your_trakt_client_secret
        ```

### Development

To run the extension in development mode with live reloading:

```bash
pnpm dev
```

This will watch for file changes and rebuild the extension into the `dist/` directory automatically.

### Production Build

To create an optimized production build:

```bash
pnpm build
```

This will generate the final, minified extension files in the `dist/` directory.

## üì¶ Loading the Extension in Your Browser

1.  Navigate to your browser's extension management page:
    -   **Chrome:** `chrome://extensions`
    -   **Firefox:** `about:debugging#/runtime/this-firefox`
2.  Enable "Developer mode" (usually a toggle in the top-right corner).
3.  Click "Load unpacked" (Chrome) or "Load Temporary Add-on..." (Firefox).
4.  Select the `dist` folder from this project's directory.
5.  The TMSync extension should now be installed and active.

## üìÇ Project Structure

The project is organized by feature/entry point to improve code co-location and maintainability.

```
/
‚îú‚îÄ‚îÄ public/                 # Static assets (manifest.json, html shells, icons)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ background/         # Logic for the extension's service worker
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/       # Modular logic for each background message action
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts        # Main background entry point and message dispatcher
‚îÇ   ‚îú‚îÄ‚îÄ content-scripts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/           # Injected on streaming sites
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/ # React components for the main content script UI
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx   # Entry point for the main content script
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trakt/          # Injected on trakt.tv
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.tsx   # Entry point for the Trakt content script
‚îÇ   ‚îú‚îÄ‚îÄ hooks/              # Shared, reusable React hooks
‚îÇ   ‚îú‚îÄ‚îÄ options/            # The React app for the options page
‚îÇ   ‚îú‚îÄ‚îÄ popup/              # The React app for the browser action popup
‚îÇ   ‚îú‚îÄ‚îÄ styles/             # Global styles and Tailwind configuration
‚îÇ   ‚îú‚îÄ‚îÄ types/              # Shared TypeScript type definitions
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Shared utilities (API helpers, site configs, etc.)
‚îî‚îÄ‚îÄ webpack/                # Webpack configuration files
```

## üìù Architectural Notes

### UI State Management (Custom Hooks)

To avoid "God Components", complex stateful logic is extracted into custom hooks. This keeps components lean and focused on rendering, while the hooks manage the underlying complexity.

-   **`useMediaLifecycle`**: The "controller" hook for the main content script. It's responsible for identifying media on the page, fetching its data from Trakt, and managing the high-level UI state (e.g., showing a "start" vs. "rewatch" prompt).
-   **`useScrobbling`**: A focused hook that manages only the video player interaction and the scrobbling state machine (idle, started, paused).
-   **`useTraktAuth`**: Encapsulates all logic for OAuth authentication, providing a clean interface to log in, log out, and check auth status.

### Background Script (Handler Pattern)

The background script's `onMessage` listener avoids becoming a massive `if/else` block by using a handler pattern. The main `index.ts` file acts as a simple dispatcher that maps message actions to dedicated handler functions located in the `src/background/handlers/` directory. This makes the core logic highly modular, testable, and easy to extend.

### Event Handling and Cross-Extension Conflicts

A significant challenge in this project is preventing keyboard events within the UI (e.g., the Comment Modal) from triggering shortcuts in other installed extensions (like "Video Speed Controller").

The root cause is **Shadow DOM Event Retargeting**. Because our UI is rendered in a Shadow DOM for style isolation, events originating from it have their `target` retargeted to the Shadow Host element when they cross into the main document. This breaks the logic of other extensions that try to inspect the event's origin, causing them to misfire.

The current solution involves a global "guard" listener implemented in `src/content-scripts/main/index.tsx`:

-   It attaches a `keydown` listener to `window` with `{ capture: true }` to run as early as possible.
-   It uses `event.composedPath()` to identify the event's true origin, even from within the Shadow DOM.
-   If the event comes from our UI, `event.stopImmediatePropagation()` is called to prevent any other listeners on the page from receiving it.

**Caveat:** This solution relies on a **race condition**. It works only if our content script loads and attaches its listener before the conflicting extension's script does. A more robust (but complex) solution would involve sandboxing the UI in an `<iframe>`.
</file>

<file path="src/content-scripts/main/components/CommentModal.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { isShowMediaInfo, isMovieMediaInfo } from '../../../utils/typeGuards';
import { ServiceComment } from '../../../types/serviceTypes';
import {
    CommentableType,
    MediaInfoResponse
} from '../../../types/media';
import { ServiceMediaRatings } from '../../../types/serviceTypes';
import { ServiceStatus } from '../../../types/serviceStatus';
import { ServiceType } from '../../../types/serviceTypes';

const ModalHalfStar: React.FC<{
    rating: number;
    currentValue: number;
    onLeftClick: () => void;
    onRightClick: () => void;
    onLeftHover: () => void;
    onRightHover: () => void;
    onMouseLeave: () => void;
    readOnly?: boolean;
}> = ({
    rating,
    currentValue,
    onLeftClick,
    onRightClick,
    onLeftHover,
    onRightHover,
    onMouseLeave,
    readOnly
}) => {
    const leftHalf = currentValue >= rating - 0.5;
    const rightHalf = currentValue >= rating;

    return (
        <div
            className="relative w-5 h-5 cursor-pointer"
            onMouseLeave={readOnly ? undefined : onMouseLeave}
        >
            <svg
                className="absolute inset-0 w-5 h-5 text-(--color-star-empty)"
                fill="currentColor"
                viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg"
            >
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>

            {/* Left half overlay */}
            {leftHalf && (
                <svg
                    className="absolute inset-0 w-5 h-5 text-(--color-star-filled)"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                    style={{ clipPath: 'inset(0 50% 0 0)' }}
                >
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                </svg>
            )}

            {/* Right half overlay */}
            {rightHalf && (
                <svg
                    className="absolute inset-0 w-5 h-5 text-(--color-star-filled)"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                    style={{ clipPath: 'inset(0 0 0 50%)' }}
                >
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                </svg>
            )}

            {/* Invisible click areas */}
            {!readOnly && (
                <>
                    <div
                        className="absolute inset-0 w-1/2 h-full cursor-pointer"
                        onClick={onLeftClick}
                        onMouseEnter={onLeftHover}
                    />
                    <div
                        className="absolute inset-y-0 right-0 w-1/2 h-full cursor-pointer"
                        onClick={onRightClick}
                        onMouseEnter={onRightHover}
                    />
                </>
            )}
        </div>
    );
};

const ModalStarRating: React.FC<{
    label: string;
    currentRating: number | null;
    onRate: (r: number) => void;
    isSubmitting: boolean;
}> = ({ label, currentRating, onRate, isSubmitting }) => {
    const [hover, setHover] = useState(0);

    const displayRating = hover || currentRating || 0;
    const currentHasDecimal =
        currentRating !== null && currentRating !== Math.round(currentRating);

    return (
        <div className="mt-2">
            <p className="text-xs text-(--color-text-secondary)">{label}</p>
            <div
                className="flex items-center space-x-1"
                onMouseLeave={() => setHover(0)}
            >
                {[...Array(10)].map((_, i) => {
                    const starNumber = i + 1;
                    return (
                        <ModalHalfStar
                            key={starNumber}
                            rating={starNumber}
                            currentValue={displayRating}
                            onLeftClick={() => onRate(starNumber - 0.5)}
                            onRightClick={() => onRate(starNumber)}
                            onLeftHover={() => setHover(starNumber - 0.5)}
                            onRightHover={() => setHover(starNumber)}
                            onMouseLeave={() => {}}
                            readOnly={isSubmitting}
                        />
                    );
                })}
            </div>

            {/* Rating display and service info */}
            <div className="flex items-center justify-center mt-2 space-x-2">
                {currentRating && (
                    <span className="text-xs text-(--color-text-secondary)">
                        Current: {currentRating}
                    </span>
                )}
            </div>

            {currentHasDecimal && (
                <div className="mt-1 text-center text-xs text-(--color-text-secondary)">
                    AniList: {currentRating} ‚Ä¢ Trakt:{' '}
                    {Math.round(currentRating)}
                </div>
            )}
        </div>
    );
};

const CommentServiceBadge: React.FC<{
    serviceType: ServiceType;
    isAuthenticated: boolean;
    isEnabled: boolean;
}> = ({ serviceType, isAuthenticated, isEnabled }) => {
    const getServiceName = (type: ServiceType): string => {
        switch (type) {
            case 'trakt':
                return 'Trakt';
            case 'anilist':
                return 'AniList';
            case 'myanimelist':
                return 'MAL';
            default:
                return String(type).charAt(0).toUpperCase() + String(type).slice(1);
        }
    };

    const getStatusIcon = (): string => {
        if (!isEnabled) return '‚ö´'; // Disabled
        if (!isAuthenticated) return '‚ö™'; // Not authenticated
        return 'üü¢'; // Ready for comments
    };

    const getStatusText = (): string => {
        if (!isEnabled) return 'Disabled';
        if (!isAuthenticated) return 'Not logged in';
        return 'Ready';
    };

    const serviceName = getServiceName(serviceType);
    const icon = getStatusIcon();
    const statusText = getStatusText();

    return (
        <div className="flex items-center gap-1 text-xs">
            <span>{icon}</span>
            <span className="font-medium">{serviceName}:</span>
            <span className="text-(--color-text-secondary)">{statusText}</span>
        </div>
    );
};

interface CommentModalProps {
    isOpen: boolean;
    onClose: () => void;
    isLoading: boolean;
    comments: ServiceComment[];
    mediaInfo: MediaInfoResponse | null;
    ratings: ServiceMediaRatings | null;
    commentType: CommentableType | null;
    serviceStatuses?: ServiceStatus[]; // Services that support comments
    onPostComment: (comment: string, spoiler: boolean) => Promise<any>;
    onUpdateComment: (
        commentId: number | string,
        comment: string,
        spoiler: boolean
    ) => Promise<any>;
    onDeleteComment: (commentId: number | string) => Promise<any>;
    onRate: (type: CommentableType, rating: number) => void;
}

export const CommentModal: React.FC<CommentModalProps> = ({
    isOpen,
    onClose,
    isLoading,
    comments,
    mediaInfo,
    ratings,
    commentType,
    serviceStatuses,
    onPostComment,
    onUpdateComment,
    onDeleteComment,
    onRate
}) => {
    const [selectedCommentId, setSelectedCommentId] = useState<
        number | string | 'new'
    >('new');
    const [editorText, setEditorText] = useState('');
    const [isSpoiler, setIsSpoiler] = useState(false);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const textareaRef = useRef<HTMLTextAreaElement>(null);
    const [validationError, setValidationError] = useState<string | null>(null);

    // Helper functions
    const hasAniListService = serviceStatuses?.some(s => s.serviceType === 'anilist' && s.isAuthenticated && s.isEnabled) ?? false;
    const hasTraktService = serviceStatuses?.some(s => s.serviceType === 'trakt' && s.isAuthenticated && s.isEnabled) ?? false;
    const anilistNote = comments.find(c => c.serviceType === 'anilist');
    const hasAniListNote = !!anilistNote;

    useEffect(() => {
        if (editorText) {
            setValidationError(null);
        }
    }, [editorText]);

    useEffect(() => {
        if (isOpen) {
            if (comments.length > 0) {
                // If AniList note exists, prioritize it (since there's only one)
                const commentToSelect = anilistNote || comments.sort(
                    (a, b) =>
                        new Date(b.createdAt).getTime() -
                        new Date(a.createdAt).getTime()
                )[0];
                setSelectedCommentId(commentToSelect.id);
                setEditorText(commentToSelect.comment);
                setIsSpoiler(commentToSelect.spoiler);
            } else {
                setSelectedCommentId('new');
                setEditorText('');
                setIsSpoiler(false);
            }
        }
    }, [isOpen, comments, anilistNote]);

    const handleSelectComment = (comment: ServiceComment) => {
        setSelectedCommentId(comment.id);
        setEditorText(comment.comment);
        setIsSpoiler(comment.spoiler);
        textareaRef.current?.focus();
    };

    const handleNewComment = () => {
        setSelectedCommentId('new');
        setEditorText('');
        setIsSpoiler(false);
        textareaRef.current?.focus();
    };

    const handleSave = async () => {
        setValidationError(null);

        // Check if text is empty
        if (!editorText.trim()) {
            setValidationError('Please enter some text.');
            return;
        }

        // Only require 5 words if Trakt is included (Trakt requirement)
        const wordCount = editorText.trim().split(/\s+/).length;
        
        if (hasTraktService && wordCount < 5) {
            setValidationError('Trakt requires at least 5 words for comments.');
            return;
        }

        if (isSubmitting) return;
        setIsSubmitting(true);

        let response;
        if (selectedCommentId === 'new') {
            response = await onPostComment(editorText, isSpoiler);
        } else {
            response = await onUpdateComment(
                selectedCommentId,
                editorText,
                isSpoiler
            );
        }

        if (!response.success && response.error) {
            if (response.error.includes('422')) {
                setValidationError(
                    'Comment must be at least 5 words (server validation).'
                );
            } else {
                setValidationError(`Error: ${response.error}`);
            }
        }

        setIsSubmitting(false);
    };

    const handleDelete = async (commentId: number | string) => {
        if (window.confirm('Are you sure you want to delete this comment?')) {
            setIsSubmitting(true);
            await onDeleteComment(commentId);
            setIsSubmitting(false);

            if (selectedCommentId === commentId) {
                handleNewComment();
            }
        }
    };

    const getTitle = () => {
        if (!mediaInfo) return 'Comments';
        if (isMovieMediaInfo(mediaInfo)) return mediaInfo.movie.title;
        if (isShowMediaInfo(mediaInfo)) return mediaInfo.show.title;
        return 'Comments';
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/50 z-[1000000000] flex items-center justify-center p-4">
            <div className="bg-(--color-surface-1) text-(--color-text-primary) rounded-lg shadow-xl w-full max-w-4xl h-[80vh] flex flex-col">
                <div className="flex justify-between items-center p-4 border-b border-(--color-border)">
                    <div>
                        <h2 className="text-xl font-bold">{getTitle()}</h2>
                        <p className="text-sm text-(--color-text-secondary)">
                            Review for:{' '}
                            <span className="capitalize font-semibold">
                                {commentType}
                            </span>
                            {comments.some(c => c.serviceType === 'anilist') && (
                                <span className="text-xs text-(--color-text-tertiary) ml-2">
                                    (AniList: show-level only)
                                </span>
                            )}
                        </p>
                        {serviceStatuses && serviceStatuses.length > 0 && (
                            <div className="mt-2">
                                <p className="text-xs text-(--color-text-secondary) mb-1">
                                    Posting to:
                                </p>
                                <div className="flex gap-3">
                                    {serviceStatuses.map((status) => (
                                        <CommentServiceBadge
                                            key={status.serviceType}
                                            serviceType={status.serviceType}
                                            isAuthenticated={status.isAuthenticated}
                                            isEnabled={status.isEnabled}
                                        />
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                    <button
                        onClick={onClose}
                        className="text-2xl hover:text-(--color-danger) cursor-pointer"
                    >
                        √ó
                    </button>
                </div>

                <div className="flex flex-grow overflow-hidden">
                    <div className="w-1/3 border-r border-(--color-border) flex flex-col">
                        <div className="p-2 border-b border-(--color-border)">
                            <button
                                onClick={handleNewComment}
                                className="w-full bg-(--color-accent-primary) hover:bg-(--color-accent-primary-hover) text-(--color-text-primary) font-bold py-2 px-4 rounded text-sm cursor-pointer"
                            >
                                + {serviceStatuses && serviceStatuses.length > 0 
                                    ? hasAniListService 
                                        ? hasTraktService
                                            ? hasAniListNote ? 'Edit Note & Comment' : 'Write Review/Note' // Both services
                                            : hasAniListNote ? 'Edit Note' : 'Write Note' // AniList only
                                        : 'New Comment' // Trakt only
                                    : 'New Comment' // Fallback
                                }
                            </button>
                        </div>
                        <div className="flex-grow overflow-y-auto">
                            {isLoading ? (
                                <p className="p-4 text-center">
                                    Loading comments...
                                </p>
                            ) : comments.length === 0 ? (
                                <p className="p-4 text-center text-(--color-text-secondary)">
                                    No comments found.
                                </p>
                            ) : (
                                comments.map((comment) => (
                                    <div
                                        key={comment.id}
                                        className={`p-3 border-b border-(--color-border) cursor-pointer ${selectedCommentId === comment.id ? 'bg-(--color-surface-2)' : 'hover:bg-(--color-surface-2)/50'}`}
                                    >
                                        <div className="flex justify-between items-start">
                                            <div
                                                onClick={() =>
                                                    handleSelectComment(comment)
                                                }
                                            >
                                                <div className="flex items-start gap-2">
                                                    <span className="text-xs font-medium text-(--color-text-tertiary) mt-0.5">
                                                        {comment.serviceType === 'trakt' ? 'üîó' : 
                                                         comment.serviceType === 'anilist' ? 'üìù' : 'üí¨'}
                                                    </span>
                                                    <p className="text-sm line-clamp-2 flex-1">
                                                        {comment.comment}
                                                    </p>
                                                </div>
                                                <p className="text-xs text-(--color-text-secondary) mt-1 ml-6">
                                                    {new Date(
                                                        comment.createdAt
                                                    ).toLocaleString()}
                                                    <span className="ml-2 capitalize">
                                                        {comment.serviceType === 'trakt' ? 'Trakt' : 
                                                         comment.serviceType === 'anilist' ? 'AniList' : comment.serviceType}
                                                    </span>
                                                </p>
                                            </div>
                                            {comment.serviceType !== 'anilist' && (
                                                <button
                                                    onClick={() =>
                                                        handleDelete(comment.id)
                                                    }
                                                    disabled={isSubmitting}
                                                    className="text-(--color-text-secondary) hover:text-(--color-danger) disabled:opacity-50 text-xl ml-2"
                                                >
                                                    √ó
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    <div className="w-2/3 p-4 flex flex-col">
                        <textarea
                            ref={textareaRef}
                            value={editorText}
                            onChange={(e) => setEditorText(e.target.value)}
                            placeholder={
                                hasTraktService
                                    ? hasAniListService
                                        ? "Write your review or note here... (Trakt: min 5 words, AniList: any length)"
                                        : "Write your review or shout here... (at least 5 words)"
                                    : "Write your note here..."
                            }
                            className={`w-full flex-grow bg-(--color-background) border rounded-md p-3 text-base resize-none focus:outline-none focus:ring-2 ${validationError ? 'border-(--color-danger) focus:ring-(--color-danger)' : 'border-(--color-border) focus:ring-(--color-accent-primary)'}`}
                        />
                        {validationError && (
                            <p className="text-(--color-danger) text-sm mt-1">
                                {validationError}
                            </p>
                        )}
                        <div className="mt-4">
                            {/* Explanation text for multi-service posting */}
                            {serviceStatuses && serviceStatuses.length > 1 && (
                                <div className="mb-3 p-2 bg-(--color-surface-2) rounded text-xs text-(--color-text-secondary)">
                                    <p>
                                        üí° <strong>Unified posting:</strong> This will create{' '}
                                        {serviceStatuses.some(s => s.serviceType === 'trakt') && 'a Trakt comment'}
                                        {serviceStatuses.some(s => s.serviceType === 'trakt') && 
                                         serviceStatuses.some(s => s.serviceType === 'anilist') && ' and '}
                                        {serviceStatuses.some(s => s.serviceType === 'anilist') && 'update your AniList note'}
                                        {' '}with the same content.
                                    </p>
                                </div>
                            )}
                            
                            {/* Show spoiler option only when Trakt is available */}
                            {hasTraktService && (
                                <label className="flex items-center space-x-2 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={isSpoiler}
                                        onChange={(e) =>
                                            setIsSpoiler(e.target.checked)
                                        }
                                        className="form-checkbox h-5 w-5 bg-(--color-surface-2) border-(--color-border) text-(--color-accent-primary) focus:ring-(--color-accent-primary)"
                                    />
                                    <span className="text-sm">
                                        This comment contains spoilers{' '}
                                        {hasAniListService && (
                                            <span className="text-xs text-(--color-text-tertiary)">
                                                (Trakt only)
                                            </span>
                                        )}
                                    </span>
                                </label>
                            )}

                            {commentType && ratings && (
                                <ModalStarRating
                                    label={`${commentType.charAt(0).toUpperCase() + commentType.slice(1)} Rating`}
                                    currentRating={
                                        commentType === 'movie'
                                            ? (ratings['show']?.userRating ??
                                              null)
                                            : (ratings[
                                                  commentType as Exclude<
                                                      CommentableType,
                                                      'movie'
                                                  >
                                              ]?.userRating ?? null)
                                    }
                                    onRate={(r) => onRate(commentType, r)}
                                    isSubmitting={isSubmitting}
                                />
                            )}
                        </div>
                    </div>
                </div>

                <div className="p-4 border-t border-(--color-border) flex justify-end space-x-3">
                    <button
                        onClick={onClose}
                        className="px-4 py-2 bg-(--color-surface-3) hover:bg-(--color-surface-2) rounded font-semibold cursor-pointer"
                    >
                        Close
                    </button>
                    <button
                        onClick={handleSave}
                        disabled={isSubmitting || !editorText.trim()}
                        className="px-4 py-2 bg-(--color-success) hover:bg-(--color-success-hover) rounded font-semibold disabled:opacity-50 disabled:cursor-not-allowed cursor-pointer"
                    >
                        {isSubmitting ? 'Saving...' : 'Save Comment'}
                    </button>
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/hooks/useMediaLifecycle.ts">
import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { getLocalRewatchInfo } from '../utils/helpers/localRewatch';
import { SiteConfigBase } from '../utils/siteConfigs/baseConfig';
import { getCurrentSiteConfig } from '../utils/siteConfigs';
import { HighlightType } from '../utils/highlighting';
import {
    MediaInfoResponse,
    MediaRatings,
    SeasonEpisodeObj,
    CommentableType
} from '../types/media';
import { TraktComment, TraktShowWatchedProgress } from '../types/trakt';
import {
    ServiceComment,
    ServiceProgressInfo,
    ServiceMediaRatings
} from '../types/serviceTypes';
import {
    MessageRequest,
    MessageResponse,
    MediaStatusPayload
} from '../types/messaging';
import { isMovieMediaInfo, isShowMediaInfo } from '../utils/typeGuards';

export type UIState =
    | 'loading'
    | 'idle'
    | 'needs_manual_confirmation'
    | 'prompt_start'
    | 'prompt_rewatch'
    | 'scrobbling_ready';

async function getMediaInfoAndConfidence(
    siteConfig: SiteConfigBase,
    url: string
): Promise<MessageResponse<MediaStatusPayload>> {
    const mediaType = siteConfig.getMediaType(url);
    if (!mediaType) {
        return {
            success: false,
            error: 'Failed to determine media type from URL.'
        };
    }
    const title = await siteConfig.getTitle(url).catch(() => null);
    const year = await siteConfig.getYear(url).catch(() => null);

    const messageParams: { type: string; query: string; years: string } = {
        type: mediaType,
        query: title || '',
        years: year || ''
    };

    return await chrome.runtime.sendMessage({
        action: 'mediaInfo',
        params: messageParams
    });
}

export function useMediaLifecycle() {
    // Core Media State
    const [mediaInfo, setMediaInfo] = useState<MediaInfoResponse | null>(null);
    const [episodeInfo, setEpisodeInfo] = useState<SeasonEpisodeObj | null>(
        null
    );
    const [originalQuery, setOriginalQuery] = useState<{
        type: string;
        query: string;
        years: string;
    } | null>(null);

    // Associated Trakt Data State
    const [ratings, setRatings] = useState<ServiceMediaRatings | null>(null);
    const [progressInfo, setProgressInfo] =
        useState<ServiceProgressInfo | null>(null);
    const [highlightTarget, setHighlightTarget] = useState<{
        season: number;
        episode: number;
        type: HighlightType;
    } | null>(null);
    const [watchedHistoryEpisodes, setWatchedHistoryEpisodes] = useState<
        { season: number; number: number }[]
    >([]);

    // UI and Interaction State
    const [uiState, setUiState] = useState<UIState>('loading');
    const [isRewatchSession, setIsRewatchSession] = useState(false);
    const [userConfirmedAction, setUserConfirmedAction] = useState(false);

    // URL and Config State
    const [currentUrl, setCurrentUrl] = useState(window.location.href);
    const previousUrlRef = useRef<string | null>(null);
    const siteConfig = useMemo(
        () => getCurrentSiteConfig(new URL(currentUrl).hostname),
        [currentUrl]
    );

    // Comments State
    const [isCommentModalOpen, setIsCommentModalOpen] = useState(false);
    const [commentModalType, setCommentModalType] =
        useState<CommentableType | null>(null);
    const [comments, setComments] = useState<ServiceComment[]>([]);
    const [isLoadingComments, setIsLoadingComments] = useState(false);

    const sendMessage = useCallback(
        async <TResponseData = any>(
            message: MessageRequest
        ): Promise<MessageResponse<TResponseData>> => {
            return await chrome.runtime.sendMessage(message);
        },
        []
    );

    const resetState = useCallback(() => {
        setMediaInfo(null);
        setEpisodeInfo(null);
        setOriginalQuery(null);
        setRatings(null);
        setProgressInfo(null);
        setHighlightTarget(null);
        setWatchedHistoryEpisodes([]);
        setUiState('loading');
        setIsRewatchSession(false);
        setUserConfirmedAction(false);
    }, []);

    const processMediaStatus = useCallback(
        async (
            data: MediaStatusPayload,
            currentEpisodeInfo: SeasonEpisodeObj | null
        ) => {
            setRatings(data.ratingInfo || null);
            setProgressInfo(data.progressInfo || null);

            let newHighlight: {
                season: number;
                episode: number;
                type: HighlightType;
            } | null = null;
            let watchedEps: { season: number; number: number }[] = [];

            if (isShowMediaInfo(data.mediaInfo)) {
                const traktProgress = data.progressInfo;
                if (traktProgress?.seasons) {
                    watchedEps = traktProgress.seasons.flatMap((s) =>
                        s.episodes
                            .filter((e) => e.completed)
                            .map((e) => ({
                                season: s.number,
                                number: e.number
                            }))
                    );
                }

                const isShowCompleted = traktProgress
                    ? traktProgress.completed >= traktProgress.aired
                    : false;

                // Scenario 1: Show is fully watched, so this is definitely a rewatch.
                if (isShowCompleted) {
                    setUiState('prompt_rewatch');
                    const localInfo = await getLocalRewatchInfo(
                        data.mediaInfo.show.ids.trakt
                    );
                    if (localInfo?.lastWatched) {
                        newHighlight = {
                            season: localInfo.lastWatched.season,
                            episode: localInfo.lastWatched.number,
                            type: 'rewatch_last'
                        };
                    }
                }
                // Scenario 2: Show is in progress.
                else if (data.watchStatus?.isInHistory && traktProgress) {
                    const isCurrentEpisodeWatched = watchedEps.some(
                        (ep) =>
                            ep.season === currentEpisodeInfo?.season &&
                            ep.number === currentEpisodeInfo?.number
                    );

                    if (isCurrentEpisodeWatched) {
                        // Viewing an already-watched episode within an unfinished show.
                        setUiState('prompt_rewatch');
                    } else {
                        // Viewing the next unwatched episode. No prompt needed.
                        setUiState('scrobbling_ready');
                        setUserConfirmedAction(true);
                    }

                    if (traktProgress.lastEpisode) {
                        newHighlight = {
                            season: traktProgress.lastEpisode.season,
                            episode: traktProgress.lastEpisode.number,
                            type: 'first_watch_last'
                        };
                    }
                }
                // Scenario 3: Brand new show (no history, 0 completed).
                else {
                    setUiState('prompt_start');
                }
            } else if (isMovieMediaInfo(data.mediaInfo)) {
                if (data.watchStatus?.isInHistory) {
                    setUiState('prompt_rewatch');
                } else {
                    setUiState('prompt_start');
                }
            }

            setHighlightTarget(newHighlight);
            setWatchedHistoryEpisodes(watchedEps);
        },
        []
    );

    const fetchAndProcessMedia = useCallback(async () => {
        resetState();
        if (!siteConfig || !siteConfig.isWatchPage(currentUrl)) {
            setUiState('idle');
            return;
        }

        const response = await getMediaInfoAndConfidence(
            siteConfig,
            currentUrl
        );

        if (response.success && response.data) {
            const {
                mediaInfo: mi,
                confidence,
                originalQuery: oq
            } = response.data;
            setMediaInfo(mi);
            setOriginalQuery(oq);

            if (confidence === 'high' && mi) {
                const currentEpisodeInfo =
                    siteConfig.getSeasonEpisodeObj(currentUrl) || null;
                setEpisodeInfo(currentEpisodeInfo);
                await processMediaStatus(response.data, currentEpisodeInfo);
            } else {
                setUiState('needs_manual_confirmation');
            }
        } else {
            setUiState('idle');
        }
    }, [currentUrl, siteConfig, resetState, processMediaStatus]);

    useEffect(() => {
        const interval = setInterval(() => {
            const href = window.location.href;
            if (href !== currentUrl) {
                previousUrlRef.current = currentUrl;
                setCurrentUrl(href);
            }
        }, 500);
        return () => clearInterval(interval);
    }, [currentUrl]);

    useEffect(() => {
        fetchAndProcessMedia();
    }, [fetchAndProcessMedia]);

    const confirmManualSelection = useCallback(
        async (confirmedMedia: MediaInfoResponse) => {
            setUiState('loading');
            await sendMessage({
                action: 'confirmMedia',
                params: confirmedMedia
            });
            await fetchAndProcessMedia();
        },
        [sendMessage, fetchAndProcessMedia]
    );

    const confirmStart = useCallback(() => {
        setUserConfirmedAction(true);
        setUiState('scrobbling_ready');
    }, []);

    const confirmRewatch = useCallback(() => {
        setUserConfirmedAction(true);
        setIsRewatchSession(true);
        setUiState('scrobbling_ready');
    }, []);

    const cancelManualSearch = useCallback(() => {
        setUiState('idle');
        setOriginalQuery(null);
    }, []);

    const handleRate = useCallback(
        async (type: CommentableType, rating: number) => {
            if (!mediaInfo) return;
            const action =
                type === 'movie'
                    ? 'rateMovie'
                    : type === 'show'
                      ? 'rateShow'
                      : type === 'season'
                        ? 'rateSeason'
                        : 'rateEpisode';
            const params: any = { mediaInfo, rating };
            if (['season', 'episode'].includes(type) && episodeInfo) {
                params.episodeInfo = episodeInfo;
            }
            const response = await sendMessage({ action, params });
            if (response.success) {
                setRatings((prev) => ({
                    ...prev,
                    [type === 'movie' ? 'show' : type]: {
                        userRating: rating,
                        ratedAt: new Date().toISOString()
                    }
                }));
            }
        },
        [mediaInfo, episodeInfo, sendMessage]
    );

    const handleUnrate = useCallback(
        async (type: CommentableType) => {
            if (!mediaInfo) return;
            const action =
                type === 'movie'
                    ? 'unrateMovie'
                    : type === 'show'
                      ? 'unrateShow'
                      : type === 'season'
                        ? 'unrateSeason'
                        : 'unrateEpisode';
            const params: any = { mediaInfo };
            if (['season', 'episode'].includes(type) && episodeInfo) {
                params.episodeInfo = episodeInfo;
            }
            const response = await sendMessage({ action, params });
            if (response.success) {
                setRatings((prev) => ({
                    ...prev,
                    [type === 'movie' ? 'show' : type]: undefined
                }));
            }
        },
        [mediaInfo, episodeInfo, sendMessage]
    );

    const openCommentModal = useCallback(
        async (type: CommentableType) => {
            if (!mediaInfo) return;
            setIsCommentModalOpen(true);
            setCommentModalType(type);
            setIsLoadingComments(true);
            setComments([]);
            const response = await sendMessage<ServiceComment[]>({
                action: 'getComments',
                params: {
                    type,
                    mediaInfo,
                    episodeInfo: episodeInfo || undefined
                }
            });
            if (response.success && response.data) setComments(response.data);
            setIsLoadingComments(false);
        },
        [mediaInfo, episodeInfo, sendMessage]
    );

    const closeCommentModal = useCallback(
        () => setIsCommentModalOpen(false),
        []
    );

    const postComment = useCallback(
        async (comment: string, spoiler: boolean) => {
            if (!mediaInfo || !commentModalType) return { success: false };
            const response = await sendMessage<ServiceComment>({
                action: 'postComment',
                params: {
                    type: commentModalType,
                    mediaInfo,
                    episodeInfo: episodeInfo || undefined,
                    comment,
                    spoiler
                }
            });
            if (response.success && response.data)
                setComments((p) => [response.data!, ...p]);
            return response;
        },
        [mediaInfo, episodeInfo, commentModalType, sendMessage]
    );

    const updateComment = useCallback(
        async (
            commentId: number | string,
            comment: string,
            spoiler: boolean
        ) => {
            const response = await sendMessage<ServiceComment>({
                action: 'updateComment',
                params: { commentId, comment, spoiler }
            });
            if (response.success && response.data)
                setComments((p) =>
                    p.map((c) => (c.id === commentId ? response.data! : c))
                );
            return response;
        },
        [sendMessage]
    );

    const deleteComment = useCallback(
        async (commentId: number | string) => {
            const response = await sendMessage({
                action: 'deleteComment',
                params: { commentId }
            });
            if (response.success)
                setComments((p) => p.filter((c) => c.id !== commentId));
            return response;
        },
        [sendMessage]
    );

    return {
        mediaInfo,
        episodeInfo,
        originalQuery,
        ratings,
        progressInfo,
        highlightTarget,
        watchedHistoryEpisodes,
        uiState,
        userConfirmedAction,
        isRewatchSession,
        siteConfig,
        confirmManualSelection,
        confirmStart,
        confirmRewatch,
        cancelManualSearch,
        handleRate,
        handleUnrate,
        refetch: fetchAndProcessMedia,
        isCommentModalOpen,
        isLoadingComments,
        commentModalType,
        comments,
        openCommentModal,
        closeCommentModal,
        postComment,
        updateComment,
        deleteComment
    };
}
</file>

<file path="src/hooks/useScrobbling.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import { saveLocalRewatchInfo } from '../utils/helpers/localRewatch';
import { isShowMediaInfo } from '../utils/typeGuards';
import { MediaInfoResponse, SeasonEpisodeObj } from '../types/media';
import {
    ActiveScrobbleStatus,
    ScrobbleStopResponseData
} from '../types/scrobbling';
import {
    MessageRequest,
    MessageResponse,
    RequestManualAddToHistoryParams,
    RequestScrobblePauseParams,
    RequestScrobbleStartParams,
    RequestScrobbleStopParams
} from '../types/messaging';

const VIDEO_PROGRESS_UPDATE_THROTTLE_MS = 2000;
const WATCHING_PING_INTERVAL_MS = 5 * 60 * 1000;
const TRAKT_SCROBBLE_COMPLETION_THRESHOLD = 80;
const MIN_TIME_BETWEEN_ACTIONS_MS = 500;

export function useScrobbling(
    mediaInfo: MediaInfoResponse | null,
    episodeInfo: SeasonEpisodeObj | null,
    userConfirmedAction: boolean,
    isRewatchSession: boolean
) {
    const [status, setStatus] = useState<ActiveScrobbleStatus>('idle');
    const [progress, setProgress] = useState(0);
    const [isProcessing, setIsProcessing] = useState(false);
    const historyIdRef = useRef<number | null>(null);
    const serviceHistoryIdsRef = useRef<{
        [serviceType: string]: number | string;
    }>({});

    const videoRef = useRef<HTMLVideoElement | null>(null);
    const lastPingTimeRef = useRef(0);
    const lastReportedProgressRef = useRef(0);
    const lastSentActionTimestampRef = useRef(0);
    const timeUpdateProcessingScheduledRef = useRef(false);
    const pageUnloadRef = useRef(false);

    const sendMessage = useCallback(
        async <TResponseData = any>(
            message: MessageRequest
        ): Promise<MessageResponse<TResponseData>> => {
            return await chrome.runtime.sendMessage(message);
        },
        []
    );

    const sendScrobbleStart = useCallback(async () => {
        if (!mediaInfo) return;
        const now = Date.now();
        if (
            now - lastSentActionTimestampRef.current <
            MIN_TIME_BETWEEN_ACTIONS_MS * 2
        )
            return;
        lastSentActionTimestampRef.current = now;

        const params: RequestScrobbleStartParams = {
            mediaInfo,
            episodeInfo: episodeInfo || undefined,
            progress
        };
        const response = await sendMessage({
            action: 'requestScrobbleStart',
            params
        });
        if (response.success) {
            setStatus('started');
            lastPingTimeRef.current = now;
            lastReportedProgressRef.current = progress;
        }
    }, [mediaInfo, episodeInfo, progress, sendMessage]);

    const sendScrobblePause = useCallback(async () => {
        if (!mediaInfo || status !== 'started') return;
        const now = Date.now();
        if (
            now - lastSentActionTimestampRef.current <
            MIN_TIME_BETWEEN_ACTIONS_MS
        )
            return;
        lastSentActionTimestampRef.current = now;

        const params: RequestScrobblePauseParams = {
            mediaInfo,
            episodeInfo: episodeInfo || undefined,
            progress
        };
        const response = await sendMessage({
            action: 'requestScrobblePause',
            params
        });
        if (response.success) setStatus('paused');
    }, [mediaInfo, episodeInfo, progress, status, sendMessage]);

    const sendScrobbleStop = useCallback(async () => {
        if (!mediaInfo || status === 'idle') return null;
        const now = Date.now();
        if (
            now - lastSentActionTimestampRef.current <
            MIN_TIME_BETWEEN_ACTIONS_MS
        )
            return null;
        lastSentActionTimestampRef.current = now;

        const params: RequestScrobbleStopParams = {
            mediaInfo: mediaInfo!,
            episodeInfo: episodeInfo || undefined,
            progress
        };
        const response = await sendMessage<ScrobbleStopResponseData>({
            action: 'requestScrobbleStop',
            params
        });

        if (response.success && response.data) {
            setStatus('idle');
            if (
                response.data.action === 'watched' &&
                response.data.traktHistoryId
            ) {
                console.log(
                    '‚úÖ Setting historyId to prevent future starts:',
                    response.data.traktHistoryId
                );
                historyIdRef.current = response.data.traktHistoryId;

                // Store service-specific history IDs for proper undo functionality
                if (response.data.serviceHistoryIds) {
                    serviceHistoryIdsRef.current =
                        response.data.serviceHistoryIds;
                    console.log(
                        'üíæ Stored service-specific history IDs:',
                        response.data.serviceHistoryIds
                    );
                }

                if (
                    isRewatchSession &&
                    isShowMediaInfo(mediaInfo) &&
                    episodeInfo
                ) {
                    await saveLocalRewatchInfo(
                        mediaInfo.show.ids.trakt,
                        episodeInfo.season,
                        episodeInfo.number
                    );
                }
            }
            return response.data;
        }
        return null;
    }, [
        mediaInfo,
        episodeInfo,
        progress,
        status,
        isRewatchSession,
        sendMessage
    ]);

    const processThrottledTimeUpdate = useCallback(
        async (latestProgress: number) => {
            timeUpdateProcessingScheduledRef.current = false;
            if (!mediaInfo || !userConfirmedAction || pageUnloadRef.current)
                return;

            setProgress(latestProgress);

            if (status === 'started') {
                const now = Date.now();
                const progressDelta = Math.abs(
                    latestProgress - lastReportedProgressRef.current
                );

                if (
                    now - lastPingTimeRef.current > WATCHING_PING_INTERVAL_MS ||
                    progressDelta >= 5
                ) {
                    await sendScrobbleStart();
                }

                if (
                    latestProgress >= TRAKT_SCROBBLE_COMPLETION_THRESHOLD &&
                    !historyIdRef.current
                ) {
                    console.log(
                        'üõë Triggering stop - progress:',
                        latestProgress,
                        'historyId:',
                        historyIdRef.current
                    );
                    await sendScrobbleStop();
                }
            }
        },
        [
            mediaInfo,
            userConfirmedAction,
            status,
            sendScrobbleStart,
            sendScrobbleStop
        ]
    );

    const lastProgressRef = useRef<number>(0);
    const seekDetectedRef = useRef<boolean>(false);

    const handleTimeUpdate = useCallback(() => {
        if (!videoRef.current || pageUnloadRef.current) return;
        const { currentTime, duration } = videoRef.current;
        if (isNaN(duration) || duration === 0) return;

        const currentProgress = (currentTime / duration) * 100;

        // Detect seeking: large jump in progress (>5% change)
        const progressDelta = Math.abs(
            currentProgress - lastProgressRef.current
        );
        if (progressDelta > 5) {
            console.log('üîÑ Seek detected:', {
                from: lastProgressRef.current,
                to: currentProgress,
                delta: progressDelta
            });
            seekDetectedRef.current = true;
            // Delay processing after seek to let video element settle
            setTimeout(() => {
                seekDetectedRef.current = false;
            }, 1000);
        }

        lastProgressRef.current = currentProgress;

        // Skip processing if we just detected a seek
        if (seekDetectedRef.current) {
            console.log('‚è≠Ô∏è Skipping progress update due to recent seek');
            return;
        }

        // Debug logging for progress calculation
        if (currentProgress > 80 || currentProgress < 5) {
            console.log('üìä Video progress calculation:', {
                currentTime,
                duration,
                calculatedProgress: currentProgress,
                ratio: currentTime / duration
            });
        }

        if (!timeUpdateProcessingScheduledRef.current) {
            timeUpdateProcessingScheduledRef.current = true;
            setTimeout(
                () => processThrottledTimeUpdate(currentProgress),
                VIDEO_PROGRESS_UPDATE_THROTTLE_MS
            );
        }
    }, [processThrottledTimeUpdate]);

    const handlePlay = useCallback(() => {
        if (!mediaInfo || !userConfirmedAction) return;
        if (historyIdRef.current) {
            console.log(
                'üö´ Skipping start on play - already completed (historyId:',
                historyIdRef.current,
                ')'
            );
            return;
        }
        if (status === 'idle' || status === 'paused') {
            console.log('üöÄ Starting on play event - status:', status);
            sendScrobbleStart();
        }
    }, [mediaInfo, userConfirmedAction, status, sendScrobbleStart]);

    const handlePause = useCallback(() => {
        if (!mediaInfo || !userConfirmedAction) return;
        if (status === 'started') sendScrobblePause();
    }, [mediaInfo, userConfirmedAction, status, sendScrobblePause]);

    const handleEnded = useCallback(async () => {
        if (!mediaInfo || !userConfirmedAction) return;
        if (status === 'started' || status === 'paused') {
            setProgress(100);
            await sendScrobbleStop();
        }
    }, [mediaInfo, userConfirmedAction, status, sendScrobbleStop]);

    useEffect(() => {
        if (!userConfirmedAction) return;
        let findVideoIntervalId: number | null = null;
        let attempts = 0;

        const tryToSetupVideoPlayer = () => {
            const videoElement = document.querySelector('video');
            if (videoElement) {
                if (findVideoIntervalId) clearInterval(findVideoIntervalId);
                videoRef.current = videoElement;
                videoElement.addEventListener('play', handlePlay);
                videoElement.addEventListener('pause', handlePause);
                videoElement.addEventListener('ended', handleEnded);
                videoElement.addEventListener('timeupdate', handleTimeUpdate);
                if (!videoElement.paused) handlePlay();
            } else {
                attempts++;
                if (attempts > 20) {
                    // Stop after 10 seconds
                    if (findVideoIntervalId) clearInterval(findVideoIntervalId);
                }
            }
        };

        tryToSetupVideoPlayer();
        findVideoIntervalId = window.setInterval(tryToSetupVideoPlayer, 500);

        return () => {
            if (findVideoIntervalId) clearInterval(findVideoIntervalId);
            if (videoRef.current) {
                videoRef.current.removeEventListener('play', handlePlay);
                videoRef.current.removeEventListener('pause', handlePause);
                videoRef.current.removeEventListener('ended', handleEnded);
                videoRef.current.removeEventListener(
                    'timeupdate',
                    handleTimeUpdate
                );
            }
        };
    }, [
        userConfirmedAction,
        handlePlay,
        handlePause,
        handleEnded,
        handleTimeUpdate
    ]);

    useEffect(() => {
        const handler = () => {
            pageUnloadRef.current = true;
        };
        window.addEventListener('beforeunload', handler);
        return () => window.removeEventListener('beforeunload', handler);
    }, []);

    const manualScrobble = useCallback(async () => {
        if (!mediaInfo) return;
        setIsProcessing(true);
        if (status === 'started') await sendScrobblePause();
        const params: RequestManualAddToHistoryParams = {
            mediaInfo,
            episodeInfo: episodeInfo || undefined
        };
        const response = await sendMessage<{ traktHistoryId?: number }>({
            action: 'requestManualAddToHistory',
            params
        });
        if (response.success && response.data?.traktHistoryId) {
            historyIdRef.current = response.data.traktHistoryId;
        }
        setIsProcessing(false);
    }, [mediaInfo, episodeInfo, status, sendMessage, sendScrobblePause]);

    const undoScrobble = useCallback(async () => {
        if (
            !historyIdRef.current &&
            Object.keys(serviceHistoryIdsRef.current).length === 0
        ) {
            return false;
        }
        setIsProcessing(true);

        // Prefer service-specific IDs if available, fallback to legacy single ID
        const undoParams =
            Object.keys(serviceHistoryIdsRef.current).length > 0
                ? { serviceHistoryIds: serviceHistoryIdsRef.current }
                : { historyId: historyIdRef.current! };

        console.log('üîÑ Sending undo request with params:', undoParams);

        const response = await sendMessage({
            action: 'undoScrobble',
            params: undoParams
        });

        if (response.success) {
            historyIdRef.current = null;
            serviceHistoryIdsRef.current = {};
            console.log('‚úÖ Cleared all history IDs after successful undo');
        }
        setIsProcessing(false);
        return response.success;
    }, [sendMessage]);

    return {
        status,
        isProcessing,
        historyId: historyIdRef.current,
        manualScrobble,
        undoScrobble
    };
}
</file>

<file path="src/services/index.ts">
/**
 * Service initialization and registration
 *
 * This file sets up all tracking services and registers them
 * with the ServiceRegistry for multi-service functionality.
 */

import { serviceRegistry } from './ServiceRegistry';
import { traktService } from './TraktService';
import { aniListService } from './AniListService';

/**
 * Initialize and register all tracking services
 */
export function initializeServices(): void {
    // Register TraktService (primary service)
    serviceRegistry.registerService(traktService, {
        serviceType: 'trakt',
        enabled: true,
        priority: 1 // Primary service (higher priority than AniList)
    });

    // Register AniListService (secondary service)
    serviceRegistry.registerService(aniListService, {
        serviceType: 'anilist',
        enabled: true,
        priority: 2
    });

    console.log('üéâ Multi-service architecture completed!');
    console.log(
        '‚úÖ TraktService successfully implements TrackerService interface'
    );
    console.log(
        '‚úÖ AniListService successfully implements TrackerService interface'
    );
    console.log(
        '‚úÖ ServiceRegistry manages multiple services with capabilities'
    );
    console.log(
        '‚úÖ Both services registered and ready for multi-service workflow'
    );

    console.log('Multi-service architecture initialized:');
    console.log(
        '- Primary service:',
        serviceRegistry.getPrimaryService()?.getCapabilities().serviceType
    );
    console.log(
        '- Enabled services:',
        serviceRegistry
            .getEnabledServices()
            .map((s) => s.getCapabilities().serviceType)
    );
    console.log(
        '- Services with real-time scrobbling:',
        serviceRegistry
            .getServicesWithCapability('supportsRealTimeScrobbling')
            .map((s) => s.getCapabilities().serviceType)
    );
    console.log(
        '- Services with progress tracking:',
        serviceRegistry
            .getServicesWithCapability('supportsProgressTracking')
            .map((s) => s.getCapabilities().serviceType)
    );
    console.log(
        '- Services with ratings:',
        serviceRegistry
            .getServicesWithCapability('supportsRatings')
            .map((s) => s.getCapabilities().serviceType)
    );
}

/**
 * Get all available services
 */
export function getServices() {
    return {
        registry: serviceRegistry,
        trakt: traktService,
        anilist: aniListService
    };
}

// Export individual services and registry
export { serviceRegistry, traktService, aniListService };
</file>

<file path="src/styles/index.css">
@import 'tailwindcss';

@theme {
    /* Base Colors */
    --color-background: oklch(
        19.5% 0.024 258
    ); /* Near black with a cool tint */
    --color-surface-1: oklch(24% 0.024 258); /* Slightly lighter surface */
    --color-surface-2: oklch(
        28% 0.024 258
    ); /* Lighter for interactive elements */
    --color-surface-3: oklch(35% 0.022 258); /* Lighter for borders/dividers */

    /* Text Colors */
    --color-text-primary: oklch(95% 0.01 258); /* Off-white for primary text */
    --color-text-secondary: oklch(65% 0.01 258); /* Gray for secondary text */
    --color-text-tertiary: oklch(
        45% 0.01 258
    ); /* Darker gray for subtle text */
    --color-text-inverted: oklch(
        15% 0.02 258
    ); /* For use on light backgrounds */

    /* Accent Colors */
    --color-accent-primary: oklch(62.3% 0.214 259.815); /* blue-500 */
    --color-accent-primary-hover: oklch(54.6% 0.245 262.881); /* blue-600 */
    --color-accent-secondary: oklch(58.5% 0.233 277.117); /* indigo-500 */
    --color-accent-secondary-hover: oklch(51.1% 0.262 276.966); /* indigo-600 */

    /* Semantic Colors */
    --color-success: oklch(72.3% 0.219 149.579); /* green-500 */
    --color-success-hover: oklch(62.7% 0.194 149.214); /* green-600 */
    --color-success-text: oklch(87.1% 0.15 154.449); /* green-300 */
    --color-warning: oklch(85.2% 0.199 91.936); /* yellow-400 */
    --color-warning-text: oklch(94.5% 0.129 101.54); /* yellow-200 */
    --color-danger: oklch(70.4% 0.191 22.216); /* red-400 */
    --color-danger-hover: oklch(63.7% 0.237 25.331); /* red-500 */
    --color-danger-text: oklch(88.5% 0.062 18.334); /* red-200 */

    /* Border Color */
    --color-border: oklch(35% 0.022 258); /* Same as surface-3 */

    /* Component-specific */
    --color-star-filled: oklch(90.5% 0.182 98.111); /* yellow-300 */
    --color-star-empty: oklch(45% 0.01 258); /* text-tertiary */

    /* Animations */
    --animate-fade-in-scale: fade-in-scale 0.3s ease-out;
    @keyframes fade-in-scale {
        0% {
            opacity: 0;
            transform: scale(0.95);
        }
        100% {
            opacity: 1;
            transform: scale(1);
        }
    }
}
</file>

<file path="src/utils/siteConfigs/cineby.ts">
import { createSiteConfig } from './baseConfig';

export const cinebyConfig = createSiteConfig({
    name: 'Cineby',
    selectorType: 'css',
    urlPatterns: {
        movie: /\/movie\/.+/,
        show: /\/tv\/.+/
    },
    selectors: {
        movie: {
            title: 'head > title',
            year: '#__next > div.relative.w-full.h-screen > div.z-\\[1\\].mx-0.max-w-screen-lg.px-4.pb-4.md\\:mx-4.lg\\:mx-auto.lg\\:pb-20.xl\\:px-0 > div.flex.items-center.justify-center.min-h-screen.gap-12.text-center > div > div.flex.items-center.gap-3.font-semibold > div:nth-child(1)'
        },
        show: {
            title: 'head > title',
            year: '#__next > div.relative.w-full.h-screen > div.z-\\[1\\].mx-0.max-w-screen-lg.px-4.pb-4.md\\:mx-4.lg\\:mx-auto.lg\\:pb-20.xl\\:px-0 > div.flex.items-center.justify-center.min-h-screen.gap-12.text-center > div > div.flex.items-center.gap-3.font-semibold > div:nth-child(1)'
        }
    }
});

// Override specific methods as needed
cinebyConfig.getUrlIdentifier = function (url: string): string {
    const urlObj = new URL(url);
    const urlPath = urlObj.pathname.split('/');

    if (this.isWatchPage(url)) {
        return urlObj.hostname + '/' + urlPath[1] + '/' + urlPath[2];
    }
    return '';
};

cinebyConfig.getSeasonEpisodeObj = function (
    url: string
): { season: number; number: number } | null {
    if (!this.isShowPage(url)) return null;

    const urlObj = new URL(url);
    const urlPath = urlObj.pathname.split('/');

    if (urlPath.length === 3) {
        return { season: 1, number: 1 };
    } else {
        return {
            season: Number(urlPath[3]),
            number: Number(urlPath[4])
        };
    }
};
</file>

<file path="package.json">
{
  "name": "tmsync",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "webpack --config webpack/webpack.dev.js --watch",
    "build": "webpack --config webpack/webpack.prod.js",
    "clean": "rimraf dist",
    "format": "prettier --write \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "format:check": "prettier --check \"src/**/*.{ts,tsx,js,jsx,json,css,md}\"",
    "lint": "eslint src --fix",
    "lint:check": "eslint src",
    "type-check": "tsc --noEmit",
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:ui": "vitest --ui",
    "check-all": "pnpm type-check && pnpm lint:check && pnpm format:check",
    "fix-all": "pnpm type-check && pnpm lint && pnpm format",
    "prepare": "husky"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@eslint/js": "^9.7.0",
    "@tailwindcss/postcss": "^4.0.13",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/chrome": "^0.0.287",
    "@types/node": "^22.10.0",
    "@vitest/coverage-v8": "^3.2.4",
    "@vitest/ui": "^3.2.4",
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^12.0.2",
    "css-loader": "^7.1.2",
    "dotenv-webpack": "^8.1.0",
    "eslint": "9.x",
    "eslint-config-prettier": "^9.1.0",
    "globals": "^15.8.0",
    "husky": "^9.1.7",
    "jsdom": "^26.1.0",
    "lint-staged": "^16.1.2",
    "mini-css-extract-plugin": "^2.9.2",
    "postcss": "^8.5.3",
    "postcss-loader": "^8.1.1",
    "prettier": "3.3.3",
    "style-loader": "^4.0.0",
    "tailwindcss": "^4.0.13",
    "ts-loader": "^9.5.1",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.35.1",
    "vitest": "^3.2.4",
    "webpack": "^5.93.0",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "rimraf": "^6.0.1"
  },
  "packageManager": "pnpm@9.15.3+sha1.120e76442c589bb9a3267dbbefa5658c9943fcae",
  "lint-staged": {
    "src/**/*.{ts,tsx,js,jsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "src/**/*.{json,css,md}": [
      "prettier --write"
    ]
  }
}
</file>

<file path="src/background/handlers/handleComments.ts">
import {
    DeleteCommentParams,
    GetCommentsParams,
    PostCommentParams,
    UpdateCommentParams
} from '../../types/messaging';
import { ServiceComment } from '../../types/serviceTypes';
import { serviceRegistry } from '../../services/ServiceRegistry';
import { filterEnabledAuthenticatedServices } from '../../utils/serviceFiltering';

export async function handleGetComments(
    params: GetCommentsParams
): Promise<ServiceComment[]> {
    const { type, mediaInfo, episodeInfo } = params;

    const allCommentServices =
        serviceRegistry.getServicesWithCapability('supportsComments');
    const commentServices =
        await filterEnabledAuthenticatedServices(allCommentServices);

    const allComments: ServiceComment[] = [];

    for (const service of commentServices) {
        try {
            const comments = await service.getComments(
                type,
                mediaInfo,
                episodeInfo
            );
            allComments.push(...comments);
        } catch (error) {
            console.error(
                `Failed to get comments from ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }

    return allComments;
}

export async function handlePostComment(
    params: PostCommentParams
): Promise<ServiceComment> {
    const { type, mediaInfo, episodeInfo, comment, spoiler } = params;

    const allCommentServices =
        serviceRegistry.getServicesWithCapability('supportsComments');
    const commentServices =
        await filterEnabledAuthenticatedServices(allCommentServices);

    console.log(`üîÑ Posting comment to ${commentServices.length} services:`, 
        commentServices.map(s => s.getCapabilities().serviceType));

    // Post to all enabled services (multi-service approach)
    const results: ServiceComment[] = [];
    const errors: string[] = [];

    for (const service of commentServices) {
        try {
            console.log(`üìù Posting to ${service.getCapabilities().serviceType}...`);
            const result = await service.postComment(
                type,
                mediaInfo,
                comment,
                spoiler,
                episodeInfo
            );
            results.push(result);
            console.log(`‚úÖ Successfully posted to ${service.getCapabilities().serviceType}`);
        } catch (error) {
            const serviceName = service.getCapabilities().serviceType;
            const errorMsg = `Failed to post comment on ${serviceName}: ${error}`;
            console.error(errorMsg);
            errors.push(errorMsg);
        }
    }

    if (results.length === 0) {
        throw new Error(`Failed to post comment to any service. Errors: ${errors.join(', ')}`);
    }

    console.log(`‚úÖ Posted comment to ${results.length}/${commentServices.length} services`);
    
    // Return the first successful result (UI expects single ServiceComment)
    return results[0];
}

export async function handleUpdateComment(
    params: UpdateCommentParams
): Promise<ServiceComment> {
    const { commentId, comment, spoiler } = params;

    const allCommentServices =
        serviceRegistry.getServicesWithCapability('supportsComments');
    const commentServices =
        await filterEnabledAuthenticatedServices(allCommentServices);

    // Use primary service for comment updating (return the first successful result)
    for (const service of commentServices) {
        try {
            return await service.updateComment(commentId, comment, spoiler);
        } catch (error) {
            console.error(
                `Failed to update comment on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }

    throw new Error('No available services to update comment');
}

export async function handleDeleteComment(
    params: DeleteCommentParams
): Promise<void> {
    const allCommentServices =
        serviceRegistry.getServicesWithCapability('supportsComments');
    const commentServices =
        await filterEnabledAuthenticatedServices(allCommentServices);

    for (const service of commentServices) {
        try {
            await service.deleteComment(params.commentId);
        } catch (error) {
            console.error(
                `Failed to delete comment on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}
</file>

<file path="src/background/handlers/handleMedia.ts">
import { traktService } from '../../services/TraktService';
import { calculateConfidence } from '../../utils/confidenceHelper';
import { getCurrentSiteConfig } from '../../utils/siteConfigs';
import {
    MediaInfoResponse,
    MovieMediaInfo,
    ScoredMediaInfo,
    ShowMediaInfo
} from '../../types/media';
import { MediaStatusPayload } from '../../types/messaging';

async function fetchStatusDetails(mediaInfo: MediaInfoResponse, url: string) {
    const siteConfig = getCurrentSiteConfig(new URL(url).hostname);
    if (!siteConfig)
        throw new Error('Could not get site config for status details.');

    // Check if authenticated before trying to fetch status
    const isAuthenticated = await traktService
        .isAuthenticated()
        .catch(() => false);
    if (!isAuthenticated) {
        // Return empty status when not authenticated
        return {
            watchStatus: { isInHistory: false },
            progressInfo: null,
            ratingInfo: {}
        };
    }

    const episodeInfo = siteConfig.getSeasonEpisodeObj(url);

    try {
        if (episodeInfo) {
            return await traktService.getMediaStatusWithEpisode(
                mediaInfo,
                episodeInfo
            );
        } else {
            return await traktService.getMediaStatus(mediaInfo);
        }
    } catch (error) {
        console.warn(
            'Failed to fetch status details, returning empty status:',
            error
        );
        // Return empty status on error
        return {
            watchStatus: { isInHistory: false },
            progressInfo: null,
            ratingInfo: {}
        };
    }
}

export async function handleMediaInfo(
    params: { type: string; query: string; years: string },
    sender: chrome.runtime.MessageSender
): Promise<MediaStatusPayload> {
    if (!sender.tab?.url) throw new Error('Sender tab URL is missing.');
    const url = sender.tab.url;
    const siteConfig = getCurrentSiteConfig(new URL(url).hostname);
    if (!siteConfig)
        throw new Error(`No site config found for ${new URL(url).hostname}`);

    const tabUrlIdentifier = siteConfig.getUrlIdentifier(url);
    const cachedData = await chrome.storage.local.get([
        tabUrlIdentifier,
        'tmsync_recent_media'
    ]);
    if (cachedData[tabUrlIdentifier]?.confidence === 'high') {
        // Ensure recent media context is also available
        if (!cachedData.tmsync_recent_media) {
            await chrome.storage.local.set({
                tmsync_recent_media: {
                    ...cachedData[tabUrlIdentifier].mediaInfo,
                    fromCache: Date.now()
                }
            });
            console.log('üíæ Updated recent media context from cache');
        }

        const details = await fetchStatusDetails(
            cachedData[tabUrlIdentifier].mediaInfo,
            url
        );
        return {
            ...details,
            mediaInfo: cachedData[tabUrlIdentifier].mediaInfo,
            confidence: 'high',
            originalQuery: params
        };
    }

    let mediaInfoResult: MediaInfoResponse | null = null;
    if (siteConfig.usesTmdbId) {
        const tmdbId = siteConfig.getTmdbId?.(url);
        if (tmdbId) {
            const mediaTypeGuess = siteConfig.getMediaType(url) || 'movie'; // Default to movie if detection fails
            try {
                const lookupResults = await traktService.getMediaByTmdbId(
                    tmdbId,
                    mediaTypeGuess as 'movie' | 'show'
                );
                const results = lookupResults ? [lookupResults] : [];
                if (results.length > 0) mediaInfoResult = results[0];
            } catch {
                // If the first guess fails (e.g., movie for a show), try the other.
                if (mediaTypeGuess === 'movie') {
                    const lookupResult = await traktService.getMediaByTmdbId(
                        tmdbId,
                        'show'
                    );
                    if (lookupResult) mediaInfoResult = lookupResult;
                }
            }
        }
    }

    if (!mediaInfoResult) {
        const searchResults = await traktService.searchMedia(
            params.query,
            params.type as 'movie' | 'show',
            params.years
        );
        if (searchResults.length > 0) {
            const scoredResults = searchResults
                .map(
                    (result): ScoredMediaInfo => ({
                        ...result,
                        confidenceScore: calculateConfidence(
                            result,
                            params.query,
                            params.years
                        )
                    })
                )
                .sort((a, b) => b.confidenceScore - a.confidenceScore);
            if (scoredResults[0].confidenceScore >= 70) {
                mediaInfoResult = scoredResults[0];
            }
        }
    }

    if (mediaInfoResult) {
        await chrome.storage.local.set({
            [tabUrlIdentifier]: {
                mediaInfo: mediaInfoResult,
                confidence: 'high'
            },
            // Store recent media context for services like AniList that need title for rating
            tmsync_recent_media: {
                ...mediaInfoResult,
                autoDetectedAt: Date.now()
            }
        });
        console.log(
            'üíæ Auto-detected media stored with context:',
            mediaInfoResult
        );
        const details = await fetchStatusDetails(mediaInfoResult, url);
        return {
            ...details,
            mediaInfo: mediaInfoResult,
            confidence: 'high',
            originalQuery: params
        };
    }

    return { mediaInfo: null, confidence: 'low', originalQuery: params };
}

export async function handleManualSearch(params: {
    type: string;
    query: string;
}): Promise<(MovieMediaInfo | ShowMediaInfo)[]> {
    return await traktService.searchMedia(
        params.query,
        params.type as 'movie' | 'show'
    );
}

export async function handleConfirmMedia(
    params: MediaInfoResponse,
    sender: chrome.runtime.MessageSender
): Promise<void> {
    console.log('üìù handleConfirmMedia called with:', params);
    if (!sender.tab?.url) throw new Error('Sender tab URL is missing.');
    const siteConfig = getCurrentSiteConfig(new URL(sender.tab.url).hostname);
    if (!siteConfig) return;
    const tabUrlIdentifier = siteConfig.getUrlIdentifier(sender.tab.url);

    const storageData = {
        [tabUrlIdentifier]: {
            mediaInfo: params,
            confidence: 'high',
            confirmedAt: Date.now()
        },
        // Store recent media context for services like AniList that need title for rating
        tmsync_recent_media: {
            ...params,
            confirmedAt: Date.now()
        }
    };

    console.log('üíæ Storing media context:', storageData);
    await chrome.storage.local.set(storageData);
    console.log('‚úÖ Media context stored successfully');
}
</file>

<file path="src/background/handlers/handleRatings.ts">
import {
    RateEpisodeParams,
    RateMovieParams,
    RateSeasonParams,
    RateShowParams,
    UnrateEpisodeParams,
    UnrateMovieParams,
    UnrateSeasonParams,
    UnrateShowParams
} from '../../types/messaging';
import { serviceRegistry } from '../../services/ServiceRegistry';
import { filterEnabledAuthenticatedServices } from '../../utils/serviceFiltering';

export async function handleRateMovie(params: RateMovieParams): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.rateMovie(params.mediaInfo.movie.ids, params.rating);
        } catch (error) {
            console.error(
                `Failed to rate movie on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleRateShow(params: RateShowParams): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.rateShow(params.mediaInfo.show.ids, params.rating);
        } catch (error) {
            console.error(
                `Failed to rate show on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleRateSeason(
    params: RateSeasonParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.rateSeason(
                params.mediaInfo.show.ids,
                params.episodeInfo.season,
                params.rating
            );
        } catch (error) {
            console.error(
                `Failed to rate season on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleRateEpisode(
    params: RateEpisodeParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.rateEpisode(
                params.mediaInfo.show.ids,
                params.episodeInfo.season,
                params.episodeInfo.number,
                params.rating
            );
        } catch (error) {
            console.error(
                `Failed to rate episode on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleUnrateMovie(
    params: UnrateMovieParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.unrateMovie(params.mediaInfo.movie.ids);
        } catch (error) {
            console.error(
                `Failed to unrate movie on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleUnrateShow(
    params: UnrateShowParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.unrateShow(params.mediaInfo.show.ids);
        } catch (error) {
            console.error(
                `Failed to unrate show on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleUnrateSeason(
    params: UnrateSeasonParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.unrateSeason(
                params.mediaInfo.show.ids,
                params.episodeInfo.season
            );
        } catch (error) {
            console.error(
                `Failed to unrate season on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}

export async function handleUnrateEpisode(
    params: UnrateEpisodeParams
): Promise<void> {
    const allRatingServices =
        serviceRegistry.getServicesWithCapability('supportsRatings');
    const ratingServices =
        await filterEnabledAuthenticatedServices(allRatingServices);

    for (const service of ratingServices) {
        try {
            await service.unrateEpisode(
                params.mediaInfo.show.ids,
                params.episodeInfo.season,
                params.episodeInfo.number
            );
        } catch (error) {
            console.error(
                `Failed to unrate episode on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }
}
</file>

<file path="src/background/index.ts">
import {
    handleConfirmMedia,
    handleManualSearch,
    handleMediaInfo
} from './handlers/handleMedia';
import {
    handleScrobblePause,
    handleScrobbleStart,
    handleScrobbleStop
} from './handlers/handleScrobble';
import {
    handleManualAddToHistory,
    handleUndoScrobble
} from './handlers/handleHistory';
import {
    handleRateEpisode,
    handleRateMovie,
    handleRateSeason,
    handleRateShow,
    handleUnrateEpisode,
    handleUnrateMovie,
    handleUnrateSeason,
    handleUnrateShow
} from './handlers/handleRatings';
import {
    handleGetComments,
    handlePostComment,
    handleUpdateComment,
    handleDeleteComment
} from './handlers/handleComments';
import { handleAuthTokenExchange } from './handlers/handleAuth';
import { serviceStatusManager } from './serviceStatusManager';
import { initializeServices } from '../services';
import { scrobbleState, resetActiveScrobbleState } from './state';
import { callApi } from '../utils/api';
import { isMovieMediaInfo, isShowMediaInfo } from '../utils/typeGuards';
import { MessageRequest } from '../types/messaging';
import { scrobbleOperationManager } from './scrobbleOperationManager';

type MessageHandler = (
    params: any,
    sender: chrome.runtime.MessageSender
) => Promise<any>;

const messageHandlers: Record<string, MessageHandler> = {
    // Media
    mediaInfo: handleMediaInfo,
    manualSearch: handleManualSearch,
    confirmMedia: handleConfirmMedia,
    // Scrobble
    requestScrobbleStart: handleScrobbleStart,
    requestScrobblePause: handleScrobblePause,
    requestScrobbleStop: handleScrobbleStop,
    // History
    requestManualAddToHistory: handleManualAddToHistory,
    undoScrobble: handleUndoScrobble,
    // Ratings
    rateMovie: handleRateMovie,
    rateShow: handleRateShow,
    rateSeason: handleRateSeason,
    rateEpisode: handleRateEpisode,
    // Unratings
    unrateMovie: handleUnrateMovie,
    unrateShow: handleUnrateShow,
    unrateSeason: handleUnrateSeason,
    unrateEpisode: handleUnrateEpisode,
    // Comments
    getComments: handleGetComments,
    postComment: handlePostComment,
    updateComment: handleUpdateComment,
    deleteComment: handleDeleteComment,
    // Authentication
    authTokenExchange: handleAuthTokenExchange,
    // Service Status
    registerStatusListener: async (
        params: any,
        sender: chrome.runtime.MessageSender
    ) => {
        if (sender.tab?.id) {
            serviceStatusManager.addStatusListener(sender.tab.id);
        }
        return { success: true };
    },
    unregisterStatusListener: async (
        params: any,
        sender: chrome.runtime.MessageSender
    ) => {
        if (sender.tab?.id) {
            serviceStatusManager.removeStatusListener(sender.tab.id);
        }
        return { success: true };
    },
    getServiceStatuses: async () => {
        return serviceStatusManager.getAllServiceStatuses();
    },
    updateServiceAuthentication: async (params: { serviceType: string }) => {
        await serviceStatusManager.updateServiceAuthentication(
            params.serviceType as any
        );
        return { success: true };
    }
};

chrome.runtime.onMessage.addListener(
    (request: MessageRequest, sender, sendResponse) => {
        const handler = messageHandlers[request.action];
        if (handler) {
            handler(request.params, sender)
                .then((data) => sendResponse({ success: true, data }))
                .catch((error) => {
                    console.error(
                        `Error handling action '${request.action}':`,
                        error
                    );
                    sendResponse({
                        success: false,
                        error: error?.message || 'An unknown error occurred.'
                    });
                });
        } else {
            sendResponse({
                success: false,
                error: `No handler for action: ${request.action}`
            });
        }
        return true; // Indicates asynchronous response
    }
);

// Tab Listeners
const TRAKT_SCROBBLE_COMPLETION_THRESHOLD = 80;

function buildPayloadForTabClose() {
    const { mediaInfo, episodeInfo, currentProgress } = scrobbleState.current;
    if (!mediaInfo) return null;

    const payload: any = { progress: currentProgress };

    // Correctly narrow the type before accessing properties
    if (isMovieMediaInfo(mediaInfo)) {
        payload.movie = mediaInfo.movie;
    } else if (isShowMediaInfo(mediaInfo) && episodeInfo) {
        payload.show = mediaInfo.show;
        payload.episode = episodeInfo;
    } else {
        return null;
    }
    return payload;
}

async function handleTabCloseOrNavigate(tabId: number) {
    if (
        scrobbleState.current.tabId === tabId &&
        scrobbleState.current.mediaInfo
    ) {
        const payload = buildPayloadForTabClose();
        if (!payload) {
            resetActiveScrobbleState();
            return;
        }

        const { mediaInfo, episodeInfo } = scrobbleState.current;

        if (
            (scrobbleState.current.status === 'started' ||
                scrobbleState.current.status === 'paused') &&
            scrobbleState.current.currentProgress >=
                TRAKT_SCROBBLE_COMPLETION_THRESHOLD
        ) {
            // Use operation manager to prevent conflicts with manual stops
            await scrobbleOperationManager
                .executeOperation(
                    'stop',
                    mediaInfo,
                    episodeInfo || null,
                    async () => {
                        await callApi(
                            `https://api.trakt.tv/scrobble/stop`,
                            'POST',
                            payload
                        );
                    }
                )
                .catch((e) =>
                    console.error('Error on tab-close scrobble stop:', e)
                );
        } else if (scrobbleState.current.status === 'started') {
            // Use operation manager to prevent conflicts with manual pauses
            await scrobbleOperationManager
                .executeOperation(
                    'pause',
                    mediaInfo,
                    episodeInfo || null,
                    async () => {
                        await callApi(
                            `https://api.trakt.tv/scrobble/pause`,
                            'POST',
                            payload
                        );
                    }
                )
                .catch((e) =>
                    console.error('Error on tab-close scrobble pause:', e)
                );
        }
        resetActiveScrobbleState();
    }
}

chrome.tabs.onRemoved.addListener((tabId) => handleTabCloseOrNavigate(tabId));
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (scrobbleState.current.tabId === tabId && changeInfo.url && tab.url) {
        if (
            scrobbleState.current.previousScrobbledUrl &&
            new URL(scrobbleState.current.previousScrobbledUrl).pathname !==
                new URL(tab.url).pathname
        ) {
            handleTabCloseOrNavigate(tabId);
        }
    }
});

// Initialize services when background script starts
console.log('üöÄ Background script starting, initializing services...');
initializeServices();
console.log('‚úÖ Services initialized in background script');

// Initialize service status manager after services are ready
serviceStatusManager
    .initializeServiceStatuses()
    .then(() => {
        console.log('‚úÖ Service status manager initialized');
    })
    .catch((error) => {
        console.error('‚ùå Failed to initialize service status manager:', error);
    });
</file>

<file path="src/options/index.tsx">
import React, { useEffect } from 'react';
import { createRoot } from 'react-dom/client';
import '../styles/index.css';
import { ErrorBoundary } from '../components/ErrorBoundary';
import { AuthenticationHub } from '../components/AuthenticationHub';
import { ServiceControlPanel } from '../components/ServiceControlPanel';
import { useMultiServiceAuth } from '../hooks/useMultiServiceAuth';
import { useQuickLinkPreferences } from '../hooks/useQuickLinkPreferences';
import { UserQuickLinkPrefs } from '../hooks/useQuickLinkPreferences';
import { initializeServices } from '../services';

export type { UserQuickLinkPrefs };

const Options: React.FC = () => {
    // Initialize services on component mount
    useEffect(() => {
        try {
            console.log('Initializing services...');
            initializeServices();
            console.log('Services initialized successfully');
        } catch (error) {
            console.error('Error initializing services:', error);
        }
    }, []);

    const { hasAnyAuthenticated, isServicesInitialized } =
        useMultiServiceAuth();
    const {
        prefs,
        isLoading: isLoadingPrefs,
        searchTerm,
        setSearchTerm,
        filteredSites,
        toggleSite,
        moveSite
    } = useQuickLinkPreferences(hasAnyAuthenticated && isServicesInitialized);

    return (
        <div className="bg-(--color-background) text-(--color-text-primary) min-h-screen">
            <div className="p-6 max-w-4xl mx-auto mt-10 space-y-8">
                <div className="bg-(--color-surface-1) rounded-lg shadow-md p-6">
                    <h1 className="text-2xl font-bold text-center mb-6 text-(--color-text-primary)">
                        TMSync Options
                    </h1>

                    {/* Authentication Hub */}
                    <AuthenticationHub />
                </div>

                {/* Service Control Panel */}
                {isServicesInitialized && <ServiceControlPanel />}

                {hasAnyAuthenticated && isServicesInitialized && (
                    <div className="bg-(--color-surface-1) rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4 text-(--color-text-primary)">
                            Quick Links on Trakt.tv
                        </h2>
                        {isLoadingPrefs ? (
                            <p>Loading preferences...</p>
                        ) : (
                            <>
                                <input
                                    type="text"
                                    placeholder="Search sites..."
                                    className="w-full p-2 border border-(--color-border) rounded mb-4 bg-(--color-background) text-(--color-text-primary) focus:ring-2 focus:ring-(--color-accent-primary) focus:outline-none"
                                    value={searchTerm}
                                    onChange={(e) =>
                                        setSearchTerm(e.target.value)
                                    }
                                />
                                <ul className="space-y-2">
                                    {filteredSites.map((site, index, arr) => (
                                        <li
                                            key={site.key}
                                            className="flex items-center justify-between p-3 bg-(--color-surface-2) rounded-md shadow-sm"
                                        >
                                            <div className="flex items-center">
                                                <img
                                                    src={site.logo}
                                                    alt={site.name}
                                                    className="w-5 h-5 mr-3 object-contain"
                                                />
                                                <span className="text-(--color-text-primary)">
                                                    {site.name}
                                                </span>
                                            </div>
                                            <div className="flex items-center space-x-2">
                                                <button
                                                    onClick={() =>
                                                        moveSite(site.key, 'up')
                                                    }
                                                    disabled={
                                                        prefs[site.key]
                                                            ?.order === 0
                                                    }
                                                    className="text-xs p-1 disabled:opacity-50"
                                                >
                                                    ‚¨ÜÔ∏è
                                                </button>
                                                <button
                                                    onClick={() =>
                                                        moveSite(
                                                            site.key,
                                                            'down'
                                                        )
                                                    }
                                                    disabled={
                                                        prefs[site.key]
                                                            ?.order ===
                                                        arr.length - 1
                                                    }
                                                    className="text-xs p-1 disabled:opacity-50"
                                                >
                                                    ‚¨áÔ∏è
                                                </button>
                                                <button
                                                    onClick={() =>
                                                        toggleSite(site.key)
                                                    }
                                                    className={`w-12 h-6 rounded-full p-1 transition-colors duration-200 ease-in-out focus:outline-none
                                                    ${prefs[site.key]?.enabled ? 'bg-(--color-accent-primary)' : 'bg-(--color-surface-3)'}`}
                                                >
                                                    <span
                                                        className={`block w-4 h-4 rounded-full bg-white shadow transform transition-transform duration-200 ease-in-out
                                                        ${prefs[site.key]?.enabled ? 'translate-x-6' : 'translate-x-0'}`}
                                                    />
                                                </button>
                                            </div>
                                        </li>
                                    ))}
                                </ul>
                            </>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
};

const container = document.getElementById('root');
if (container) {
    const root = createRoot(container);
    root.render(
        <ErrorBoundary>
            <Options />
        </ErrorBoundary>
    );
} else {
    console.error("Target container 'root' not found for Options page.");
}
</file>

<file path="src/types/messaging.ts">
// Defines the request/response protocol between different parts of the extension.

import {
    MediaInfoResponse,
    MediaRatings,
    SeasonEpisodeObj,
    ShowMediaInfo,
    MovieMediaInfo,
    CommentableType
} from './media';
import { WatchStatusInfo } from './scrobbling';
import { TraktShowWatchedProgress, TraktComment } from './trakt';
import { ServiceProgressInfo, ServiceMediaRatings } from './serviceTypes';

// --- Payloads ---
export interface MediaStatusPayload {
    mediaInfo: MediaInfoResponse | null;
    originalQuery: { type: string; query: string; years: string };
    confidence: 'high' | 'low';
    watchStatus?: WatchStatusInfo;
    progressInfo?: ServiceProgressInfo | null;
    ratingInfo?: ServiceMediaRatings;
}

// --- Requests ---
export interface RequestScrobbleStartParams {
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
    progress: number;
}
export interface RequestScrobblePauseParams {
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
    progress: number;
}
export interface RequestScrobbleStopParams {
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
    progress: number;
}
export interface RequestManualAddToHistoryParams {
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
}
export interface MediaInfoRequestParams {
    type: string;
    query: string;
    years: string;
}
export interface ManualSearchParams {
    type: string;
    query: string;
}
export interface UndoScrobbleParams {
    historyId?: number; // Legacy field for backwards compatibility
    serviceHistoryIds?: { [serviceType: string]: number | string };
}
export interface RateMovieParams {
    mediaInfo: MovieMediaInfo;
    rating: number;
}
export interface RateShowParams {
    mediaInfo: ShowMediaInfo;
    rating: number;
}
export interface RateSeasonParams {
    mediaInfo: ShowMediaInfo;
    episodeInfo: SeasonEpisodeObj;
    rating: number;
}
export interface RateEpisodeParams {
    mediaInfo: ShowMediaInfo;
    episodeInfo: SeasonEpisodeObj;
    rating: number;
}
export interface UnrateMovieParams {
    mediaInfo: MovieMediaInfo;
}
export interface UnrateShowParams {
    mediaInfo: ShowMediaInfo;
}
export interface UnrateSeasonParams {
    mediaInfo: ShowMediaInfo;
    episodeInfo: SeasonEpisodeObj;
}
export interface UnrateEpisodeParams {
    mediaInfo: ShowMediaInfo;
    episodeInfo: SeasonEpisodeObj;
}
export interface GetCommentsParams {
    type: CommentableType;
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
}
export interface PostCommentParams {
    type: CommentableType;
    mediaInfo: MediaInfoResponse;
    episodeInfo?: SeasonEpisodeObj;
    comment: string;
    spoiler: boolean;
}
export interface UpdateCommentParams {
    commentId: number | string;
    comment: string;
    spoiler: boolean;
}
export interface DeleteCommentParams {
    commentId: number | string;
}

export interface UpdateServiceAuthParams {
    serviceType: string;
}

export type MessageRequest =
    | { action: 'mediaInfo'; params: MediaInfoRequestParams }
    | { action: 'manualSearch'; params: ManualSearchParams }
    | { action: 'confirmMedia'; params: MediaInfoResponse }
    | { action: 'requestScrobbleStart'; params: RequestScrobbleStartParams }
    | { action: 'requestScrobblePause'; params: RequestScrobblePauseParams }
    | { action: 'requestScrobbleStop'; params: RequestScrobbleStopParams }
    | {
          action: 'requestManualAddToHistory';
          params: RequestManualAddToHistoryParams;
      }
    | { action: 'undoScrobble'; params: UndoScrobbleParams }
    | { action: 'rateMovie'; params: RateMovieParams }
    | { action: 'rateShow'; params: RateShowParams }
    | { action: 'rateSeason'; params: RateSeasonParams }
    | { action: 'rateEpisode'; params: RateEpisodeParams }
    | { action: 'unrateMovie'; params: UnrateMovieParams }
    | { action: 'unrateShow'; params: UnrateShowParams }
    | { action: 'unrateSeason'; params: UnrateSeasonParams }
    | { action: 'unrateEpisode'; params: UnrateEpisodeParams }
    | { action: 'getComments'; params: GetCommentsParams }
    | { action: 'postComment'; params: PostCommentParams }
    | { action: 'updateComment'; params: UpdateCommentParams }
    | { action: 'deleteComment'; params: DeleteCommentParams }
    | {
          action: 'updateServiceAuthentication';
          params: UpdateServiceAuthParams;
      };

// --- Responses ---
export interface MessageResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}

export interface ScrobbleResponse {
    traktHistoryId: number;
}

export type MediaInfoMessageResponse = MessageResponse<MediaStatusPayload>;
</file>

<file path="src/utils/siteConfigs/index.ts">
import { SiteConfigBase } from './baseConfig';
import { cinebyConfig } from './cineby';
import { freekConfig } from './freek';
import { hexaWatchConfig } from './hexa';
import { hydraConfig } from './hydra';
import { xprimeTvConfig } from './xprime';

export type SiteConfigMap = Record<string, SiteConfigBase>;

export const siteConfigs: SiteConfigMap = {
    'www.cineby.app': cinebyConfig,
    'freek.to': freekConfig,
    'hydrahd.me': hydraConfig,
    'hydrahd.ac': hydraConfig,
    'hexa.watch': hexaWatchConfig,
    'xprime.tv': xprimeTvConfig
};

export const getCurrentSiteConfig = (hostname: string) => {
    return siteConfigs[hostname] || null;
};
</file>

<file path="src/background/handlers/handleHistory.ts">
import {
    RequestManualAddToHistoryParams,
    ScrobbleResponse
} from '../../types/messaging';
import { serviceRegistry } from '../../services/ServiceRegistry';
import { filterEnabledAuthenticatedServices } from '../../utils/serviceFiltering';

export async function handleManualAddToHistory(
    params: RequestManualAddToHistoryParams
): Promise<ScrobbleResponse> {
    const allHistoryServices =
        serviceRegistry.getServicesWithCapability('supportsHistory');
    const historyServices =
        await filterEnabledAuthenticatedServices(allHistoryServices);

    // Use primary service for history response (return the first successful result)
    for (const service of historyServices) {
        try {
            const result = await service.addToHistory(
                params.mediaInfo,
                params.episodeInfo || null
            );
            const historyId =
                typeof result.historyId === 'string'
                    ? parseInt(result.historyId, 10)
                    : result.historyId!;
            return { traktHistoryId: historyId };
        } catch (error) {
            console.error(
                `Failed to add to history on ${service.getCapabilities().serviceType}:`,
                error
            );
        }
    }

    throw new Error('No available services to add to history');
}

export async function handleUndoScrobble(params: {
    historyId?: number;
    serviceHistoryIds?: { [serviceType: string]: number | string };
}): Promise<void> {
    const allHistoryServices =
        serviceRegistry.getServicesWithCapability('supportsHistory');
    const historyServices =
        await filterEnabledAuthenticatedServices(allHistoryServices);

    console.log('üîÑ Attempting to undo scrobble...');

    if (params.serviceHistoryIds) {
        console.log(
            'üìã Using service-specific history IDs:',
            params.serviceHistoryIds
        );

        // Use service-specific IDs for targeted removal
        for (const service of historyServices) {
            const serviceType = service.getCapabilities().serviceType;
            const serviceHistoryId = params.serviceHistoryIds[serviceType];

            if (serviceHistoryId) {
                try {
                    console.log(
                        `üóëÔ∏è Removing from ${serviceType} with ID: ${serviceHistoryId}`
                    );
                    await service.removeFromHistory(serviceHistoryId);
                    console.log(`‚úÖ Successfully removed from ${serviceType}`);
                } catch (error) {
                    console.error(
                        `‚ùå Failed to remove from history on ${serviceType}:`,
                        error
                    );
                }
            } else {
                console.log(
                    `‚ö†Ô∏è No history ID found for ${serviceType}, skipping`
                );
            }
        }
    } else if (params.historyId) {
        // Legacy fallback - try to use single ID for all services
        console.log(`‚ö†Ô∏è Using legacy single history ID: ${params.historyId}`);

        for (const service of historyServices) {
            const serviceType = service.getCapabilities().serviceType;
            try {
                console.log(
                    `üóëÔ∏è Attempting to remove from ${serviceType} with ID: ${params.historyId}`
                );
                await service.removeFromHistory(params.historyId);
                console.log(`‚úÖ Successfully removed from ${serviceType}`);
            } catch (error) {
                console.error(
                    `‚ùå Failed to remove from history on ${serviceType}:`,
                    error
                );
                // Don't fail the entire undo operation if one service fails
                // This is especially important since Trakt and AniList have different ID systems
            }
        }
    } else {
        throw new Error('No history IDs provided for undo operation');
    }
}
</file>

<file path="src/content-scripts/main/components/ScrobbleNotification.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { isMovieMediaInfo, isShowMediaInfo } from '../../../utils/typeGuards';
import {
    ActiveScrobbleStatus,
    ScrobbleNotificationMediaType
} from '../../../types/scrobbling';
import { CommentableType, MediaRatings } from '../../../types/media';
import { useServiceStatus } from '../../../hooks/useServiceStatus';
import {
    ServiceStatus,
    ServiceActivityState
} from '../../../types/serviceStatus';

const ServiceStatusBadge: React.FC<{
    status: ServiceStatus;
    isEffectivelyScrobbled: boolean;
}> = ({ status, isEffectivelyScrobbled }) => {
    const getStatusIcon = (state: ServiceActivityState): string => {
        switch (state) {
            case 'scrobbling':
            case 'starting_scrobble':
            case 'pausing_scrobble':
            case 'stopping_scrobble':
                return 'üîµ';
            case 'tracking_progress':
                return 'üü£';
            case 'updating_progress':
                return 'üü£';
            case 'error':
                return 'üî¥';
            case 'idle':
                return status.isAuthenticated ? 'üü¢' : '‚ö™';
            case 'disabled':
                return '‚ö´';
            default:
                return '‚ö™';
        }
    };

    const getStatusText = (state: ServiceActivityState): string => {
        // Always check authentication first
        if (!status.isAuthenticated) {
            if (isEffectivelyScrobbled) {
                return 'Not logged in';
            }
            return 'Not logged in';
        }

        if (isEffectivelyScrobbled) {
            return 'Added to history';
        }

        switch (state) {
            case 'starting_scrobble':
                return 'Starting...';
            case 'scrobbling':
                return 'Scrobbling';
            case 'pausing_scrobble':
                return 'Pausing...';
            case 'paused':
                return 'Paused';
            case 'stopping_scrobble':
                return 'Stopping...';
            case 'tracking_progress':
                return 'Tracking progress';
            case 'updating_progress':
                return 'Updating...';
            case 'error':
                return 'Error';
            case 'idle':
                return 'Ready';
            case 'disabled':
                return 'Disabled';
            default:
                return 'Unknown';
        }
    };

    const getServiceName = (serviceType: string): string => {
        switch (serviceType) {
            case 'trakt':
                return 'Trakt';
            case 'anilist':
                return 'AniList';
            case 'myanimelist':
                return 'MAL';
            default:
                return (
                    serviceType.charAt(0).toUpperCase() + serviceType.slice(1)
                );
        }
    };

    const icon = getStatusIcon(status.activityState);
    const statusText = getStatusText(status.activityState);
    const serviceName = getServiceName(status.serviceType);

    return (
        <div className="flex items-center gap-1 text-xs">
            <span>{icon}</span>
            <span className="font-medium">{serviceName}:</span>
            <span className="text-(--color-text-secondary)">{statusText}</span>
        </div>
    );
};

const HalfStar: React.FC<{
    rating: number;
    currentValue: number;
    onLeftClick: () => void;
    onRightClick: () => void;
    onLeftHover: () => void;
    onRightHover: () => void;
    onMouseLeave: () => void;
    readOnly?: boolean;
}> = ({
    rating,
    currentValue,
    onLeftClick,
    onRightClick,
    onLeftHover,
    onRightHover,
    onMouseLeave,
    readOnly
}) => {
    const leftHalf = currentValue >= rating - 0.5;
    const rightHalf = currentValue >= rating;

    return (
        <div
            className="relative w-4 h-4 cursor-pointer"
            onMouseLeave={readOnly ? undefined : onMouseLeave}
        >
            <svg
                className="absolute inset-0 w-4 h-4 text-(--color-star-empty)"
                fill="currentColor"
                viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg"
            >
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>

            {/* Left half overlay */}
            {leftHalf && (
                <svg
                    className="absolute inset-0 w-4 h-4 text-(--color-star-filled)"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                    style={{ clipPath: 'inset(0 50% 0 0)' }}
                >
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                </svg>
            )}

            {/* Right half overlay */}
            {rightHalf && (
                <svg
                    className="absolute inset-0 w-4 h-4 text-(--color-star-filled)"
                    fill="currentColor"
                    viewBox="0 0 20 20"
                    style={{ clipPath: 'inset(0 0 0 50%)' }}
                >
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                </svg>
            )}

            {/* Invisible click areas */}
            {!readOnly && (
                <>
                    <div
                        className="absolute inset-0 w-1/2 h-full cursor-pointer"
                        onClick={onLeftClick}
                        onMouseEnter={onLeftHover}
                    />
                    <div
                        className="absolute inset-y-0 right-0 w-1/2 h-full cursor-pointer"
                        onClick={onRightClick}
                        onMouseEnter={onRightHover}
                    />
                </>
            )}
        </div>
    );
};

const StarRatingInput: React.FC<{
    label: string;
    currentRating: number | null;
    onRate: (rating: number) => void;
    isSubmitting: boolean;
    onCommentClick?: () => void;
}> = ({ label, currentRating, onRate, isSubmitting, onCommentClick }) => {
    const [hoverRating, setHoverRating] = useState(0);

    const displayRating = hoverRating || currentRating || 0;
    const currentHasDecimal =
        currentRating !== null && currentRating !== Math.round(currentRating);

    return (
        <div className="mt-2 pt-2 border-t border-(--color-border) first-of-type:border-t-0 first-of-type:pt-1 first-of-type:mt-1">
            <div className="flex justify-between items-center">
                <p className="text-xs text-(--color-text-secondary) mb-0.5 text-left">
                    {label}:
                </p>
                {onCommentClick && (
                    <button
                        onClick={onCommentClick}
                        className="text-xs text-(--color-accent-primary) hover:underline disabled:opacity-50"
                        disabled={isSubmitting}
                    >
                        Comment
                    </button>
                )}
            </div>
            <div
                className="flex justify-center items-center space-x-0.5"
                onMouseLeave={() => setHoverRating(0)}
            >
                {[...Array(10)].map((_, i) => {
                    const starNumber = i + 1;
                    return (
                        <HalfStar
                            key={starNumber}
                            rating={starNumber}
                            currentValue={displayRating}
                            onLeftClick={() => onRate(starNumber - 0.5)}
                            onRightClick={() => onRate(starNumber)}
                            onLeftHover={() => setHoverRating(starNumber - 0.5)}
                            onRightHover={() => setHoverRating(starNumber)}
                            onMouseLeave={() => {}}
                            readOnly={isSubmitting}
                        />
                    );
                })}
            </div>

            {/* Rating display and service info */}
            <div className="flex items-center justify-center mt-2 space-x-2">
                {currentRating && (
                    <span className="text-xs text-(--color-text-secondary)">
                        Current: {currentRating}
                    </span>
                )}
            </div>

            {currentHasDecimal && (
                <div className="mt-1 text-center text-xs text-(--color-text-secondary)">
                    AniList: {currentRating} ‚Ä¢ Trakt:{' '}
                    {Math.round(currentRating)}
                </div>
            )}
        </div>
    );
};

interface ScrobbleNotificationProps {
    mediaInfo: ScrobbleNotificationMediaType;
    isEffectivelyScrobbled: boolean;
    traktHistoryId: number | null;
    liveScrobbleStatus: ActiveScrobbleStatus;
    onManualScrobble: () => Promise<void>;
    onUndoScrobble: () => Promise<void>;
    isProcessingAction: boolean;
    ratings: MediaRatings | null;
    onRate: (type: CommentableType, rating: number) => void;
    onUnrate: (type: CommentableType) => void;
    onOpenCommentModal: (type: CommentableType) => void;
}

export const ScrobbleNotification: React.FC<ScrobbleNotificationProps> = ({
    mediaInfo,
    isEffectivelyScrobbled,
    traktHistoryId,
    liveScrobbleStatus,
    onManualScrobble,
    onUndoScrobble,
    isProcessingAction,
    ratings,
    onRate,
    onUnrate,
    onOpenCommentModal
}) => {
    const [isExpanded, setIsExpanded] = useState<boolean>(false);
    const initialExpandDoneRef = useRef(false);
    const { serviceStatuses, isLoading: isLoadingServiceStatus } =
        useServiceStatus();

    useEffect(() => {
        if (isEffectivelyScrobbled && !initialExpandDoneRef.current) {
            setIsExpanded(true);
            const timer = setTimeout(() => setIsExpanded(false), 7000);
            initialExpandDoneRef.current = true;
            return () => clearTimeout(timer);
        }
        if (!isEffectivelyScrobbled) {
            initialExpandDoneRef.current = false;
        }
    }, [isEffectivelyScrobbled]);

    const handleRatingClick = async (
        type: CommentableType,
        ratingValue: number
    ) => {
        if (isProcessingAction) return;

        // Check if user is clicking the same rating they already have
        let currentUserRating: number | null = null;

        if (type === 'movie' && isMovieMediaInfo(mediaInfo)) {
            currentUserRating = ratings?.show?.userRating ?? null;
        } else if (type === 'show') {
            currentUserRating = ratings?.show?.userRating ?? null;
        } else if (type === 'season') {
            currentUserRating = ratings?.season?.userRating ?? null;
        } else if (type === 'episode') {
            currentUserRating = ratings?.episode?.userRating ?? null;
        }

        // If user clicks the same rating, unrate instead
        if (currentUserRating !== null && currentUserRating === ratingValue) {
            await onUnrate(type);
        } else {
            await onRate(type, ratingValue);
        }
    };

    const getMediaTitle = (): string => {
        if (isMovieMediaInfo(mediaInfo)) return mediaInfo.movie.title;
        if (isShowMediaInfo(mediaInfo)) return mediaInfo.show.title;
        return 'Unknown Title';
    };

    const getMediaYear = (): number | undefined => {
        if (isMovieMediaInfo(mediaInfo)) return mediaInfo.movie.year;
        if (isShowMediaInfo(mediaInfo)) return mediaInfo.show.year;
        return undefined;
    };

    const title = getMediaTitle();
    const year = getMediaYear();
    const isShow = isShowMediaInfo(mediaInfo);
    const season =
        isShow && 'season' in mediaInfo ? mediaInfo.season : undefined;
    const episode =
        isShow && 'number' in mediaInfo ? mediaInfo.number : undefined;

    const containerClasses = `fixed bottom-0 left-1/2 -translate-x-1/2 z-[999999999] transition-all duration-250 ease-in-out pointer-events-none`;
    const contentWrapperClasses = `bg-(--color-surface-1) w-72 text-base text-center overflow-hidden shadow-lg rounded-t-md transition-[max-height] duration-250 ease-in-out ${isExpanded ? 'max-h-[500px]' : 'max-h-2 hover:max-h-[500px]'} pointer-events-auto`;

    return (
        <div className={containerClasses}>
            <div
                className={contentWrapperClasses}
                onMouseEnter={() => setIsExpanded(true)}
                onMouseLeave={() => setIsExpanded(false)}
            >
                <div className="py-2 px-3">
                    {/* Service Status Indicators */}
                    {!isLoadingServiceStatus && serviceStatuses.length > 0 && (
                        <div className="flex flex-col gap-1 mb-2">
                            {serviceStatuses.map((serviceStatus) => (
                                <ServiceStatusBadge
                                    key={serviceStatus.serviceType}
                                    status={serviceStatus}
                                    isEffectivelyScrobbled={
                                        isEffectivelyScrobbled
                                    }
                                />
                            ))}
                        </div>
                    )}
                    <p className="text-(--color-text-primary) text-sm m-0 p-0 truncate">
                        {title} {year && `(${year})`}
                    </p>
                    {isShow &&
                        season !== undefined &&
                        episode !== undefined && (
                            <p className="text-(--color-text-secondary) text-xs m-0 p-0">
                                S{String(season).padStart(2, '0')} E
                                {String(episode).padStart(2, '0')}
                            </p>
                        )}

                    {(isExpanded || isEffectivelyScrobbled) && (
                        <>
                            {isMovieMediaInfo(mediaInfo) && (
                                <StarRatingInput
                                    label="Movie Rating"
                                    currentRating={
                                        ratings?.show?.userRating ?? null
                                    }
                                    onRate={(r) =>
                                        handleRatingClick('movie', r)
                                    }
                                    isSubmitting={isProcessingAction}
                                    onCommentClick={() =>
                                        onOpenCommentModal('movie')
                                    }
                                />
                            )}

                            {isShowMediaInfo(mediaInfo) &&
                                episode !== undefined && (
                                    <StarRatingInput
                                        label="Episode Rating"
                                        currentRating={
                                            ratings?.episode?.userRating ?? null
                                        }
                                        onRate={(r) =>
                                            handleRatingClick('episode', r)
                                        }
                                        isSubmitting={isProcessingAction}
                                        onCommentClick={() =>
                                            onOpenCommentModal('episode')
                                        }
                                    />
                                )}

                            {isShowMediaInfo(mediaInfo) &&
                                season !== undefined && (
                                    <StarRatingInput
                                        label="Season Rating"
                                        currentRating={
                                            ratings?.season?.userRating ?? null
                                        }
                                        onRate={(r) =>
                                            handleRatingClick('season', r)
                                        }
                                        isSubmitting={isProcessingAction}
                                        onCommentClick={() =>
                                            onOpenCommentModal('season')
                                        }
                                    />
                                )}

                            {isShowMediaInfo(mediaInfo) && (
                                <StarRatingInput
                                    label="Show Rating"
                                    currentRating={
                                        ratings?.show?.userRating ?? null
                                    }
                                    onRate={(r) => handleRatingClick('show', r)}
                                    isSubmitting={isProcessingAction}
                                    onCommentClick={() =>
                                        onOpenCommentModal('show')
                                    }
                                />
                            )}

                            <div className="mt-2 border-t border-(--color-border) pt-2">
                                {isEffectivelyScrobbled ? (
                                    <button
                                        className="text-(--color-danger) px-2 py-1 rounded border-none cursor-pointer text-xs hover:underline disabled:opacity-50 disabled:cursor-not-allowed"
                                        onClick={onUndoScrobble}
                                        disabled={
                                            isProcessingAction ||
                                            !traktHistoryId
                                        }
                                    >
                                        Undo History Add?
                                    </button>
                                ) : (
                                    liveScrobbleStatus === 'idle' && (
                                        <button
                                            className="text-(--color-accent-primary) w-full px-2 py-1 rounded border-none cursor-pointer my-1 text-sm hover:bg-(--color-surface-2) disabled:opacity-70 disabled:cursor-wait flex items-center justify-center"
                                            onClick={onManualScrobble}
                                            disabled={isProcessingAction}
                                        >
                                            {isProcessingAction
                                                ? 'Processing...'
                                                : 'Manually Add to History'}
                                        </button>
                                    )
                                )}
                            </div>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
};
</file>

<file path="src/utils/siteConfigs/hexa.ts">
import { TraktPageInfo } from '../../content-scripts/trakt';
import { createSiteConfig, SiteConfigBase } from './baseConfig';

export const hexaWatchConfig: SiteConfigBase = createSiteConfig({
    name: 'Hexa Watch',
    selectorType: 'css',
    usesTmdbId: true,
    tmdbIdUrlPatterns: {
        movie: /\/(details|watch)\/movie\/\d+$/,
        show: /\/(details|watch)\/tv\/\d+$/
    },

    urlPatterns: {
        movie: /\/(details|watch)\/movie\/\d+/,
        show: /\/(details|watch)\/tv\/\d+/
    },
    selectors: {
        movie: { title: '', year: '' },
        show: { title: '', year: '' }
    },
    highlighting: {
        getCurrentHighlightContextKey: (url: string): string | null => {
            const path = new URL(url).pathname;
            if (/\/details\/tv\/\d+/.test(path)) return 'detailPageEpisodes';
            if (/\/watch\/tv\/\d+(\/\d+\/\d+)?/.test(path))
                return 'watchPageMenuEpisodes';
            return null;
        },
        contexts: {
            detailPageEpisodes: {
                containerSelector: 'div',
                itemSelector: 'a[href*="/watch/tv/"]',
                getSeasonEpisodeFromElement: (
                    itemElement: Element
                ): { season: number; episode: number } | null => {
                    const anchor = itemElement as HTMLAnchorElement;
                    const hrefMatch = anchor.href.match(
                        /\/watch\/tv\/\d+\/(\d+)\/(\d+)/
                    );
                    if (hrefMatch) {
                        return {
                            season: parseInt(hrefMatch[1], 10),
                            episode: parseInt(hrefMatch[2], 10)
                        };
                    }
                    return null;
                },
                getElementToStyle: (
                    itemElement: Element
                ): HTMLElement | null => {
                    return itemElement.closest(
                        'div.group'
                    ) as HTMLElement | null;
                }
            },
            watchPageMenuEpisodes: {
                containerSelector:
                    'div.absolute.bottom-full div[class*="bg-[#0A0A0A]/95"]',
                itemSelector: 'button[data-episode-id]',
                getSeasonEpisodeFromElement: (
                    itemElement: Element
                ): { season: number; episode: number } | null => {
                    const button = itemElement as HTMLButtonElement;
                    const episodeId = button.dataset.episodeId;
                    const match = episodeId?.match(/s(\d+)e(\d+)/);
                    if (match) {
                        return {
                            season: parseInt(match[1], 10),
                            episode: parseInt(match[2], 10)
                        };
                    }
                    return null;
                },
                getElementToStyle: (
                    itemElement: Element
                ): HTMLElement | null => {
                    return itemElement as HTMLElement;
                }
            }
        }
    },
    generateWatchLink: (pageInfo: TraktPageInfo): string | null => {
        if (!pageInfo.tmdbId) return null;
        if (pageInfo.type === 'show') {
            if (
                pageInfo.season !== undefined &&
                pageInfo.episode !== undefined
            ) {
                return `https://hexa.watch/watch/tv/${pageInfo.tmdbId}/${pageInfo.season}/${pageInfo.episode}`;
            }
            return `https://hexa.watch/details/tv/${pageInfo.tmdbId}`;
        } else if (pageInfo.type === 'movie') {
            return `https://hexa.watch/watch/movie/${pageInfo.tmdbId}`;
        }
        return null;
    }
});

hexaWatchConfig.getTmdbId = function (url: string): string | null {
    const match = url.match(/\/(?:details|watch)\/(?:movie|tv)\/(\d+)/);
    return match ? match[1] : null;
};

hexaWatchConfig.getSeasonEpisodeObj = function (
    url: string
): { season: number; number: number } | null {
    const match = url.match(/\/watch\/tv\/\d+\/(\d+)\/(\d+)/);
    console.log('match', url, match);

    if (match && match[1] && match[2]) {
        const season = parseInt(match[1], 10);
        const episode = parseInt(match[2], 10);

        if (!isNaN(season) && season > 0 && !isNaN(episode) && episode > 0) {
            return { season: season, number: episode };
        }
    }

    return null;
};
</file>

<file path="src/utils/siteConfigs/xprime.ts">
import { TraktPageInfo } from '../../content-scripts/trakt';
import { createSiteConfig, SiteConfigBase } from './baseConfig';

export const xprimeTvConfig: SiteConfigBase = createSiteConfig({
    name: 'XPrimeTV',
    selectorType: 'css',
    usesTmdbId: true,

    tmdbIdUrlPatterns: {
        movie: /\/watch\/\d+$/,
        show: /\/watch\/\d+\/\d+\/\d+$/
    },
    urlPatterns: {
        movie: /\/watch\/\d+$/,
        show: /\/watch\/\d+\/\d+\/\d+$/
    },

    selectors: {
        movie: { title: '', year: '' },
        show: { title: '', year: '' }
    },
    usesIframePlayer: false,
    highlighting: {
        getCurrentHighlightContextKey: (url: string): string | null => {
            const path = new URL(url).pathname;
            if (/\/watch\/\d+(\/\d+\/\d+)?/.test(path))
                return 'watchPageMenuEpisodes';
            return null;
        },
        contexts: {
            watchPageMenuEpisodes: {
                containerSelector: 'div.episodes-box.visible',
                itemSelector: 'button.episodebox-item',
                getSeasonEpisodeFromElement: (
                    itemElement: Element,
                    containerElement: Element
                ): { season: number; episode: number } | null => {
                    const button = itemElement as HTMLButtonElement;
                    const episodeNumberText = button
                        .querySelector('.episode-number')
                        ?.textContent?.trim();

                    if (!episodeNumberText) return null;
                    const episode = parseInt(episodeNumberText, 10);
                    if (isNaN(episode)) return null;

                    let season: number | null = null;

                    const seasonHeader = containerElement.querySelector(
                        '.episodesbox-header > h3'
                    );
                    if (seasonHeader && seasonHeader.textContent) {
                        const seasonMatch =
                            seasonHeader.textContent.match(/Season\s*(\d+)/i);
                        if (seasonMatch && seasonMatch[1]) {
                            season = parseInt(seasonMatch[1], 10);
                        }
                    }

                    if (season === null || isNaN(season)) {
                        console.warn(
                            'Could not parse season number from container:',
                            containerElement
                        );
                        return null;
                    }

                    return { season, episode };
                },
                getElementToStyle: (
                    itemElement: Element
                ): HTMLElement | null => {
                    return itemElement as HTMLElement;
                }
            }
        }
    },
    generateWatchLink: (pageInfo: TraktPageInfo): string | null => {
        if (!pageInfo.tmdbId) return null;
        if (pageInfo.type === 'show') {
            if (
                pageInfo.season !== undefined &&
                pageInfo.episode !== undefined
            ) {
                return `https://xprime.tv/watch/${pageInfo.tmdbId}/${pageInfo.season}/${pageInfo.episode}`;
            }
            return `https://xprime.tv/watch/${pageInfo.tmdbId}`;
        } else if (pageInfo.type === 'movie') {
            return `https://xprime.tv/watch/${pageInfo.tmdbId}`;
        }
        return null;
    }
});

xprimeTvConfig.getTmdbId = function (url: string): string | null {
    const match = url.match(/\/watch\/(\d+)/);
    console.log(url, match);
    return match ? match[1] : null;
};

xprimeTvConfig.getSeasonEpisodeObj = function (
    url: string
): { season: number; number: number } | null {
    const match = url.match(/\/watch\/\d+\/(\d+)\/(\d+)/);
    if (match && match[1] && match[2]) {
        const season = parseInt(match[1], 10);
        const episode = parseInt(match[2], 10);
        if (!isNaN(season) && season >= 0 && !isNaN(episode) && episode >= 0) {
            return { season: season, number: episode };
        }
    }
    return null;
};
</file>

<file path="src/background/handlers/handleScrobble.ts">
import {
    RequestScrobblePauseParams,
    RequestScrobbleStartParams,
    RequestScrobbleStopParams
} from '../../types/messaging';
import { ScrobbleStopResponseData } from '../../types/scrobbling';
import { traktService } from '../../services/TraktService';
import { serviceRegistry } from '../../services/ServiceRegistry';
import { serviceStatusManager } from '../serviceStatusManager';
import { scrobbleState, resetActiveScrobbleState } from '../state';
import { filterEnabledAuthenticatedServices } from '../../utils/serviceFiltering';
import { isServiceEnabled } from '../../utils/servicePreferences';

export async function handleScrobbleStart(
    params: RequestScrobbleStartParams,
    sender: chrome.runtime.MessageSender
): Promise<void> {
    if (!sender.tab?.id) throw new Error('Tab ID missing for scrobble start');
    const tabId = sender.tab.id;

    console.log(
        'üé¨ Starting scrobble for:',
        params.mediaInfo.type,
        params.mediaInfo
    );

    // Get services that support real-time scrobbling (filtered by user preferences + auth)
    const allRealTimeServices = serviceRegistry.getServicesWithCapability(
        'supportsRealTimeScrobbling'
    );
    const realTimeScrobblingServices =
        await filterEnabledAuthenticatedServices(allRealTimeServices);

    // Get services that support progress tracking (currently unused but ready for future implementation)
    // const progressTrackingServices = serviceRegistry.getServicesWithCapability('supportsProgressTracking');

    console.log('üìä Services available:');
    console.log(
        '- Real-time scrobbling services:',
        realTimeScrobblingServices.length
    );
    // console.log('- Progress tracking services:', progressTrackingServices.length);

    // Get all services for status updates
    const allServices = serviceRegistry.getAllServices();

    // Update status for different service types (handle async properly)
    for (const service of allServices) {
        const serviceType = service.getCapabilities().serviceType;
        const capabilities = service.getCapabilities();

        // Check if service is enabled by user preference
        const userEnabled = await isServiceEnabled(serviceType);
        if (!userEnabled) {
            serviceStatusManager.updateServiceActivity(serviceType, 'disabled');
            continue;
        }

        if (capabilities.supportsRealTimeScrobbling) {
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'starting_scrobble'
            );
        } else if (capabilities.supportsProgressTracking) {
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'tracking_progress'
            );
        } else {
            serviceStatusManager.updateServiceActivity(serviceType, 'idle');
        }
    }

    // If there's an active scrobble on a different tab, pause it first
    if (
        scrobbleState.current.tabId &&
        scrobbleState.current.tabId !== tabId &&
        scrobbleState.current.status === 'started'
    ) {
        // Use primary real-time scrobbling service for legacy state management
        const primaryScrobblingService =
            realTimeScrobblingServices[0] || traktService;
        await primaryScrobblingService.pauseScrobble(
            scrobbleState.current.mediaInfo!,
            scrobbleState.current.episodeInfo || null,
            scrobbleState.current.currentProgress
        );
    }

    // Start real-time scrobble on services that support it
    console.log('üöÄ Starting real-time scrobbles...');
    for (const service of realTimeScrobblingServices) {
        const serviceType = service.getCapabilities().serviceType;
        console.log(`üì° Starting scrobble on ${serviceType}...`);
        try {
            await service.startScrobble(
                params.mediaInfo,
                params.episodeInfo || null,
                params.progress
            );
            console.log(`‚úÖ Successfully started scrobble on ${serviceType}`);
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'scrobbling'
            );
        } catch (error) {
            console.error(
                `‚ùå Failed to start scrobble on ${serviceType}:`,
                error
            );
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'error',
                error instanceof Error ? error.message : 'Scrobble start failed'
            );
        }
    }

    // Update the global scrobble state (keeping legacy structure for now)
    scrobbleState.current = {
        tabId: tabId,
        mediaInfo: params.mediaInfo,
        episodeInfo: params.episodeInfo,
        currentProgress: params.progress,
        status: 'started',
        traktMediaType: params.mediaInfo.type === 'movie' ? 'movie' : 'episode',
        lastUpdateTime: Date.now(),
        previousScrobbledUrl: sender.tab.url
    };
}

export async function handleScrobblePause(
    params: RequestScrobblePauseParams,
    sender: chrome.runtime.MessageSender
): Promise<void> {
    if (!sender.tab?.id) throw new Error('Tab ID missing for scrobble pause');
    if (
        scrobbleState.current.tabId !== sender.tab.id ||
        scrobbleState.current.status !== 'started'
    ) {
        throw new Error('Scrobble not active on this tab or not started.');
    }

    // Get services that support real-time scrobbling (filtered by user preferences + auth)
    const allRealTimeServices = serviceRegistry.getServicesWithCapability(
        'supportsRealTimeScrobbling'
    );
    const realTimeScrobblingServices =
        await filterEnabledAuthenticatedServices(allRealTimeServices);

    // Get services that support progress tracking (currently unused)
    // const progressTrackingServices = serviceRegistry.getServicesWithCapability('supportsProgressTracking');

    // Update status for all real-time services (including disabled ones)
    for (const service of allRealTimeServices) {
        const serviceType = service.getCapabilities().serviceType;
        const userEnabled = await isServiceEnabled(serviceType);

        if (!userEnabled) {
            serviceStatusManager.updateServiceActivity(serviceType, 'disabled');
        } else {
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'pausing_scrobble'
            );
        }
    }

    // Pause real-time scrobble on services that support it
    for (const service of realTimeScrobblingServices) {
        const serviceType = service.getCapabilities().serviceType;
        try {
            await service.pauseScrobble(
                params.mediaInfo,
                params.episodeInfo || null,
                params.progress
            );
            serviceStatusManager.updateServiceActivity(serviceType, 'paused');
        } catch (error) {
            console.error(`Failed to pause scrobble on ${serviceType}:`, error);
            serviceStatusManager.updateServiceActivity(
                serviceType,
                'error',
                error instanceof Error ? error.message : 'Scrobble pause failed'
            );
        }
    }

    // Update the global scrobble state
    scrobbleState.current.currentProgress = params.progress;
    scrobbleState.current.status = 'paused';
    scrobbleState.current.lastUpdateTime = Date.now();
}

export async function handleScrobbleStop(
    params: RequestScrobbleStopParams,
    sender: chrome.runtime.MessageSender
): Promise<ScrobbleStopResponseData> {
    if (!sender.tab?.id) throw new Error('Tab ID missing for scrobble stop');
    if (scrobbleState.current.tabId !== sender.tab.id) {
        throw new Error('Scrobble not active on this tab for stop.');
    }

    // Get services that support real-time scrobbling (filtered by user preferences + auth)
    const allRealTimeServices = serviceRegistry.getServicesWithCapability(
        'supportsRealTimeScrobbling'
    );
    const realTimeScrobblingServices =
        await filterEnabledAuthenticatedServices(allRealTimeServices);

    // Get services that support progress tracking (filtered by user preferences + auth)
    const allProgressTrackingServices =
        serviceRegistry.getServicesWithCapability('supportsProgressTracking');
    const progressTrackingServices = await filterEnabledAuthenticatedServices(
        allProgressTrackingServices
    );

    console.log('üéØ Processing stop with services:');
    console.log(
        '- Real-time scrobbling services:',
        realTimeScrobblingServices.length
    );
    console.log(
        '- Progress tracking services:',
        progressTrackingServices.length
    );

    // Use primary service for stop response (fallback to traktService for legacy compatibility)
    const primaryService = realTimeScrobblingServices[0] || traktService;
    const serviceResponse = await primaryService.stopScrobble(
        params.mediaInfo,
        params.episodeInfo || null,
        params.progress
    );

    // Collect service-specific history IDs
    const serviceHistoryIds: { [serviceType: string]: number | string } = {};

    // Add Trakt history ID if available
    if (serviceResponse.historyId) {
        const primaryServiceType = primaryService.getCapabilities().serviceType;
        serviceHistoryIds[primaryServiceType] = serviceResponse.historyId;
        console.log(
            `üíæ Stored ${primaryServiceType} history ID: ${serviceResponse.historyId}`
        );
    }

    // Process progress tracking services in parallel (for completion threshold)
    if (progressTrackingServices.length > 0) {
        console.log('üìä Processing progress tracking services...');

        // Process all progress tracking services concurrently
        const progressTrackingPromises = progressTrackingServices.map(
            async (service) => {
                const serviceType = service.getCapabilities().serviceType;
                try {
                    console.log(`üìà Adding to history on ${serviceType}...`);
                    const result = await service.addToHistory(
                        params.mediaInfo,
                        params.episodeInfo || null
                    );
                    console.log(
                        `‚úÖ Successfully added to history on ${serviceType}:`,
                        result
                    );

                    // Store service-specific history ID
                    if (result.historyId) {
                        serviceHistoryIds[serviceType] = result.historyId;
                        console.log(
                            `üíæ Stored ${serviceType} history ID: ${result.historyId}`
                        );
                    }

                    // Update service status to indicate successful tracking
                    serviceStatusManager.updateServiceActivity(
                        serviceType,
                        'idle'
                    );

                    return { serviceType, success: true, result };
                } catch (error) {
                    console.error(
                        `‚ùå Failed to add to history on ${serviceType}:`,
                        error
                    );
                    serviceStatusManager.updateServiceActivity(
                        serviceType,
                        'error',
                        error instanceof Error
                            ? error.message
                            : 'Progress tracking failed'
                    );
                    return { serviceType, success: false, error };
                }
            }
        );

        // Wait for all progress tracking operations to complete
        await Promise.allSettled(progressTrackingPromises);
    }

    // Reset the global scrobble state
    resetActiveScrobbleState();

    // Map ServiceScrobbleResponse to ScrobbleStopResponseData
    const responseData: ScrobbleStopResponseData = {
        action: serviceResponse.action,
        traktHistoryId:
            typeof serviceResponse.historyId === 'string'
                ? parseInt(serviceResponse.historyId, 10)
                : serviceResponse.historyId,
        serviceHistoryIds:
            Object.keys(serviceHistoryIds).length > 0
                ? serviceHistoryIds
                : undefined
    };

    console.log('üéØ Mapped scrobble stop response:', {
        serviceResponse,
        responseData
    });

    return responseData;
}
</file>

<file path="src/services/AniListService.ts">
import { TrackerService } from '../types/services';
import {
    ServiceType,
    ServiceComment,
    ServiceProgressInfo,
    ServiceMediaIds,
    ServiceMediaRatings,
    ServiceScrobbleResponse,
    ServiceCapabilities
} from '../types/serviceTypes';
import { MediaInfoResponse, SeasonEpisodeObj } from '../types/media';
import { WatchStatusInfo } from '../types/scrobbling';

/**
 * AniListService - Handles all AniList API interactions
 *
 * This service encapsulates authentication, media operations, scrobbling,
 * ratings, and user data management for AniList using GraphQL.
 */
export class AniListService implements TrackerService {
    private accessToken: string | null = null;
    private cachedUsername: string | null = null;

    // Configuration - would typically come from environment or config
    private readonly clientId = process.env.ANILIST_CLIENT_ID || '';
    private readonly apiEndpoint = 'https://graphql.anilist.co';

    /**
     * Get service capabilities and configuration
     */
    getCapabilities(): ServiceCapabilities {
        return {
            serviceType: 'anilist' as ServiceType,
            supportsRealTimeScrobbling: false, // AniList doesn't support real-time scrobbling
            supportsProgressTracking: true, // Episode progress tracking implemented
            supportsRatings: true, // Rating functionality implemented
            supportsComments: true, // AniList notes functionality implemented
            supportsHistory: true, // History add/remove implemented
            supportsSearch: true, // Search is implemented
            ratingScale: {
                min: 1,
                max: 10, // Our interface uses 1-10, converted to user's AniList format
                step: 1,
                serviceType: 'anilist'
            },
            authMethod: 'oauth',
            supportedMediaTypes: ['show', 'movie'], // AniList supports anime TV shows and movies
            rateLimits: {
                requestsPerMinute: 90,
                requestsPerHour: 90 * 60 // AniList rate limit is roughly 90 requests per minute
            }
        };
    }

    /**
     * Authentication Methods
     */

    /**
     * Check if user is currently authenticated with AniList
     */
    async isAuthenticated(): Promise<boolean> {
        try {
            const tokenData = await chrome.storage.local.get([
                'anilistAccessToken',
                'anilistTokenExpiresAt'
            ]);
            const storedToken = tokenData.anilistAccessToken;
            const expiresAt = tokenData.anilistTokenExpiresAt || 0;

            return !!(storedToken && Date.now() < expiresAt);
        } catch {
            return false;
        }
    }

    /**
     * Get current username for AniList
     */
    async getUsername(): Promise<string> {
        if (this.cachedUsername) return this.cachedUsername;

        const data = await chrome.storage.local.get('anilistUsername');
        if (data.anilistUsername) {
            this.cachedUsername = data.anilistUsername;
            return data.anilistUsername;
        }

        // Fetch username from AniList API
        const query = `
            query {
                Viewer {
                    name
                }
            }
        `;

        const response = await this.makeGraphQLRequest(query);
        const username = response.data?.Viewer?.name;

        if (username) {
            this.cachedUsername = username;
            await chrome.storage.local.set({ anilistUsername: username });
            return username;
        }

        throw new Error('Could not determine AniList username.');
    }

    /**
     * Initiate OAuth login flow for AniList using implicit grant
     */
    async login(): Promise<void> {
        // Use implicit grant flow - no redirect_uri needed for AniList
        const authUrl = `https://anilist.co/api/v2/oauth/authorize?client_id=${this.clientId}&response_type=token`;

        try {
            const redirectUrlResponse = await chrome.identity.launchWebAuthFlow(
                {
                    url: authUrl,
                    interactive: true
                }
            );

            if (chrome.runtime.lastError || !redirectUrlResponse) {
                throw new Error(
                    chrome.runtime.lastError?.message ||
                        'Authentication cancelled or failed.'
                );
            }

            // Parse the access token from the URL fragment (not query params)
            const url = new URL(redirectUrlResponse);
            const fragment = url.hash.substring(1); // Remove the '#'
            const params = new URLSearchParams(fragment);

            const accessToken = params.get('access_token');
            const expiresIn = params.get('expires_in');

            if (!accessToken) {
                throw new Error(
                    'Could not get access token from AniList redirect.'
                );
            }

            // AniList tokens are long-lived (1 year by default)
            const expiresAt = expiresIn
                ? Date.now() + parseInt(expiresIn) * 1000
                : Date.now() + 365 * 24 * 60 * 60 * 1000; // Default to 1 year

            await chrome.storage.local.set({
                anilistAccessToken: accessToken,
                anilistTokenExpiresAt: expiresAt
            });

            // Fetch and cache user info
            await this.getUsername();
        } catch (err) {
            console.error('Error during AniList login process:', err);
            throw err instanceof Error
                ? err
                : new Error('An unexpected error occurred during login.');
        }
    }

    /**
     * Logout and clear stored tokens
     */
    async logout(): Promise<void> {
        try {
            // AniList doesn't have a token revocation endpoint
            await chrome.storage.local.remove([
                'anilistAccessToken',
                'anilistTokenExpiresAt',
                'anilistUsername'
            ]);
            this.cachedUsername = null;
            this.accessToken = null;
        } catch (err) {
            console.error('Error during AniList logout:', err);
        }
    }

    /**
     * Media Search and Identification Methods
     */

    /**
     * Search for media by query and type
     */
    async searchMedia(
        query: string,
        type: 'movie' | 'show',
        years?: string
    ): Promise<MediaInfoResponse[]> {
        // Search both anime shows and movies
        const anilistType = type === 'movie' ? 'ANIME' : 'ANIME'; // AniList uses ANIME for both

        const searchQuery = `
            query ($search: String, $seasonYear: Int, $type: MediaType) {
                Page(page: 1, perPage: 10) {
                    media(search: $search, type: $type, seasonYear: $seasonYear) {
                        id
                        idMal
                        title {
                            romaji
                            english
                            native
                        }
                        episodes
                        seasonYear
                        format
                        status
                        description
                        coverImage {
                            large
                        }
                        externalLinks {
                            site
                            url
                        }
                    }
                }
            }
        `;

        const variables: any = {
            search: query,
            type: anilistType
        };
        if (years) {
            const year = parseInt(years);
            if (!isNaN(year)) {
                variables.seasonYear = year;
            }
        }

        const response = await this.makeGraphQLRequest(
            searchQuery,
            variables,
            false
        );
        const media = response.data?.Page?.media || [];

        // Convert AniList format to our MediaInfoResponse format
        return media.map((item: any) => this.convertAniListToMediaInfo(item));
    }

    /**
     * Get media info by TMDB ID
     */
    async getMediaByTmdbId(
        tmdbId: string,
        type: 'movie' | 'show'
    ): Promise<MediaInfoResponse | null> {
        // AniList doesn't directly support TMDB ID lookup
        // This would require a mapping service or external API
        // For now, return null as this feature isn't available
        return null;
    }

    /**
     * Get detailed media status including watch history and ratings
     */
    async getMediaStatus(mediaInfo: MediaInfoResponse): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }> {
        // Implementation would fetch user's list entry for this media
        throw new Error('getMediaStatus not yet implemented for AniList');
    }

    /**
     * Get media status with episode-specific ratings
     */
    async getMediaStatusWithEpisode(
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }> {
        // AniList doesn't have episode-specific ratings, only series-level
        return await this.getMediaStatus(mediaInfo);
    }

    /**
     * Scrobbling Methods (Progress Tracking)
     */

    /**
     * Start scrobbling media (update progress)
     */
    async startScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void> {
        // Implementation would update MediaList entry with current progress
        throw new Error('startScrobble not yet implemented for AniList');
    }

    /**
     * Pause scrobbling (no-op for AniList as it doesn't have real-time scrobbling)
     */
    async pauseScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void> {
        // AniList doesn't have pause state, so this is a no-op
    }

    /**
     * Stop scrobbling and update progress/status
     */
    async stopScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<ServiceScrobbleResponse> {
        // Implementation would update MediaList entry and determine if completed
        throw new Error('stopScrobble not yet implemented for AniList');
    }

    /**
     * History Management Methods
     */

    /**
     * Add media to watch history manually
     */
    async addToHistory(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null
    ): Promise<{ historyId?: number | string }> {
        // Check authentication by attempting to get the token from storage
        const tokenData = await chrome.storage.local.get([
            'anilistAccessToken'
        ]);
        if (!tokenData.anilistAccessToken) {
            throw new Error('Not authenticated with AniList');
        }

        // AniList supports both anime shows and movies

        // Search AniList directly for the media
        const mediaTitle =
            mediaInfo.type === 'movie'
                ? mediaInfo.movie.title
                : mediaInfo.show.title;
        const mediaYear =
            mediaInfo.type === 'movie'
                ? mediaInfo.movie.year
                : mediaInfo.show.year;

        const searchQuery = `
            query ($search: String, $seasonYear: Int) {
                Page(page: 1, perPage: 5) {
                    media(search: $search, type: ANIME, seasonYear: $seasonYear) {
                        id
                        episodes
                        title {
                            romaji
                            english
                        }
                    }
                }
            }
        `;

        const searchVariables: any = { search: mediaTitle };
        if (mediaYear) {
            searchVariables.seasonYear = mediaYear;
        }

        const searchResponse = await this.makeGraphQLRequest(
            searchQuery,
            searchVariables,
            false
        );
        const mediaList = searchResponse.data?.Page?.media || [];

        if (mediaList.length === 0) {
            throw new Error(`Could not find anime "${mediaTitle}" on AniList`);
        }

        // Use first result (could improve with better matching later)
        const anilistMedia = mediaList[0];
        const anilistId = anilistMedia.id;

        // Determine if this is completion or just progress update
        let episodeNumber = 1;
        let isCompleted = false;

        if (mediaInfo.type === 'movie') {
            // Movies are always "completed" when watched
            episodeNumber = 1;
            isCompleted = true;
        } else {
            // TV shows use episode info
            episodeNumber = episodeInfo?.number || 1;
            const totalEpisodes = anilistMedia.episodes;
            isCompleted = totalEpisodes && episodeNumber >= totalEpisodes;
        }

        // Use SaveMediaListEntry mutation
        const mutation = `
            mutation($mediaId: Int!, $status: MediaListStatus!, $progress: Int!) {
                SaveMediaListEntry(mediaId: $mediaId, status: $status, progress: $progress) {
                    id
                    progress
                    status
                }
            }
        `;

        const mutationVariables = {
            mediaId: anilistId,
            status: isCompleted ? 'COMPLETED' : 'CURRENT',
            progress: episodeNumber
        };

        const mutationResponse = await this.makeGraphQLRequest(
            mutation,
            mutationVariables
        );

        if (mutationResponse.errors) {
            throw new Error(
                `AniList API error: ${mutationResponse.errors[0].message}`
            );
        }

        const entry = mutationResponse.data.SaveMediaListEntry;
        // Keep ID as number to avoid precision issues with large integers
        return { historyId: entry.id };
    }

    /**
     * Remove item from watch history
     */
    async removeFromHistory(historyId: number | string): Promise<void> {
        // Check authentication by attempting to get the token from storage
        const tokenData = await chrome.storage.local.get([
            'anilistAccessToken'
        ]);
        if (!tokenData.anilistAccessToken) {
            throw new Error('Not authenticated with AniList');
        }

        // Use DeleteMediaListEntry mutation
        const mutation = `
            mutation($id: Int!) {
                DeleteMediaListEntry(id: $id) {
                    deleted
                }
            }
        `;

        // Ensure ID is handled as a proper number for GraphQL Int type
        let numericId: number;
        if (typeof historyId === 'string') {
            numericId = parseInt(historyId, 10);
            // Check if the parsed number is valid and within safe integer range
            if (isNaN(numericId) || !Number.isSafeInteger(numericId)) {
                throw new Error(`Invalid AniList entry ID: ${historyId}`);
            }
        } else {
            numericId = historyId;
            if (!Number.isSafeInteger(numericId)) {
                throw new Error(
                    `AniList entry ID exceeds safe integer range: ${historyId}`
                );
            }
        }

        // AniList uses 32-bit signed integers for IDs, check if this ID is within range
        const MAX_32BIT_INT = 2147483647;
        const MIN_32BIT_INT = -2147483648;

        if (numericId > MAX_32BIT_INT || numericId < MIN_32BIT_INT) {
            // This is likely a Trakt ID or other service ID that can't be used with AniList
            console.log(
                `‚ö†Ô∏è Skipping AniList removal - ID ${numericId} appears to be from another service (exceeds 32-bit range)`
            );
            throw new Error(
                `Cannot remove AniList entry: ID ${numericId} is not a valid AniList ID (likely from another service)`
            );
        }

        const variables = { id: numericId };

        const response = await this.makeGraphQLRequest(mutation, variables);

        if (response.errors) {
            throw new Error(`AniList API error: ${response.errors[0].message}`);
        }

        if (!response.data.DeleteMediaListEntry?.deleted) {
            throw new Error('Failed to remove entry from AniList');
        }
    }

    /**
     * Rating Methods
     */

    /**
     * Rate a movie (anime movie)
     */
    async rateMovie(movieIds: ServiceMediaIds, rating: number): Promise<void> {
        // AniList treats movies as anime, so we can rate them
        await this.rateAnimeByMediaInfo('movie', movieIds, rating);
    }

    /**
     * Rate a show (anime series)
     */
    async rateShow(showIds: ServiceMediaIds, rating: number): Promise<void> {
        await this.rateAnimeByMediaInfo('show', showIds, rating);
    }

    /**
     * Rate a season (not applicable for AniList)
     */
    async rateSeason(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        rating: number
    ): Promise<void> {
        throw new Error('AniList does not support season-specific ratings');
    }

    /**
     * Rate an episode (not applicable for AniList)
     */
    async rateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number,
        rating: number
    ): Promise<void> {
        throw new Error('AniList does not support episode-specific ratings');
    }

    /**
     * Rate anime by media info (helper method for both movies and shows)
     */
    private async rateAnimeByMediaInfo(
        type: 'movie' | 'show',
        mediaIds: ServiceMediaIds,
        rating: number
    ): Promise<void> {
        console.log(`‚≠ê AniList: Starting rating process for ${type}`, {
            mediaIds,
            rating
        });

        // Check authentication
        const tokenData = await chrome.storage.local.get([
            'anilistAccessToken'
        ]);
        if (!tokenData.anilistAccessToken) {
            console.log('‚ùå AniList: Not authenticated');
            throw new Error('Not authenticated with AniList');
        }
        console.log('‚úÖ AniList: Authenticated');

        // Validate rating (1-10 scale)
        if (rating < 1 || rating > 10) {
            console.log('‚ùå AniList: Invalid rating:', rating);
            throw new Error('Rating must be between 1 and 10');
        }
        console.log('‚úÖ AniList: Rating validation passed:', rating);

        // Get user's score format preference
        console.log('üîç AniList: Getting user score format...');
        const userScoreFormat = await this.getUserScoreFormat();
        console.log('üìä AniList: User score format:', userScoreFormat);

        // Convert our 1-10 rating to user's preferred format
        const convertedScore = this.convertRatingToAniListFormat(
            rating,
            userScoreFormat
        );
        console.log('üîÑ AniList: Converted score:', {
            original: rating,
            converted: convertedScore,
            format: userScoreFormat
        });

        // Try to find the anime using cached media context or search
        const anilistMedia = await this.findAnimeForRating(type, mediaIds);

        if (!anilistMedia) {
            console.log('‚ùå AniList: Could not find anime for rating');
            throw new Error(
                `Could not find ${type} on AniList for rating. Please ensure the anime exists on AniList and try rating from the media page.`
            );
        }

        // Rate the anime using SaveMediaListEntry mutation
        console.log('‚≠ê AniList: Setting rating...', {
            anilistId: anilistMedia.id,
            score: convertedScore
        });
        await this.setAnimeRating(anilistMedia.id, convertedScore);
        console.log('‚úÖ AniList: Rating completed successfully');
    }

    /**
     * Find anime on AniList for rating using available identifiers
     */
    private async findAnimeForRating(
        type: 'movie' | 'show',
        mediaIds: ServiceMediaIds
    ): Promise<any | null> {
        console.log('üîç AniList: Finding anime for rating...', {
            type,
            mediaIds
        });

        // Try to get recently viewed media context from storage
        const recentMediaData = await chrome.storage.local.get([
            'tmsync_recent_media'
        ]);
        const recentMedia = recentMediaData.tmsync_recent_media;

        console.log('üì¶ Recent media context:', recentMedia);

        if (recentMedia && recentMedia.type === type) {
            // Use the title from recent media context
            const title =
                type === 'movie'
                    ? recentMedia.movie?.title
                    : recentMedia.show?.title;
            if (title) {
                console.log(`üîç Searching AniList for ${type}: "${title}"`);
                const searchResults = await this.searchAnimeByTitle(title);
                console.log('üìã AniList search results:', searchResults);

                if (searchResults.length > 0) {
                    console.log('‚úÖ Found anime on AniList:', searchResults[0]);
                    return searchResults[0]; // Return best match
                } else {
                    console.log(
                        '‚ùå No anime found on AniList for title:',
                        title
                    );
                }
            } else {
                console.log('‚ùå No title found in recent media context');
            }
        } else {
            console.log('‚ùå No recent media context or type mismatch');
        }

        // Fallback: If no recent context, show helpful error
        return null;
    }

    /**
     * Get user's preferred score format from AniList
     */
    private async getUserScoreFormat(): Promise<string> {
        const query = `
            query {
                Viewer {
                    mediaListOptions {
                        scoreFormat
                    }
                }
            }
        `;

        const response = await this.makeGraphQLRequest(query);
        return (
            response.data?.Viewer?.mediaListOptions?.scoreFormat || 'POINT_10'
        );
    }

    /**
     * Convert our 1-10 rating to AniList's score format
     */
    private convertRatingToAniListFormat(
        rating: number,
        scoreFormat: string
    ): number {
        switch (scoreFormat) {
            case 'POINT_100':
                return Math.round(rating * 10); // 1-10 -> 10-100
            case 'POINT_10_DECIMAL':
                return rating; // 1-10 -> 1.0-10.0 (will be sent as float)
            case 'POINT_10':
                return Math.round(rating); // 1-10 -> 1-10
            case 'POINT_5':
                return Math.round(rating / 2); // 1-10 -> 1-5 (stars)
            case 'POINT_3':
                // 1-3 = 1 (sad), 4-6 = 2 (neutral), 7-10 = 3 (happy)
                if (rating <= 3) return 1;
                if (rating <= 6) return 2;
                return 3;
            default:
                return rating; // Fallback to 1-10
        }
    }

    /**
     * Search for anime by title on AniList
     */
    private async searchAnimeByTitle(title: string): Promise<any[]> {
        console.log(`üîç AniList: Searching for anime with title: "${title}"`);

        const searchQuery = `
            query ($search: String) {
                Page(page: 1, perPage: 10) {
                    media(search: $search, type: ANIME) {
                        id
                        title {
                            romaji
                            english
                            native
                        }
                        format
                        seasonYear
                    }
                }
            }
        `;

        try {
            const response = await this.makeGraphQLRequest(
                searchQuery,
                { search: title },
                false
            );
            const results = response.data?.Page?.media || [];
            console.log(
                `üìä AniList: Found ${results.length} search results:`,
                results
            );

            // Try to find exact or close matches
            const exactMatches = results.filter((anime: any) => {
                const titles = [
                    anime.title.romaji,
                    anime.title.english,
                    anime.title.native
                ].filter(Boolean);

                return titles.some(
                    (animeTitle: string) =>
                        animeTitle.toLowerCase() === title.toLowerCase() ||
                        animeTitle
                            .toLowerCase()
                            .includes(title.toLowerCase()) ||
                        title.toLowerCase().includes(animeTitle.toLowerCase())
                );
            });

            console.log(
                `üéØ AniList: Found ${exactMatches.length} close matches:`,
                exactMatches
            );

            return exactMatches.length > 0 ? exactMatches : results;
        } catch (error) {
            console.error('‚ùå AniList: Search failed:', error);
            return [];
        }
    }

    /**
     * Set rating for anime using SaveMediaListEntry mutation
     */
    private async setAnimeRating(
        anilistId: number,
        score: number
    ): Promise<void> {
        const mutation = `
            mutation($mediaId: Int!, $score: Float) {
                SaveMediaListEntry(mediaId: $mediaId, score: $score) {
                    id
                    score
                    status
                }
            }
        `;

        const variables = {
            mediaId: anilistId,
            score: score
        };

        const response = await this.makeGraphQLRequest(mutation, variables);

        if (response.errors) {
            throw new Error(`AniList API error: ${response.errors[0].message}`);
        }

        const action =
            score === 0 ? 'removed rating from' : `rated with score ${score}`;
        console.log(`‚úÖ Successfully ${action} anime ${anilistId}`);
    }

    /**
     * Unrating Methods
     */

    /**
     * Remove rating from a movie (anime movie)
     */
    async unrateMovie(movieIds: ServiceMediaIds): Promise<void> {
        await this.unrateAnimeByMediaInfo('movie', movieIds);
    }

    /**
     * Remove rating from a show (anime series)
     */
    async unrateShow(showIds: ServiceMediaIds): Promise<void> {
        await this.unrateAnimeByMediaInfo('show', showIds);
    }

    /**
     * Remove rating from a season (not applicable for AniList)
     */
    async unrateSeason(
        showIds: ServiceMediaIds,
        seasonNumber: number
    ): Promise<void> {
        throw new Error('AniList does not support season-specific ratings');
    }

    /**
     * Remove rating from an episode (not applicable for AniList)
     */
    async unrateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number
    ): Promise<void> {
        throw new Error('AniList does not support episode-specific ratings');
    }

    /**
     * Unrate anime by media info (helper method for both movies and shows)
     */
    private async unrateAnimeByMediaInfo(
        type: 'movie' | 'show',
        mediaIds: ServiceMediaIds
    ): Promise<void> {
        console.log(`üö´ AniList: Starting unrate process for ${type}`, {
            mediaIds
        });

        // Check authentication
        const tokenData = await chrome.storage.local.get([
            'anilistAccessToken'
        ]);
        if (!tokenData.anilistAccessToken) {
            console.log('‚ùå AniList: Not authenticated');
            throw new Error('Not authenticated with AniList');
        }
        console.log('‚úÖ AniList: Authenticated');

        // Try to find the anime using cached media context or search
        const anilistMedia = await this.findAnimeForRating(type, mediaIds);

        if (!anilistMedia) {
            console.log('‚ùå AniList: Could not find anime for unrating');
            throw new Error(
                `Could not find ${type} on AniList for unrating. Please ensure the anime exists on AniList.`
            );
        }

        // Unrate the anime using SaveMediaListEntry mutation with 0 score
        console.log('üö´ AniList: Removing rating...', {
            anilistId: anilistMedia.id
        });
        await this.setAnimeRating(anilistMedia.id, 0);
        console.log('‚úÖ AniList: Rating removed successfully');
    }

    /**
     * Comment Methods (AniList Notes)
     * Note: AniList only supports show-level notes, no episode/season level
     */

    /**
     * Get notes for media (show-level only)
     */
    async getComments(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        _episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment[]> {
        // AniList only supports show-level notes, map all types to show
        const mediaType = type === 'movie' || type === 'show' ? type : 'show';
        
        // Use the same search approach as rating methods
        const recentMediaData = await chrome.storage.local.get(['tmsync_recent_media']);
        const recentMedia = recentMediaData.tmsync_recent_media;

        if (!recentMedia || recentMedia.type !== mediaType) {
            console.log('No recent media context found for AniList notes');
            return [];
        }

        try {
            const title = mediaType === 'movie' ? recentMedia.movie?.title : recentMedia.show?.title;
            if (!title) {
                console.log('No title found in recent media context');
                return [];
            }

            // Search for the anime first
            const searchResults = await this.searchAnimeByTitle(title);
            if (searchResults.length === 0) {
                console.log('No AniList media found for notes');
                return [];
            }

            const anilistMedia = searchResults[0];
            const userId = await this.getUserId();

            const query = `
                query GetMediaListEntry($mediaId: Int, $userId: Int) {
                    MediaList(mediaId: $mediaId, userId: $userId) {
                        id
                        notes
                        updatedAt
                        user {
                            id
                            name
                        }
                    }
                }
            `;

            const variables = {
                mediaId: anilistMedia.id,
                userId: userId
            };

            const response = await this.makeGraphQLRequest(query, variables);
            const mediaListEntry = response.data.MediaList;

            if (!mediaListEntry || !mediaListEntry.notes) {
                return [];
            }

            // Convert to ServiceComment format
            const serviceComment: ServiceComment = {
                id: mediaListEntry.id,
                comment: mediaListEntry.notes,
                spoiler: false, // AniList doesn't support spoiler flags
                createdAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                updatedAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                user: {
                    username: mediaListEntry.user.name,
                    name: mediaListEntry.user.name
                },
                serviceData: {
                    anilistId: mediaListEntry.id,
                    mediaId: anilistMedia.id
                },
                serviceType: 'anilist' as ServiceType
            };

            return [serviceComment];
        } catch (error) {
            console.error('Error fetching AniList notes:', error);
            return [];
        }
    }

    /**
     * Post/update notes for media (show-level only)
     */
    async postComment(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        comment: string,
        _spoiler: boolean, // Ignored for AniList
        _episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment> {
        // AniList only supports show-level notes, map all types to show
        const mediaType = type === 'movie' || type === 'show' ? type : 'show';
        
        // Use the same search approach as rating methods
        const recentMediaData = await chrome.storage.local.get(['tmsync_recent_media']);
        const recentMedia = recentMediaData.tmsync_recent_media;

        if (!recentMedia || recentMedia.type !== mediaType) {
            throw new Error('No recent media context found for AniList notes');
        }

        const title = mediaType === 'movie' ? recentMedia.movie?.title : recentMedia.show?.title;
        if (!title) {
            throw new Error('No title found in recent media context');
        }

        // Search for the anime first
        const searchResults = await this.searchAnimeByTitle(title);
        if (searchResults.length === 0) {
            throw new Error('No AniList media found for notes');
        }

        const anilistMedia = searchResults[0];

        try {
            const mutation = `
                mutation SaveMediaListEntry($mediaId: Int, $notes: String) {
                    SaveMediaListEntry(mediaId: $mediaId, notes: $notes) {
                        id
                        notes
                        updatedAt
                        user {
                            id
                            name
                        }
                    }
                }
            `;

            const variables = {
                mediaId: anilistMedia.id,
                notes: comment
            };

            const response = await this.makeGraphQLRequest(mutation, variables);
            const mediaListEntry = response.data.SaveMediaListEntry;

            // Convert to ServiceComment format
            const serviceComment: ServiceComment = {
                id: mediaListEntry.id,
                comment: mediaListEntry.notes,
                spoiler: false, // AniList doesn't support spoiler flags
                createdAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                updatedAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                user: {
                    username: mediaListEntry.user.name,
                    name: mediaListEntry.user.name
                },
                serviceData: {
                    anilistId: mediaListEntry.id,
                    mediaId: anilistMedia.id
                },
                serviceType: 'anilist' as ServiceType
            };

            return serviceComment;
        } catch (error) {
            console.error('Error saving AniList notes:', error);
            throw error;
        }
    }

    /**
     * Update existing notes
     */
    async updateComment(
        commentId: number | string,
        comment: string,
        _spoiler: boolean // Ignored for AniList
    ): Promise<ServiceComment> {
        // For AniList, updating is the same as posting since it's MediaList entry based
        // We need to get the media ID from the comment ID (which is the MediaList entry ID)
        try {
            const mutation = `
                mutation SaveMediaListEntry($id: Int, $notes: String) {
                    SaveMediaListEntry(id: $id, notes: $notes) {
                        id
                        notes
                        updatedAt
                        user {
                            id
                            name
                        }
                    }
                }
            `;

            const variables = {
                id: commentId,
                notes: comment
            };

            const response = await this.makeGraphQLRequest(mutation, variables);
            const mediaListEntry = response.data.SaveMediaListEntry;

            // Convert to ServiceComment format
            const serviceComment: ServiceComment = {
                id: mediaListEntry.id,
                comment: mediaListEntry.notes,
                spoiler: false, // AniList doesn't support spoiler flags
                createdAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                updatedAt: new Date(mediaListEntry.updatedAt * 1000).toISOString(),
                user: {
                    username: mediaListEntry.user.name,
                    name: mediaListEntry.user.name
                },
                serviceData: {
                    anilistId: mediaListEntry.id,
                    mediaId: null // We don't have this from the update response
                },
                serviceType: 'anilist' as ServiceType
            };

            return serviceComment;
        } catch (error) {
            console.error('Error updating AniList notes:', error);
            throw error;
        }
    }

    /**
     * Delete notes (submit blank notes)
     */
    async deleteComment(commentId: number | string): Promise<void> {
        // For AniList, delete means setting notes to empty string
        try {
            const mutation = `
                mutation SaveMediaListEntry($id: Int, $notes: String) {
                    SaveMediaListEntry(id: $id, notes: $notes) {
                        id
                        notes
                    }
                }
            `;

            const variables = {
                id: commentId,
                notes: ''
            };

            await this.makeGraphQLRequest(mutation, variables);
        } catch (error) {
            console.error('Error deleting AniList notes:', error);
            throw error;
        }
    }

    /**
     * Private Helper Methods
     */

    /**
     * Make a GraphQL request to AniList API
     */
    private async makeGraphQLRequest(
        query: string,
        variables: any = {},
        requireAuth: boolean = true
    ): Promise<any> {
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            Accept: 'application/json'
        };

        if (requireAuth) {
            const tokenData = await chrome.storage.local.get([
                'anilistAccessToken'
            ]);
            const token = tokenData.anilistAccessToken;
            if (!token) {
                throw new Error('No AniList access token available');
            }
            headers['Authorization'] = `Bearer ${token}`;
        }

        const response = await fetch(this.apiEndpoint, {
            method: 'POST',
            headers,
            body: JSON.stringify({
                query,
                variables
            })
        });

        if (!response.ok) {
            throw new Error(
                `AniList API error: ${response.status} ${response.statusText}`
            );
        }

        const data = await response.json();

        if (data.errors) {
            throw new Error(
                `AniList API error: ${data.errors[0]?.message || 'Unknown error'}`
            );
        }

        return data;
    }

    /**
     * Convert AniList media format to our MediaInfoResponse format
     */
    private convertAniListToMediaInfo(anilistMedia: any): MediaInfoResponse {
        // This is a basic conversion - would need refinement based on actual usage
        return {
            type: 'show',
            score: 0, // Default score, would be updated from user's list
            show: {
                title:
                    anilistMedia.title?.english ||
                    anilistMedia.title?.romaji ||
                    'Unknown',
                year: anilistMedia.seasonYear || 0,
                ids: {
                    trakt: 0, // Default values since AniList doesn't have these
                    slug: '',
                    tvdb: 0,
                    imdb: '',
                    tmdb: 0
                }
            }
        };
    }

    /**
     * Get AniList media ID from MediaInfoResponse
     */
    private getAniListMediaId(mediaInfo: MediaInfoResponse): number | null {
        // Try to find AniList ID from the media info
        // This could be from various sources like recent media context or search results
        
        // For now, we'll need to use the search/context approach similar to findAnimeForRating
        // This is a simplified version - in practice, you'd want to cache this
        return null; // Will be handled by search in the calling methods
    }

    /**
     * Get current user ID from AniList
     */
    private async getUserId(): Promise<number> {
        try {
            const query = `
                query {
                    Viewer {
                        id
                    }
                }
            `;

            const response = await this.makeGraphQLRequest(query);
            const userId = response.data?.Viewer?.id;

            if (!userId) {
                throw new Error('Could not get user ID from AniList');
            }

            return userId;
        } catch (error) {
            console.error('Error getting AniList user ID:', error);
            throw error;
        }
    }
}

// Export singleton instance
export const aniListService = new AniListService();
</file>

<file path="webpack/webpack.common.js">
const path = require('path');
const CopyPlugin = require('copy-webpack-plugin');
const Dotenv = require('dotenv-webpack');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

const srcDir = path.join(__dirname, '..', 'src');

module.exports = {
    entry: {
        popup: path.join(srcDir, 'popup/index.tsx'),
        options: path.join(srcDir, 'options/index.tsx'),
        background: path.join(srcDir, 'background/index.ts'),
        contentScript: path.join(srcDir, 'content-scripts/main/index.tsx'),
        traktContentScript: path.join(srcDir, 'content-scripts/trakt/index.tsx')
    },
    output: {
        path: path.join(__dirname, '../dist/js'),
        filename: '[name].js'
    },
    optimization: {
        splitChunks: {
            name: 'vendor',
            chunks(chunk) {
                return chunk.name !== 'background';
            }
        }
    },
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                use: 'ts-loader',
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader',
                    'postcss-loader'
                ]
            }
        ]
    },
    resolve: {
        extensions: ['.ts', '.tsx', '.js']
    },
    plugins: [
        new Dotenv(),
        new CopyPlugin({
            patterns: [{ from: '.', to: '../', context: 'public' }]
        }),
        new MiniCssExtractPlugin({
            filename: '../css/styles.css'
        })
    ]
};
</file>

<file path="src/services/TraktService.ts">
import { clientId, clientSecret, traktHeaders } from '../utils/config';
import {
    MediaInfoResponse,
    SeasonEpisodeObj,
    MediaRatings
} from '../types/media';
import {
    TraktComment,
    ScrobbleBody,
    TraktShowWatchedProgress
} from '../types/trakt';
import { WatchStatusInfo, ScrobbleStopResponseData } from '../types/scrobbling';
import { TrackerService } from '../types/services';
import {
    ServiceType,
    ServiceComment,
    ServiceProgressInfo,
    ServiceMediaIds,
    ServiceMediaRatings,
    ServiceScrobbleResponse,
    ServiceCapabilities
} from '../types/serviceTypes';
import { scrobbleOperationManager } from '../background/scrobbleOperationManager';

/**
 * TraktService - Handles all Trakt.tv API interactions
 *
 * This service encapsulates authentication, media operations, scrobbling,
 * ratings, comments, and user data management for Trakt.tv.
 */
export class TraktService implements TrackerService {
    private isRefreshing = false;
    private refreshSubscribers: ((token: string) => void)[] = [];
    private cachedUsername: string | null = null;

    /**
     * Get service capabilities and configuration
     */
    getCapabilities(): ServiceCapabilities {
        return {
            serviceType: 'trakt' as ServiceType,
            supportsRealTimeScrobbling: true, // Trakt supports real-time scrobbling
            supportsProgressTracking: false, // Trakt doesn't need completion-based tracking
            supportsRatings: true,
            supportsComments: true,
            supportsHistory: true,
            supportsSearch: true,
            ratingScale: {
                min: 1,
                max: 10,
                step: 1,
                serviceType: 'trakt'
            },
            authMethod: 'oauth',
            supportedMediaTypes: ['movie', 'show'],
            rateLimits: {
                requestsPerMinute: 1000,
                requestsPerHour: 5000
            }
        };
    }

    /**
     * Authentication Methods
     */

    /**
     * Check if user is currently authenticated with Trakt
     */
    async isAuthenticated(): Promise<boolean> {
        try {
            const tokenData = await chrome.storage.local.get([
                'traktAccessToken',
                'traktTokenExpiresAt'
            ]);
            const storedToken = tokenData.traktAccessToken;
            const expiresAt = tokenData.traktTokenExpiresAt || 0;

            return !!(storedToken && Date.now() < expiresAt);
        } catch {
            return false;
        }
    }

    /**
     * Get current user settings and info
     */
    async getUserSettings(): Promise<any> {
        return this.callApi('https://api.trakt.tv/users/settings', 'GET');
    }

    /**
     * Get cached or fetch current username
     */
    async getUsername(): Promise<string> {
        if (this.cachedUsername) return this.cachedUsername;

        const data = await chrome.storage.local.get('traktUsername');
        if (data.traktUsername) {
            this.cachedUsername = data.traktUsername;
            return data.traktUsername;
        }

        const settings = await this.getUserSettings();
        const username = settings?.user?.username;
        if (username) {
            this.cachedUsername = username;
            await chrome.storage.local.set({ traktUsername: username });
            return username;
        }

        throw new Error('Could not determine Trakt username.');
    }

    /**
     * Initiate OAuth login flow
     */
    async login(): Promise<void> {
        let redirectUri: string | undefined;
        try {
            redirectUri = chrome.identity.getRedirectURL();
            if (!redirectUri) throw new Error('Could not get redirect URL.');
        } catch (err) {
            console.error('Error getting redirect URL:', err);
            throw new Error('Failed to configure authentication redirect.');
        }

        const authUrl = `https://trakt.tv/oauth/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code`;

        try {
            const redirectUrlResponse = await chrome.identity.launchWebAuthFlow(
                {
                    url: authUrl,
                    interactive: true
                }
            );

            if (chrome.runtime.lastError || !redirectUrlResponse) {
                throw new Error(
                    chrome.runtime.lastError?.message ||
                        'Authentication cancelled or failed.'
                );
            }

            const url = new URL(redirectUrlResponse);
            const code = url.searchParams.get('code');

            if (!code) {
                throw new Error('Could not get authorization code from Trakt.');
            }

            const tokenResponse = await fetch(
                'https://api.trakt.tv/oauth/token',
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        code: code,
                        client_id: clientId,
                        client_secret: clientSecret,
                        redirect_uri: redirectUri,
                        grant_type: 'authorization_code'
                    })
                }
            );

            const tokenData = await tokenResponse.json();
            if (!tokenResponse.ok) {
                throw new Error(
                    `Token exchange failed: ${tokenData.error_description || tokenResponse.statusText}`
                );
            }

            const expiresAt = Date.now() + tokenData.expires_in * 1000;
            await chrome.storage.local.set({
                traktAccessToken: tokenData.access_token,
                traktRefreshToken: tokenData.refresh_token,
                traktTokenExpiresAt: expiresAt
            });

            // Fetch and cache user info
            const settings = await this.getUserSettings();
            if (settings?.user?.username) {
                this.cachedUsername = settings.user.username;
                await chrome.storage.local.set({
                    traktUsername: settings.user.username
                });
            }
        } catch (err) {
            console.error('Error during login process:', err);
            throw err instanceof Error
                ? err
                : new Error('An unexpected error occurred during login.');
        }
    }

    /**
     * Logout and clear stored tokens
     */
    async logout(): Promise<void> {
        try {
            const tokenData = await chrome.storage.local.get([
                'traktAccessToken'
            ]);
            if (tokenData.traktAccessToken) {
                await fetch('https://api.trakt.tv/oauth/revoke', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${tokenData.traktAccessToken}`,
                        'trakt-api-key': clientId,
                        'trakt-api-version': '2'
                    },
                    body: JSON.stringify({ token: tokenData.traktAccessToken })
                });
            }
        } catch (err) {
            console.error('Error revoking token (continuing logout):', err);
        } finally {
            await chrome.storage.local.remove([
                'traktAccessToken',
                'traktRefreshToken',
                'traktTokenExpiresAt',
                'traktUsername'
            ]);
            this.cachedUsername = null;
        }
    }

    /**
     * Media Search and Identification Methods
     */

    /**
     * Search for media by query and type
     */
    async searchMedia(
        query: string,
        type: 'movie' | 'show',
        years?: string
    ): Promise<any[]> {
        const params = new URLSearchParams();
        params.append('query', query);
        if (years) params.append('years', years);

        const url = `https://api.trakt.tv/search/${type}?${params.toString()}`;
        return this.callApi(url, 'GET', null, false);
    }

    /**
     * Get media info by TMDB ID
     */
    async getMediaByTmdbId(
        tmdbId: string,
        type: 'movie' | 'show'
    ): Promise<any> {
        const url = `https://api.trakt.tv/search/tmdb/${tmdbId}?type=${type}`;
        const results = await this.callApi(url, 'GET', null, false);
        return results?.[0] || null;
    }

    /**
     * Get detailed media status including watch history and ratings
     */
    async getMediaStatus(mediaInfo: MediaInfoResponse): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }> {
        const watchStatus: WatchStatusInfo = {
            isInHistory: false,
            isCompleted: false
        };
        let progressInfo: TraktShowWatchedProgress | null = null;
        const ratingInfo: MediaRatings = {};

        if (mediaInfo.type === 'movie') {
            const movieTraktId = mediaInfo.movie.ids?.trakt;
            if (movieTraktId) {
                const [history, ratings] = await Promise.all([
                    this.callApi(
                        `https://api.trakt.tv/sync/history/movies/${movieTraktId}?limit=1`
                    ).catch(() => []),
                    this.callApi(
                        `https://api.trakt.tv/sync/ratings/movies`
                    ).catch(() => [])
                ]);

                if (history?.[0]?.watched_at) {
                    watchStatus.isInHistory = true;
                    watchStatus.lastWatchedAt = history[0].watched_at;
                }

                const movieRating = ratings.find(
                    (r: any) => r.movie.ids.trakt === movieTraktId
                );
                if (movieRating) {
                    ratingInfo.show = {
                        userRating: movieRating.rating,
                        ratedAt: movieRating.rated_at
                    };
                }
            }
        } else if (mediaInfo.type === 'show') {
            const showTraktId = mediaInfo.show.ids?.trakt;
            if (showTraktId) {
                progressInfo = await this.callApi(
                    `https://api.trakt.tv/shows/${showTraktId}/progress/watched?hidden=false&specials=false`
                ).catch(() => null);

                if (progressInfo?.last_watched_at) {
                    watchStatus.isInHistory = true;
                    watchStatus.lastWatchedAt = progressInfo.last_watched_at;
                }

                watchStatus.isCompleted = !!(
                    progressInfo &&
                    progressInfo.aired > 0 &&
                    progressInfo.aired === progressInfo.completed
                );

                const [showRatings, seasonRatings, episodeRatings] =
                    await Promise.all([
                        this.callApi(
                            `https://api.trakt.tv/sync/ratings/shows`
                        ).catch(() => []),
                        this.callApi(
                            `https://api.trakt.tv/sync/ratings/seasons`
                        ).catch(() => []),
                        this.callApi(
                            `https://api.trakt.tv/sync/ratings/episodes`
                        ).catch(() => [])
                    ]);

                const showRating = showRatings.find(
                    (r: any) => r.show.ids.trakt === showTraktId
                );
                if (showRating) {
                    ratingInfo.show = {
                        userRating: showRating.rating,
                        ratedAt: showRating.rated_at
                    };
                }

                // Note: Season and episode ratings would need episode info context
                // This will be handled by calling methods when episode info is available
            }
        }

        return {
            watchStatus,
            progressInfo: this.convertToServiceProgressInfo(progressInfo),
            ratingInfo: this.convertToServiceMediaRatings(ratingInfo)
        };
    }

    /**
     * Get media status with episode-specific ratings
     */
    async getMediaStatusWithEpisode(
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<{
        watchStatus: WatchStatusInfo;
        progressInfo: ServiceProgressInfo | null;
        ratingInfo: ServiceMediaRatings;
    }> {
        const result = await this.getMediaStatus(mediaInfo);

        // Add episode-specific ratings if this is a show with episode info
        if (mediaInfo.type === 'show' && episodeInfo) {
            const showTraktId = mediaInfo.show.ids?.trakt;
            if (showTraktId) {
                const [seasonRatings, episodeRatings] = await Promise.all([
                    this.callApi(
                        `https://api.trakt.tv/sync/ratings/seasons`
                    ).catch(() => []),
                    this.callApi(
                        `https://api.trakt.tv/sync/ratings/episodes`
                    ).catch(() => [])
                ]);

                const seasonRating = seasonRatings.find(
                    (r: any) =>
                        r.show.ids.trakt === showTraktId &&
                        r.season.number === episodeInfo.season
                );
                if (seasonRating) {
                    result.ratingInfo.season = {
                        userRating: seasonRating.rating,
                        ratedAt: seasonRating.rated_at,
                        serviceType: 'trakt'
                    };
                }

                const episodeRating = episodeRatings.find(
                    (r: any) =>
                        r.show.ids.trakt === showTraktId &&
                        r.episode.season === episodeInfo.season &&
                        r.episode.number === episodeInfo.number
                );
                if (episodeRating) {
                    result.ratingInfo.episode = {
                        userRating: episodeRating.rating,
                        ratedAt: episodeRating.rated_at,
                        serviceType: 'trakt'
                    };
                }
            }
        }

        return result;
    }

    /**
     * Scrobbling Methods
     */

    /**
     * Start scrobbling media
     */
    async startScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void> {
        const payload = this.buildScrobblePayload(
            mediaInfo,
            episodeInfo,
            progress
        );
        await this.callApi(
            'https://api.trakt.tv/scrobble/start',
            'POST',
            payload
        );
    }

    /**
     * Pause scrobbling
     */
    async pauseScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<void> {
        return scrobbleOperationManager.executeOperation(
            'pause',
            mediaInfo,
            episodeInfo,
            async () => {
                const payload = this.buildScrobblePayload(
                    mediaInfo,
                    episodeInfo,
                    progress
                );
                await this.callApi(
                    'https://api.trakt.tv/scrobble/pause',
                    'POST',
                    payload
                );
            }
        );
    }

    /**
     * Stop scrobbling and mark as watched if threshold met
     */
    async stopScrobble(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): Promise<ServiceScrobbleResponse> {
        return scrobbleOperationManager.executeOperation(
            'stop',
            mediaInfo,
            episodeInfo,
            async () => {
                const payload = this.buildScrobblePayload(
                    mediaInfo,
                    episodeInfo,
                    progress
                );
                const response = await this.callApi(
                    'https://api.trakt.tv/scrobble/stop',
                    'POST',
                    payload
                );

                console.log('üõë Trakt scrobble stop response:', {
                    progress,
                    responseAction: response?.action,
                    responseId: response?.id
                });

                // Use Trakt's response to determine the action, not our own threshold
                // Trakt decides based on its own logic whether this should be "scrobble" (watched) or "pause"
                if (response?.action === 'scrobble') {
                    return {
                        action: 'watched',
                        historyId: response?.id,
                        serviceType: 'trakt'
                    };
                } else {
                    // Trakt returned "pause" - meaning it doesn't consider this completed
                    return {
                        action: 'paused_incomplete',
                        historyId: response?.id, // Still include ID in case it's useful
                        serviceType: 'trakt'
                    };
                }
            }
        );
    }

    /**
     * Add media to watch history manually
     */
    async addToHistory(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null
    ): Promise<{ historyId?: number }> {
        const historyBody: any = {};

        if (mediaInfo.type === 'movie') {
            historyBody.movies = [{ ids: mediaInfo.movie.ids }];
        } else if (mediaInfo.type === 'show' && episodeInfo) {
            historyBody.shows = [
                {
                    ids: mediaInfo.show.ids,
                    seasons: [
                        {
                            number: episodeInfo.season,
                            episodes: [{ number: episodeInfo.number }]
                        }
                    ]
                }
            ];
        } else {
            throw new Error('Invalid media for manual history add');
        }

        await this.callApi(
            'https://api.trakt.tv/sync/history',
            'POST',
            historyBody
        );

        // Get the history ID of the item we just added
        const historyEndpoint =
            mediaInfo.type === 'movie' ? 'movies' : 'episodes';
        const traktId =
            mediaInfo.type === 'movie'
                ? mediaInfo.movie.ids.trakt
                : mediaInfo.show.ids.trakt;

        const historyResponse = await this.callApi(
            `https://api.trakt.tv/sync/history/${historyEndpoint}/${traktId}?limit=1`,
            'GET'
        );

        let traktHistoryId: number | undefined;
        if (
            Array.isArray(historyResponse) &&
            historyResponse.length > 0 &&
            historyResponse[0].id
        ) {
            traktHistoryId = historyResponse[0].id;
        }

        return { historyId: traktHistoryId };
    }

    /**
     * Remove item from watch history
     */
    async removeFromHistory(historyId: number): Promise<void> {
        await this.callApi(`https://api.trakt.tv/sync/history/remove`, 'POST', {
            ids: [historyId]
        });
    }

    /**
     * Rating Methods
     */

    /**
     * Rate a movie
     */
    async rateMovie(movieIds: ServiceMediaIds, rating: number): Promise<void> {
        const body = {
            movies: [{ ids: movieIds, rating: Math.round(rating) }]
        };
        await this.callApi('https://api.trakt.tv/sync/ratings', 'POST', body);
    }

    /**
     * Rate a show
     */
    async rateShow(showIds: ServiceMediaIds, rating: number): Promise<void> {
        const body = {
            shows: [{ ids: showIds, rating: Math.round(rating) }]
        };
        await this.callApi('https://api.trakt.tv/sync/ratings', 'POST', body);
    }

    /**
     * Rate a season
     */
    async rateSeason(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        rating: number
    ): Promise<void> {
        // Get season details first
        const seasons = await this.callApi(
            `https://api.trakt.tv/shows/${showIds.trakt}/seasons`
        );
        const seasonId = seasons.find((s: any) => s.number === seasonNumber)
            ?.ids?.trakt;

        if (!seasonId) {
            throw new Error(`Season ${seasonNumber} not found for show`);
        }

        const body = {
            seasons: [{ ids: { trakt: seasonId }, rating: Math.round(rating) }]
        };
        await this.callApi('https://api.trakt.tv/sync/ratings', 'POST', body);
    }

    /**
     * Rate an episode
     */
    async rateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number,
        rating: number
    ): Promise<void> {
        // Get episode details first
        const episodes = await this.callApi(
            `https://api.trakt.tv/shows/${showIds.trakt}/seasons/${seasonNumber}/episodes`
        );
        const episodeId = episodes.find((e: any) => e.number === episodeNumber)
            ?.ids?.trakt;

        if (!episodeId) {
            throw new Error(
                `Episode ${seasonNumber}x${episodeNumber} not found`
            );
        }

        const body = {
            episodes: [
                { ids: { trakt: episodeId }, rating: Math.round(rating) }
            ]
        };
        await this.callApi('https://api.trakt.tv/sync/ratings', 'POST', body);
    }

    /**
     * Unrating Methods
     */

    /**
     * Remove rating from a movie
     */
    async unrateMovie(movieIds: ServiceMediaIds): Promise<void> {
        const body = {
            movies: [{ ids: movieIds }]
        };
        await this.callApi(
            'https://api.trakt.tv/sync/ratings/remove',
            'POST',
            body
        );
    }

    /**
     * Remove rating from a show
     */
    async unrateShow(showIds: ServiceMediaIds): Promise<void> {
        const body = {
            shows: [{ ids: showIds }]
        };
        await this.callApi(
            'https://api.trakt.tv/sync/ratings/remove',
            'POST',
            body
        );
    }

    /**
     * Remove rating from a season
     */
    async unrateSeason(
        showIds: ServiceMediaIds,
        seasonNumber: number
    ): Promise<void> {
        // Get season details first
        const seasons = await this.callApi(
            `https://api.trakt.tv/shows/${showIds.trakt}/seasons`
        );
        const season = seasons.find((s: any) => s.number === seasonNumber);

        if (!season?.ids?.trakt) {
            throw new Error(`Season ${seasonNumber} not found for show`);
        }

        const body = {
            seasons: [{ ids: { trakt: season.ids.trakt } }]
        };
        await this.callApi(
            'https://api.trakt.tv/sync/ratings/remove',
            'POST',
            body
        );
    }

    /**
     * Remove rating from an episode
     */
    async unrateEpisode(
        showIds: ServiceMediaIds,
        seasonNumber: number,
        episodeNumber: number
    ): Promise<void> {
        // Get episode details first
        const episodes = await this.callApi(
            `https://api.trakt.tv/shows/${showIds.trakt}/seasons/${seasonNumber}/episodes`
        );
        const episode = episodes.find((e: any) => e.number === episodeNumber);

        if (!episode?.ids?.trakt) {
            throw new Error(
                `Episode ${seasonNumber}x${episodeNumber} not found`
            );
        }

        const body = {
            episodes: [{ ids: { trakt: episode.ids.trakt } }]
        };
        await this.callApi(
            'https://api.trakt.tv/sync/ratings/remove',
            'POST',
            body
        );
    }

    /**
     * Comment Methods
     */

    /**
     * Get comments for media
     */
    async getComments(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment[]> {
        const username = await this.getUsername();
        const url = `https://api.trakt.tv/users/${username}/comments/${type}s/all`;
        const allComments = await this.callApi<any[]>(url);

        if (type === 'movie' && mediaInfo.type === 'movie') {
            const id = mediaInfo.movie.ids.trakt;
            return allComments
                .filter((c: any) => c.movie?.ids?.trakt === id)
                .map((c: any) => this.convertToServiceComment(c.comment));
        }
        if (type === 'show' && mediaInfo.type === 'show') {
            const id = mediaInfo.show.ids.trakt;
            return allComments
                .filter((c: any) => c.show?.ids?.trakt === id)
                .map((c: any) => this.convertToServiceComment(c.comment));
        }
        if (type === 'season' && mediaInfo.type === 'show' && episodeInfo) {
            const id = mediaInfo.show.ids.trakt;
            return allComments
                .filter(
                    (c: any) =>
                        c.show?.ids?.trakt === id &&
                        c.season?.number === episodeInfo.season
                )
                .map((c: any) => this.convertToServiceComment(c.comment));
        }
        if (type === 'episode' && mediaInfo.type === 'show' && episodeInfo) {
            const id = mediaInfo.show.ids.trakt;
            return allComments
                .filter(
                    (c: any) =>
                        c.show?.ids?.trakt === id &&
                        c.episode?.season === episodeInfo.season &&
                        c.episode?.number === episodeInfo.number
                )
                .map((c: any) => this.convertToServiceComment(c.comment));
        }
        return [];
    }

    /**
     * Post a new comment
     */
    async postComment(
        type: 'movie' | 'show' | 'season' | 'episode',
        mediaInfo: MediaInfoResponse,
        comment: string,
        spoiler: boolean,
        episodeInfo?: SeasonEpisodeObj
    ): Promise<ServiceComment> {
        const body: any = { comment, spoiler };

        if (type === 'movie' && mediaInfo.type === 'movie') {
            body.movie = { ids: mediaInfo.movie.ids };
        } else if (type === 'show' && mediaInfo.type === 'show') {
            body.show = { ids: mediaInfo.show.ids };
        } else if (
            type === 'season' &&
            mediaInfo.type === 'show' &&
            episodeInfo
        ) {
            const seasons = await this.callApi<any[]>(
                `https://api.trakt.tv/shows/${mediaInfo.show.ids.trakt}/seasons`
            );
            const seasonId = seasons.find(
                (s: any) => s.number === episodeInfo.season
            )?.ids?.trakt;
            if (!seasonId)
                throw new Error('Could not find Trakt ID for the season.');
            body.season = { ids: { trakt: seasonId } };
        } else if (
            type === 'episode' &&
            mediaInfo.type === 'show' &&
            episodeInfo
        ) {
            const epDetails = await this.callApi<any>(
                `https://api.trakt.tv/shows/${mediaInfo.show.ids.trakt}/seasons/${episodeInfo.season}/episodes/${episodeInfo.number}`
            );
            const episodeId = epDetails?.ids?.trakt;
            if (!episodeId)
                throw new Error('Could not find Trakt ID for the episode.');
            body.episode = { ids: { trakt: episodeId } };
        } else {
            throw new Error('Invalid media type for posting comment.');
        }
        const response = await this.callApi<TraktComment>(
            'https://api.trakt.tv/comments',
            'POST',
            body
        );
        return this.convertToServiceComment(response);
    }

    /**
     * Update existing comment
     */
    async updateComment(
        commentId: number | string,
        comment: string,
        spoiler: boolean
    ): Promise<ServiceComment> {
        const response = await this.callApi(
            `https://api.trakt.tv/comments/${commentId}`,
            'PUT',
            {
                comment,
                spoiler
            }
        );
        return this.convertToServiceComment(response);
    }

    /**
     * Delete a comment
     */
    async deleteComment(commentId: number | string): Promise<void> {
        await this.callApi(
            `https://api.trakt.tv/comments/${commentId}`,
            'DELETE'
        );
    }

    /**
     * Private Helper Methods
     */

    /**
     * Convert TraktShowWatchedProgress to ServiceProgressInfo
     */
    private convertToServiceProgressInfo(
        progress: TraktShowWatchedProgress | null
    ): ServiceProgressInfo | null {
        if (!progress) return null;

        return {
            aired: progress.aired,
            completed: progress.completed,
            lastWatchedAt: progress.last_watched_at,
            serviceType: 'trakt'
        };
    }

    /**
     * Convert MediaRatings to ServiceMediaRatings
     */
    private convertToServiceMediaRatings(
        ratings: MediaRatings
    ): ServiceMediaRatings {
        return {
            show:
                ratings.show && ratings.show.userRating !== null
                    ? {
                          userRating: ratings.show.userRating,
                          ratedAt: ratings.show.ratedAt || '',
                          serviceType: 'trakt'
                      }
                    : undefined,
            season:
                ratings.season && ratings.season.userRating !== null
                    ? {
                          userRating: ratings.season.userRating,
                          ratedAt: ratings.season.ratedAt || '',
                          serviceType: 'trakt'
                      }
                    : undefined,
            episode:
                ratings.episode && ratings.episode.userRating !== null
                    ? {
                          userRating: ratings.episode.userRating,
                          ratedAt: ratings.episode.ratedAt || '',
                          serviceType: 'trakt'
                      }
                    : undefined
        };
    }

    /**
     * Convert TraktComment to ServiceComment
     */
    private convertToServiceComment(comment: TraktComment): ServiceComment {
        return {
            id: comment.id,
            comment: comment.comment,
            spoiler: comment.spoiler,
            createdAt: comment.created_at,
            updatedAt: comment.updated_at,
            user: {
                username: comment.user.username,
                name: comment.user.name
            },
            serviceType: 'trakt'
        };
    }

    /**
     * Build scrobble payload for API calls
     */
    private buildScrobblePayload(
        mediaInfo: MediaInfoResponse,
        episodeInfo: SeasonEpisodeObj | null,
        progress: number
    ): ScrobbleBody {
        const payload: ScrobbleBody = { progress };

        if (mediaInfo.type === 'movie') {
            payload.movie = mediaInfo.movie;
        } else if (mediaInfo.type === 'show' && episodeInfo) {
            payload.show = mediaInfo.show;
            payload.episode = episodeInfo;
        } else {
            throw new Error(
                'Invalid mediaInfo or missing episodeInfo for show'
            );
        }

        return payload;
    }

    /**
     * Subscribe to token refresh events
     */
    private subscribeTokenRefresh(cb: (token: string) => void): void {
        this.refreshSubscribers.push(cb);
    }

    /**
     * Notify token refresh subscribers
     */
    private onRefreshed(token: string): void {
        this.refreshSubscribers.forEach((cb) => cb(token));
        this.refreshSubscribers = [];
    }

    /**
     * Refresh access token using refresh token
     */
    private async refreshToken(): Promise<string | null> {
        console.log('Attempting token refresh...');
        this.isRefreshing = true;

        const tokenData = await chrome.storage.local.get(['traktRefreshToken']);
        const storedRefreshToken = tokenData.traktRefreshToken;

        if (!storedRefreshToken) {
            console.error('No refresh token found. Cannot refresh.');
            this.isRefreshing = false;
            await this.logout();
            return null;
        }

        let redirectUri: string | undefined;
        try {
            redirectUri = chrome.identity.getRedirectURL();
            if (!redirectUri)
                throw new Error('Could not get redirect URL for refresh.');
        } catch (error) {
            console.error('Error getting redirect URL during refresh:', error);
            this.isRefreshing = false;
            return null;
        }

        try {
            const response = await fetch('https://api.trakt.tv/oauth/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    refresh_token: storedRefreshToken,
                    client_id: clientId,
                    client_secret: clientSecret,
                    redirect_uri: redirectUri,
                    grant_type: 'refresh_token'
                })
            });

            const data = await response.json();

            if (!response.ok) {
                console.error('Token refresh failed:', response.status, data);
                await this.logout();
                this.isRefreshing = false;
                this.onRefreshed('');
                return null;
            }

            console.log('Token refresh successful:', data);
            const newExpiresAt = Date.now() + data.expires_in * 1000;

            await chrome.storage.local.set({
                traktAccessToken: data.access_token,
                traktRefreshToken: data.refresh_token,
                traktTokenExpiresAt: newExpiresAt
            });

            this.isRefreshing = false;
            this.onRefreshed(data.access_token);
            return data.access_token;
        } catch (error) {
            console.error('Error during token refresh fetch:', error);
            this.isRefreshing = false;
            this.onRefreshed('');
            return null;
        }
    }

    /**
     * Core API call method with automatic token management
     */
    private async callApi<T = any>(
        url: string,
        method: RequestInit['method'] = 'GET',
        body: BodyInit | object | null = null,
        isAuth: boolean = true
    ): Promise<T> {
        let accessToken: string | null = null;

        if (isAuth) {
            const tokenData = await chrome.storage.local.get([
                'traktAccessToken',
                'traktTokenExpiresAt'
            ]);
            const expiresAt = tokenData.traktTokenExpiresAt || 0;
            const storedAccessToken = tokenData.traktAccessToken;

            if (!storedAccessToken || Date.now() >= expiresAt - 60000) {
                console.log('Access token missing or expired/expiring soon.');

                if (this.isRefreshing) {
                    console.log('Waiting for ongoing token refresh...');
                    return new Promise((resolve) => {
                        this.subscribeTokenRefresh(async (newToken) => {
                            if (!newToken) {
                                throw new Error(
                                    'Authentication failed during refresh.'
                                );
                            }
                            resolve(
                                this.callApiInternal(
                                    url,
                                    method,
                                    body,
                                    isAuth,
                                    newToken
                                )
                            );
                        });
                    });
                } else {
                    accessToken = await this.refreshToken();
                    if (!accessToken) {
                        await this.logout();
                        throw new Error(
                            'Authentication required. Please login via the extension popup.'
                        );
                    }
                }
            } else {
                accessToken = storedAccessToken;
            }
        }

        return this.callApiInternal(url, method, body, isAuth, accessToken);
    }

    /**
     * Internal API call implementation
     */
    private async callApiInternal<T = any>(
        url: string,
        method: RequestInit['method'] = 'GET',
        body: BodyInit | object | null = null,
        isAuth: boolean = true,
        accessToken: string | null = null
    ): Promise<T> {
        const headers: HeadersInit = { ...traktHeaders };

        if (isAuth && accessToken) {
            headers['Authorization'] = `Bearer ${accessToken}`;
        }

        if (body && typeof body === 'object' && !(body instanceof FormData)) {
            headers['Content-Type'] = 'application/json';
            body = JSON.stringify(body);
        }

        const response = await fetch(url, {
            method,
            headers,
            body: body as BodyInit
        });

        if (!response.ok) {
            throw new Error(
                `Trakt API error: ${response.status} ${response.statusText}`
            );
        }

        const contentType = response.headers.get('content-type');
        if (contentType?.includes('application/json')) {
            return response.json();
        } else {
            return response.text() as T;
        }
    }
}

// Export singleton instance
export const traktService = new TraktService();
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

**Package Manager**: Use `pnpm` for all package management operations.

**Build & Development**:
- `pnpm dev` - Run development build with file watching
- `pnpm build` - Create production build
- `pnpm clean` - Remove dist directory

**Quality & Testing**:
- `pnpm format` - Auto-format all code with Prettier
- `pnpm lint` - Run ESLint with auto-fix
- `pnpm lint:check` - Check linting without fixing
- `pnpm type-check` - TypeScript type checking
- `pnpm test` - Run tests with Vitest
- `pnpm test:watch` - Run tests in watch mode
- `pnpm test:coverage` - Run tests with coverage report
- `pnpm test:ui` - Run tests with UI interface
- `pnpm check-all` - Run all quality checks
- `pnpm fix-all` - Auto-fix all issues possible

**Environment Setup**:
- Copy `.env.example` to `.env` and configure tracking service API credentials
- **Trakt.tv**: `TRAKT_CLIENT_ID`, `TRAKT_CLIENT_SECRET`
- **AniList**: `ANILIST_CLIENT_ID`, `ANILIST_CLIENT_SECRET` (optional - for AniList integration)
- Services can be enabled/disabled individually based on available credentials

## Project Architecture

TMSync is a Chrome extension that integrates streaming sites with multiple tracking services (Trakt.tv, AniList) for automatic scrobbling and watch tracking. The extension features a multi-service architecture that can support multiple tracking services simultaneously.

### Core Architecture Patterns

**Multi-Service Architecture Pattern**:
- `TrackerService` interface defines common operations for all tracking services
- Service-specific implementations: `TraktService`, `AniListService` 
- `ServiceRegistry` manages multiple services with priority and capability filtering
- Service-agnostic types (`ServiceComment`, `ServiceProgressInfo`, `ServiceMediaRatings`) abstract away service differences

**Message Handler Pattern (Background Script)**:
- Background script at `src/background/index.ts` uses a dispatcher pattern
- Message handlers are modular functions in `src/background/handlers/`
- Each handler corresponds to a specific action (scrobble, rate, comment, etc.)
- Handlers use service-agnostic types for multi-service compatibility

**Custom Hook Pattern (React Components)**:
- Complex stateful logic is extracted into custom hooks to avoid "God Components"
- Key hooks:
  - `useMediaLifecycle`: Main controller for media detection, identification, and UI state management (uses service-agnostic types)
  - `useScrobbling`: Manages video player interaction and scrobbling state machine (works with multiple services)
  - `useTraktAuth`: Handles OAuth authentication with Trakt.tv (service-specific authentication hook)

**Site Configuration Pattern**:
- Each supported streaming site has a configuration class in `src/utils/siteConfigs/`
- Base configuration interface in `baseConfig.ts`
- Site-specific implementations (hexa.ts, xprime.ts, etc.) extend base config

### Key Components

**Content Scripts**:
- `src/content-scripts/main/`: Injected into streaming sites for scrobbling
- `src/content-scripts/trakt/`: Injected into Trakt.tv pages for quick links

**Background State Management**:
- Global scrobbling state managed in `src/background/state.ts`
- Handles tab close/navigation events to properly stop scrobbles

**Shadow DOM Implementation**:
- UI components use Shadow DOM for style isolation
- Critical event handling guard in `src/content-scripts/main/index.tsx` prevents conflicts with other extensions

### TypeScript Types

**Key Type Definitions**:
- `src/types/media.ts`: Media information, ratings, and episode structures
- `src/types/messaging.ts`: Message passing between content scripts and background (uses service-agnostic types)
- `src/types/scrobbling.ts`: Scrobbling state and progress tracking
- `src/types/services.ts`: TrackerService interface and ServiceRegistry definitions
- `src/types/serviceTypes.ts`: Service-agnostic types for multi-service compatibility
- `src/types/trakt.ts`: Trakt.tv API response structures

### Extension Structure

**Entry Points**:
- Background script: `src/background/index.ts`
- Main content script: `src/content-scripts/main/index.tsx`
- Trakt content script: `src/content-scripts/trakt/index.tsx`
- Options page: `src/options/index.tsx`
- Popup: `src/popup/index.tsx`

**Service Architecture**:
- Service implementations: `src/services/TraktService.ts`, `src/services/AniListService.ts`
- Service management: `src/services/ServiceRegistry.ts`
- Service initialization: `src/services/index.ts`
- Multi-service test: `src/test-services.ts`

**Build Configuration**:
- Webpack configuration in `webpack/` directory
- TypeScript configuration in `tsconfig.json`
- Manifest and static assets in `public/`

## Development Notes

**Commit Strategy**:

**For Complete Features**:
- Commit only when a feature is complete and working as intended
- Each commit should represent a complete, production-ready feature or fix
- Use descriptive commit messages explaining the "why" not just "what"
- This creates clean history for easy reverting and better code review
- Major architectural changes (like completing a full phase) should be single comprehensive commits
- Always run `npm run check-all` before committing to ensure code quality

**For Iterative Development**:
- When developing complex features that require multiple iterations and user feedback:
  - Work in a feature branch with intermediate commits for safety/checkpoints
  - Use `git commit --amend` or interactive rebase to refine commits during development
  - Squash incremental commits into single cohesive feature commit when complete
  - Only merge/push final polished commits to main branch history
- If you need to commit incomplete work for context preservation:
  - Use clear WIP (Work In Progress) prefixes: `wip: partial implementation of X`
  - Always squash/rebase these into proper commits before considering the work complete
- Example workflow: `git rebase -i HEAD~3` to squash last 3 commits into one coherent feature

**Commit Message Quality**:
- Focus on the user-facing impact and technical reasoning
- Bad: "fix stars" Good: "fix: resolve half-star hover precision and prevent text flickering"
- Include context about why the change was needed
- Reference any architectural decisions or tradeoffs made

**Event Handling Conflicts**:
The extension uses a global keydown event guard to prevent conflicts with other extensions. This relies on timing - the extension's event listener must attach before conflicting extensions. A more robust solution would use iframe sandboxing.

**Media Detection Flow**:
1. Site config detects media type and extracts metadata
2. Background script queries tracking service APIs (Trakt.tv, AniList) for media information
3. ServiceRegistry determines which services can handle the media type
4. Custom hook processes service responses and determines UI state
5. User confirms or manually selects media if confidence is low
6. Scrobbling begins once media is confirmed, using appropriate services based on capabilities

**State Management**:
- React component state managed through custom hooks
- Extension-wide state (scrobbling status) managed in background script
- Local storage used for rewatch tracking and user preferences
- Multi-service state managed through ServiceRegistry with priority-based service selection

**Multi-Service Architecture Guidelines**:
- All new handlers should use service-agnostic types (ServiceComment, ServiceProgressInfo, etc.)
- Use ServiceRegistry to get services with specific capabilities rather than direct service imports
- When adding new features, implement them in the TrackerService interface first
- Service-specific implementations should convert their native types to service-agnostic types
- Test multi-service functionality using `npx tsx src/test-services.ts`
- Run `npm run type-check` after any service-related changes to ensure interface compliance
- Each service should handle its own authentication and error states gracefully

**Context Recovery Protocol**:
When starting a new session or after context compaction:
1. Read `TODO.md` for current phase and pending tasks
2. Read `CURRENT_STATE.md` for recent work and architecture status
3. Read `DESIGN_DECISIONS.md` for product design rationale and user preferences
4. Run `git log --oneline -5` to see recent commits
5. Check current git status with `git status`
6. Verify system health with `pnpm type-check`

**Automated Workflow Commands**:
Use these custom slash commands for consistent workflow:
- `/project:context-recovery` - Execute full context recovery protocol
- `/project:smart-commit` - Commit with proper message format and quality checks
- `/project:next-task` - Identify and start next priority task
- `/project:workflow-health` - Comprehensive project health check

**Session Triggers**:
- **New Session**: Always run `/project:context-recovery` first
- **After Significant Work**: Run `/project:smart-commit` to maintain clean history
- **When Uncertain**: Run `/project:workflow-health` to identify issues
- **Between Tasks**: Run `/project:next-task` to maintain momentum

**File-Based State Management**:
- `TODO.md` - Current problems to solve and phase status (problem-solving focused, not task-execution)
- `CURRENT_STATE.md` - Architecture status and last major work (update after significant changes)
- `CLAUDE.md` - Timeless development guidelines and architecture documentation
- `DESIGN_DECISIONS.md` - Product design decisions and rationale (collaborative UX/product choices)

**Creative Collaboration Guidelines**:

- TODOs are problems to solve, not tasks to execute - approach them with creative thinking
- Challenge architectural decisions if you see better approaches or potential issues
- Suggest alternative solutions when the success criteria could be met differently
- Ask clarifying questions about user needs and edge cases before implementing
- Follow established patterns and user direction when technically sound
- Question assumptions when they might lead to technical debt or poor UX

**Debugging Protocol**:

- **UI Issues**: Trace from what user sees ‚Üí find actual rendering component (not assumed component)
- **Component Issues**: Always `rg "import.*ComponentName"` to find real usage before debugging
- **Duplicate Code**: Search for similar patterns, especially status/UI logic that might be duplicated
- **Dead Code**: Remove unused components immediately when discovered to avoid confusion

## When to Challenge vs When to Follow

- **Challenge**: Technical debt risks, architectural inconsistencies, overlooked edge cases, better UX alternatives
- **Follow**: Domain-specific decisions, intentional tradeoffs, technically sound approaches, explicit user preferences
- **Collaborate**: Explore questions in TODO.md, suggest approaches from "Alternative Approaches" sections

## Development Roadmap

**Phase 1: Development Infrastructure & Best Practices** ‚úÖ COMPLETED
- Comprehensive package.json scripts for development workflow
- Vitest testing framework with Chrome extension mocks
- Pre-commit hooks with Husky + lint-staged for code quality
- Enhanced TypeScript configuration with stricter settings
- GitHub Actions CI/CD pipeline for automated testing and releases

**Phase 2: Multi-Service Architecture Foundation** ‚úÖ COMPLETED
- ‚úÖ Created TrackerService interface defining common operations for all tracking services
- ‚úÖ Implemented TraktService class with full TrackerService interface compliance
- ‚úÖ Implemented AniListService class with TrackerService interface (GraphQL API integration)
- ‚úÖ Created ServiceRegistry for managing multiple services with priority and capability filtering
- ‚úÖ Added service-agnostic types (ServiceComment, ServiceProgressInfo, ServiceMediaRatings, etc.)
- ‚úÖ Updated all handlers and components to use service-agnostic types
- ‚úÖ Created service initialization and testing infrastructure
- üîÑ Service configuration management for API keys and settings (partial - basic OAuth flows implemented)
- üìã Create MediaIdentifier service for cross-service mapping (deferred to Phase 4)
- üìã Implement confidence scoring for media matching (deferred to Phase 4)
- üìã Add database mapping utilities for episode/season reconciliation (deferred to Phase 4)

**Phase 3: UI/UX Multi-Service Integration** ‚úÖ COMPLETED
- ‚úÖ Refactor rating system with service-specific translation (basic implementation completed)
- ‚úÖ Create service-aware comment/notes system (completed with ServiceComment type)
- ‚úÖ Add multi-service status indicators in UI (real-time service status badges)
- ‚úÖ Add service selection and configuration in options page (global service toggles)
- ‚úÖ Create multi-service authentication management UI (unified auth hub)
- ‚úÖ Add service-specific error handling and user feedback (status indicators + filtering)
- üîÑ Implement service-specific confirmation prompts (deferred - tackle organically when needed)

**Phase 4: Advanced Features & Edge Cases**
- Implement EpisodeMapper service for complex show structures
- Create MediaIdentifier service for cross-service mapping
- Implement confidence scoring for media matching across services
- Add database mapping utilities for episode/season reconciliation
- Add crowd-sourced mapping support
- Create user-driven corrections and community validation
- Implement MyAnimeList service integration
- Add service-specific media type handling (anime/manga support)
- Create conflict resolution for differing service data
</file>

<file path="src/utils/siteConfigs/baseConfig.ts">
import { TraktPageInfo } from '../../content-scripts/trakt';
import { waitForElm } from '../content';
import { SeasonEpisodeObj } from '../../types/media';

interface MediaInfoSelectors {
    title: string;
    year: string;
}

export type MediaType = 'movie' | 'show' | null;

export interface EpisodeListContextConfig {
    containerSelector: string;
    itemSelector: string;
    getSeasonEpisodeFromElement: (
        itemElement: Element,
        containerElement: Element
    ) => { season: number; episode: number } | null;
    getElementToStyle: (itemElement: Element) => HTMLElement | null;
}

export interface SiteConfigBase {
    name: string;
    selectorType: 'css' | 'xpath';
    urlPatterns: {
        movie: RegExp;
        show: RegExp;
    };
    selectors: {
        movie: MediaInfoSelectors;
        show: MediaInfoSelectors;
    };

    usesTmdbId?: boolean;
    getTmdbId?(url: string): string | null;
    tmdbIdUrlPatterns?: {
        movie: RegExp;
        show: RegExp;
    };
    usesIframePlayer?: boolean;
    iframePlayerSelector?: string;

    isWatchPage(url: string): boolean;
    isShowPage(url: string): boolean;
    isMoviePage(url: string): boolean;
    getMediaType(url: string): MediaType;
    getUrlIdentifier(url: string): string;
    getSeasonEpisodeObj(url: string): SeasonEpisodeObj | null;

    getTitle(url: string): Promise<string | null>;
    getYear(url: string): Promise<string | null>;

    highlighting?: {
        contexts: Record<string, EpisodeListContextConfig>;
        getCurrentHighlightContextKey?: (url: string) => string | null;
    };

    generateWatchLink?: (pageInfo: TraktPageInfo) => string | null;
}

export const createSiteConfig = (
    config: Partial<SiteConfigBase>
): SiteConfigBase => {
    const defaults: SiteConfigBase = {
        name: '',
        selectorType: 'css',
        urlPatterns: { movie: /^$/, show: /^$/ },
        selectors: {
            movie: { title: '', year: '' },
            show: { title: '', year: '' }
        },
        usesTmdbId: false,
        tmdbIdUrlPatterns: undefined,

        getTmdbId(url: string): string | null {
            const urlObj = new URL(url);
            const path = urlObj.pathname;

            if (this.tmdbIdUrlPatterns?.movie?.test(path)) {
                const match = path.match(/\/(\d+)$/);
                return match ? match[1] : null;
            }
            if (this.tmdbIdUrlPatterns?.show?.test(path)) {
                const match = path.match(/\/(\d+)/);
                return match ? match[1] : null;
            }
            return null;
        },

        getMediaType(url: string): MediaType {
            const urlObj = new URL(url);
            const path = urlObj.pathname;
            if (this.tmdbIdUrlPatterns?.movie?.test(path)) return 'movie';
            if (this.tmdbIdUrlPatterns?.show?.test(path)) return 'show';
            if (this.urlPatterns.movie.test(path)) return 'movie';
            if (this.urlPatterns.show.test(path)) return 'show';
            return null;
        },

        isWatchPage(url: string): boolean {
            return this.getMediaType(url) !== null;
        },

        isShowPage(url: string): boolean {
            return this.getMediaType(url) === 'show';
        },

        isMoviePage(url: string): boolean {
            return this.getMediaType(url) === 'movie';
        },

        getUrlIdentifier(url: string): string {
            const urlObj = new URL(url);
            if (this.isWatchPage(url)) {
                return `${urlObj.hostname}${urlObj.pathname}`;
            }
            return '';
        },

        getSeasonEpisodeObj(url: string): SeasonEpisodeObj | null {
            return null;
        },

        async getTitle(url: string): Promise<string | null> {
            if (!this.isWatchPage(url)) return null;
            let selector = '';
            if (this.isMoviePage(url)) {
                selector = this.selectors.movie.title;
            } else if (this.isShowPage(url)) {
                selector = this.selectors.show.title;
            }
            if (!selector) return null;
            try {
                const element = await waitForElm(
                    selector,
                    this.selectorType === 'xpath'
                );
                return element?.textContent?.trim() || null;
            } catch (error) {
                console.error(`Error getting title for ${url}:`, error);
                return null;
            }
        },

        async getYear(url: string): Promise<string | null> {
            if (!this.isWatchPage(url)) return null;
            let selector = '';
            if (this.isMoviePage(url)) {
                selector = this.selectors.movie.year;
            } else if (this.isShowPage(url)) {
                selector = this.selectors.show.year;
            }
            if (!selector) return null;
            try {
                const element = await waitForElm(
                    selector,
                    this.selectorType === 'xpath'
                );
                const text = element?.textContent?.trim();
                if (!text) return null;
                const yearMatch = text.match(/\b(19|20)\d{2}\b/);
                return yearMatch ? yearMatch[0] : text;
            } catch (error) {
                console.error(`Error getting year for ${url}:`, error);
                return null;
            }
        },
        highlighting: undefined,
        generateWatchLink: undefined
    };

    const finalConfig: SiteConfigBase = {
        ...defaults,
        ...config,

        urlPatterns: {
            ...defaults.urlPatterns,
            ...(config.urlPatterns ?? {})
        },
        selectors: {
            movie: config.selectors?.movie ?? defaults.selectors?.movie,
            show: config.selectors?.show ?? defaults.selectors?.show,
            ...(config.selectors ?? {})
        },

        tmdbIdUrlPatterns:
            config.tmdbIdUrlPatterns ?? defaults.tmdbIdUrlPatterns,
        highlighting: config.highlighting ?? defaults.highlighting
    };

    return finalConfig;
};
</file>

<file path="public/manifest.json">
{
    "manifest_version": 3,
    "name": "TMSync",
    "version": "1.0",
    "action": {
        "default_popup": "popup.html"
    },
    "options_page": "options.html",
    "permissions": ["identity", "storage"],
    "host_permissions": ["https://api.trakt.tv/*/", "https://anilist.co/*/", "https://graphql.anilist.co/"],
    "content_scripts": [
        {
            "js": ["js/vendor.js", "js/contentScript.js"],
            "matches": [
                "https://www.cineby.app/*",
                "https://freek.to/*",
                "https://hydrahd.me/*",
                "https://hydrahd.ac/*",
                "https://popcornmovies.to/*",
                "https://mcloud.bz/*",
                "https://vid2faf.site/*",
                "https://vidsrc.cc/*",
                "https://vidsrc.su/*",
                "https://vidsrc.vip/*",
                "https://vidsrc.pro/*",
                "https://ythd.org/*",
                "https://embed.su/*",
                "https://*.autoembed.cc/*",
                "https://vidlink.pro/*",
                "https://*.videasy.net/*",
                "https://*.2embed.cc/*",
                "https://edgedeliverynetwork.com/*",
                "https://vid3c.site/*",
                "https://*.moviesapi.club/*",
                "https://stre4mplay.one/*",
                "https://hexa.watch/*",
                "https://xprime.tv/*"
            ],
            "all_frames": true
        },
        {
            "js": ["js/vendor.js", "js/traktContentScript.js"],
            "matches": ["*://trakt.tv/shows/*", "*://trakt.tv/movies/*"]
        }
    ],
    "web_accessible_resources": [
        {
            "resources": ["css/styles.css"],
            "matches": ["<all_urls>"]
        },
        {
            "resources": ["images/logos/*.png"],
            "matches": ["*://trakt.tv/*"]
        }
    ],
    "background": {
        "service_worker": "js/background.js"
    },
    "key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnHwVw4cwX6aSFK+k5dw4oSnqAiHJy7skS0+pAeT1L3xv29dVaMnz2ENO0l8pA4vGo4pUd+97SmMFJ6aj2gKj8Uq0Cw5c1Ke1E+vMneV4eFhb3jqlRPIuavihIBlSK27bR/WNm3mIUgeguKcyl7nF6NqWBKei8NcDEfthzZD/9zHwTEE/ep6TsN9E6PhO7DzpXUs8K1qsh/kpa9EL18vgpxzEnA9G6Ma/RVevJFnqPOxpJ79sSmQbk6kaVzlI3VtSr3fzPK/wYsNSGgHRp1Oy5f+x+SJ2f3Omb0LRBdKGnZcRCOBArl5G2xxcHwZln0TAIXHN0tsbMO4SPUdPSZJDawIDAQAB"
}
</file>

</files>
